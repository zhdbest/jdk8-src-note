[{"id":0,"href":"/jdk8-src-note/","title":"JDK8源码阅读笔记","parent":"","content":"","description":""},{"id":1,"href":"/jdk8-src-note/java/nio/ByteOrder/","title":"ByteOrder","parent":"nio","content":" 字节顺序的类型安全枚举。\n1. private String name; 2. public static final ByteOrder BIG_ENDIAN = new ByteOrder(\u0026ldquo;BIG_ENDIAN\u0026rdquo;); 3. public static final ByteOrder LITTLE_ENDIAN = new ByteOrder(\u0026ldquo;LITTLE_ENDIAN\u0026rdquo;); 4. public static ByteOrder nativeOrder() 5. public String toString() 1. private String name; 字节顺序的名称。\n2. public static final ByteOrder BIG_ENDIAN = new ByteOrder(\u0026ldquo;BIG_ENDIAN\u0026rdquo;); 表示大端字节序的常量。在这个顺序中，多字节值的字节从最高位到最低位排列。\n3. public static final ByteOrder LITTLE_ENDIAN = new ByteOrder(\u0026ldquo;LITTLE_ENDIAN\u0026rdquo;); 表示小端字节序的常量。在这个顺序中，多字节值的字节从最低位到最高位排列。\n4. public static ByteOrder nativeOrder() 获取底层平台的本地字节序。\n定义此方法是为了使性能敏感的Java代码可以分配与硬件具有相同字节序的直接缓冲区。当使用这样的缓冲区时，本地代码库通常更高效。\n该方法返回运行此Java虚拟机的硬件的本机字节序。\npublic static ByteOrder nativeOrder() { return Bits.byteOrder(); } 5. public String toString() 构造一个描述此对象的字符串。\n此方法为BIG_ENDIAN返回字符串“BIG_ENDDIAN”，为LITTLE_ENDIAN返回字符串“LITTLE_ENDIAN”。\npublic String toString() { return name; } ","description":"字节顺序的类型安全枚举。\n1. private String name; 2. public static final ByteOrder BIG_ENDIAN = new ByteOrder(\u0026ldquo;BIG_ENDIAN\u0026rdquo;); 3. public static final ByteOrder LITTLE_ENDIAN = new ByteOrder(\u0026ldquo;LITTLE_ENDIAN\u0026rdquo;); 4. public static ByteOrder nativeOrder() 5. public String toString() 1. private String name; 字节顺序的名称。\n2. public static final ByteOrder BIG_ENDIAN = new ByteOrder(\u0026ldquo;BIG_ENDIAN\u0026rdquo;); 表示大端字节序的常量。在这个顺序中，多字节值的字节从最高位到最低位排列。\n3. public static final ByteOrder LITTLE_ENDIAN = new ByteOrder(\u0026ldquo;LITTLE_ENDIAN\u0026rdquo;); 表示小端字节序的常量。在这个顺序中，多字节值的字节从最低位到最高位排列。\n4. public static ByteOrder nativeOrder() 获取底层平台的本地字节序。\n定义此方法是为了使性能敏感的Java代码可以分配与硬件具有相同字节序的直接缓冲区。当使用这样的缓冲区时，本地代码库通常更高效。\n该方法返回运行此Java虚拟机的硬件的本机字节序。\npublic static ByteOrder nativeOrder() { return Bits."},{"id":2,"href":"/jdk8-src-note/java/nio/ReadOnlyBufferException/","title":"ReadOnlyBufferException","parent":"nio","content":" 1. public ReadOnlyBufferException() { } 在只读缓冲区上调用内容突变方法（如put或compact）时会引发此不受检查的异常。\n1. public ReadOnlyBufferException() { } 构造此类的一个实例。\n","description":"1. public ReadOnlyBufferException() { } 在只读缓冲区上调用内容突变方法（如put或compact）时会引发此不受检查的异常。\n1. public ReadOnlyBufferException() { } 构造此类的一个实例。"},{"id":3,"href":"/jdk8-src-note/java/nio/InvalidMarkException/","title":"InvalidMarkException","parent":"nio","content":" 1. public InvalidMarkException() { } 在未定义缓冲区标记的情况下尝试重置缓冲区时会引发此不受检查的异常。\n1. public InvalidMarkException() { } 构造此类的一个实例。\n","description":"1. public InvalidMarkException() { } 在未定义缓冲区标记的情况下尝试重置缓冲区时会引发此不受检查的异常。\n1. public InvalidMarkException() { } 构造此类的一个实例。"},{"id":4,"href":"/jdk8-src-note/java/nio/BufferOverflowException/","title":"BufferOverflowException","parent":"nio","content":" 1. public BufferOverflowException() { } 当相对put操作达到目标缓冲区的限制时，会抛出此不受检查的异常。\n1. public BufferOverflowException() { } 构造此类的一个实例。\n","description":"1. public BufferOverflowException() { } 当相对put操作达到目标缓冲区的限制时，会抛出此不受检查的异常。\n1. public BufferOverflowException() { } 构造此类的一个实例。"},{"id":5,"href":"/jdk8-src-note/java/nio/BufferUnderflowException/","title":"BufferUnderflowException","parent":"nio","content":" 1. public BufferUnderflowException() { } 当相对get操作达到源缓冲区的限制时，会抛出此不受检查的异常。\n1. public BufferUnderflowException() { } 构造此类的一个实例。\n","description":"1. public BufferUnderflowException() { } 当相对get操作达到源缓冲区的限制时，会抛出此不受检查的异常。\n1. public BufferUnderflowException() { } 构造此类的一个实例。"},{"id":6,"href":"/jdk8-src-note/java/nio/ByteBuffer/","title":"ByteBuffer","parent":"nio","content":" 1. final byte[] hb; 2. final int offset; 3. boolean isReadOnly; 4. ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) 5. ByteBuffer(int mark, int pos, int lim, int cap) 6. public static ByteBuffer allocateDirect(int capacity) 7. public static ByteBuffer allocate(int capacity) 8. public static ByteBuffer wrap(byte[] array, int offset, int length) 9. public static ByteBuffer wrap(byte[] array) 10. public abstract ByteBuffer slice(); 11. public abstract ByteBuffer duplicate(); 12. public abstract ByteBuffer asReadOnlyBuffer(); 13. public abstract byte get(); 14. public abstract ByteBuffer put(byte b); 15. public abstract byte get(int index); 16. public abstract ByteBuffer put(int index, byte b); 17. public ByteBuffer get(byte[] dst, int offset, int length) 18. public ByteBuffer get(byte[] dst) 19. public ByteBuffer put(ByteBuffer src) 20. public ByteBuffer put(byte[] src, int offset, int length) 21. public final ByteBuffer put(byte[] src) 22. public final boolean hasArray() 23. public final byte[] array() 24. public final int arrayOffset() 25. public abstract ByteBuffer compact(); 26. public abstract boolean isDirect(); 27. public String toString() 28. public int hashCode() 29. public boolean equals(Object ob) 30. private static boolean equals(byte x, byte y) 31. public int compareTo(ByteBuffer that) 32. private static int compare(byte x, byte y) 33. boolean bigEndian = true; 34. boolean nativeByteOrder = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN); 35. public final ByteOrder order() 36. public final ByteBuffer order(ByteOrder bo) 37. abstract byte _get(int i); 38. abstract void _put(int i, byte b); 39. public abstract char getChar(); 40. public abstract ByteBuffer putChar(char value); 41. public abstract char getChar(int index); 42. public abstract ByteBuffer putChar(int index, char value); 43. public abstract CharBuffer asCharBuffer(); 44. public abstract short getShort(); 45. public abstract ByteBuffer putShort(short value); 46. public abstract short getShort(int index); 47. public abstract ByteBuffer putShort(int index, short value); 48. public abstract ShortBuffer asShortBuffer(); 49. public abstract int getInt(); 50. public abstract ByteBuffer putInt(int value); 51. public abstract int getInt(int index); 52. public abstract ByteBuffer putInt(int index, int value); 53. public abstract IntBuffer asIntBuffer(); 54. public abstract long getLong(); 55. public abstract ByteBuffer putLong(long value); 56. public abstract long getLong(int index); 57. public abstract ByteBuffer putLong(int index, long value); 58. public abstract LongBuffer asLongBuffer(); 59. public abstract float getFloat(); 60. public abstract ByteBuffer putFloat(float value); 61. public abstract float getFloat(int index); 62. public abstract ByteBuffer putFloat(int index, float value); 63. public abstract FloatBuffer asFloatBuffer(); 64. public abstract double getDouble(); 65. public abstract ByteBuffer putDouble(double value); 66. public abstract double getDouble(int index); 67. public abstract ByteBuffer putDouble(int index, double value); 68. public abstract DoubleBuffer asDoubleBuffer(); 字节缓冲区。\n此类定义了字节缓冲区上的六类操作：\n读取和写入单个字节的绝对和相对get和put方法。 相对批量get方法，将连续的字节序列从此缓冲区转移到数组中。 将连续的字节序列从字节数组或某个其他字节缓冲区转移到该缓冲区的相对批量put方法。 绝对和相对的get和put方法用于读取和写入其他原始类型的值，将它们转换为特定字节顺序的字节序列。 方法用于创建视图缓冲区，这允许一个字节缓冲区被视作包含其他原始类型的值的缓冲区。 压缩、复制和切片字节缓冲区的方法。 字节缓冲区可以通过分配（为缓冲区的内容分配空间）或将现有字节数组包装到缓冲区中来创建。\n直接缓冲区与非直接缓冲区\n一个字节缓冲区要么是直接的，要么是不是直接的。对于一个直接字节缓冲区，Java虚拟机会尽最大努力直接在其上执行本地I/O操作。也就是说，它将尝试避免在每次调用底层操作系统的本地I/O操作之前（或之后）将缓冲区的内容复制到一个中间缓冲区（或从一个中间缓冲区复制到缓冲区）。\n直接字节缓冲区可以通过调用这个类的allocateDirect工厂方法来创建。这个方法返回的缓冲区在分配和释放成本上通常比非直接缓冲区要高一些。直接缓冲区的内容可能位于常规垃圾回收堆之外，因此它们对应用程序内存占用的影响可能不是很明显。因此，建议主要为大型、长期存在的缓冲区分配直接缓冲区，这些缓冲区将受到底层系统本地I/O操作的影响。通常情况下，最好只有在直接缓冲区能够在程序性能上带来可衡量的提升时，才分配直接缓冲区。\n还可以通过将文件的区域直接映射到内存中来创建直接字节缓冲区。Java平台的实现可以选择性地支持通过JNI从本地代码创建直接字节缓冲区。如果这些类型的缓冲区中的一个实例引用了一个不可访问的内存区域，那么访问该区域的尝试将不会更改缓冲区的内容，并将导致在访问时或稍后引发不受检查的异常。\n一个字节缓冲区是直接的还是非直接的，可以通过调用它的isDirect方法来确定。提供这个方法是为了能够在性能关键型代码中进行显式的缓冲区管理。\n访问二进制数据\n这个类定义了除了布尔类型之外的所有其他基本类型值读取和写入的方法。基本类型值根据缓冲区的当前字节序被转换为字节序列（或基于字节序列转换为当前字节序），当前字节序可以通过order方法获取和修改。特定的字节序由ByteOrder类的实例表示。字节缓冲区的初始字节序始终是BIG_ENDIAN（大端序）。\n用于访问异构二进制数据，即不同类型值的序列，这个类为每种类型定义了一系列绝对和相对的 get 和 put 方法。例如，对于32位浮点值，这个类定义了：\nfloat getFloat() float getFloat(int index) void putFloat(float f) void putFloat(int index, float f) 本类为 char、short、int、long 和 double 类型定义了相应的方法。绝对 get 和 put 方法的索引参数是以字节为单位，而不是基于正在读取或写入的类型。\n为了访问同类型二进制数据，即相同类型值的序列，这个类定义了可以创建给定字节缓冲区视图的方法。视图缓冲区实际上是另一个缓冲区，其内容由字节缓冲区支持。对字节缓冲区内容的更改将在视图缓冲区中可见，反之亦然；这两个缓冲区的位置、限制和标记值是独立的。例如，asFloatBuffer方法创建了一个FloatBuffer类的实例，它由调用该方法的字节缓冲区支持。本类为 char、short、int、long 和 double 类型定义了相应的视图创建方法。\n视图缓冲区与上述特定类型的 get 和 put 方法相比具有三个重要优势：\n视图缓冲区的索引不是以字节为单位，而是以其值的类型特定大小为单位； 视图缓冲区提供了相对的批量 get 和 put 方法，这些方法可以在缓冲区与数组或其他相同类型的缓冲区之间传输连续的值序列； 视图缓冲区可能效率更高，因为如果仅当其支持的字节缓冲区是直接的，它才会是直接的。 视图缓冲区的字节序在创建视图时固定为其字节缓冲区的字节序。\n调用链 这个类中没有其他返回值要返回的方法被指定为返回它们被调用的缓冲区。这允许将方法调用链接在一起。如下语句：\nbb. putInt(0xCAFEBABE); bb. putShort(3); bb. putShort(45); 可以用如下单个语句替换：\nbb. putInt(0xCAFEBABE).putShort(3).putShort(45); 1. final byte[] hb; 这个字段还有下面的offset、isReadOnly字段在这里声明，而不是在“Heap-X-Buffer”中声明，目的是为了减少访问这些值所需的虚拟方法调用次数，这在编码小缓冲区时尤其耗费成本。\n字节数组，非空、仅适用于堆缓冲区。\n2. final int offset; 偏移量。\n3. boolean isReadOnly; 当前字节缓冲区是否只读。仅对堆缓冲区有效。\n4. ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) 基于给出的mark，position，limit，capacity，后备数组和数组偏移量创建一个字节缓冲区。\nByteBuffer(int mark, int pos, int lim, int cap, // 包内私有 byte[] hb, int offset) { super(mark, pos, lim, cap); this.hb = hb; this.offset = offset; } 5. ByteBuffer(int mark, int pos, int lim, int cap) 基于给出的mark，position，limit，capacity创建一个字节缓冲区。\nByteBuffer(int mark, int pos, int lim, int cap) { // 包内私有 this(mark, pos, lim, cap, null, 0); } 6. public static ByteBuffer allocateDirect(int capacity) 分配一个新的直接字节缓冲区。\n新缓冲区的位置将为零，其限制将为其容量，其标记将未定义，其每个元素将被初始化为零。它是否有支持数组是未指明的。\n参数capacity是新缓冲区的容量（字节）。\npublic static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } 7. public static ByteBuffer allocate(int capacity) 分配一个新的字节缓冲区。\n新缓冲区的位置将被设置为零，其限制将等于其容量，其标记将未定义，其所有元素将被初始化为零。它将拥有一个后备数组，并且其数组偏移量将为零。\n参数capacity是新缓冲区的容量（字节）。\npublic static ByteBuffer allocate(int capacity) { if (capacity \u0026lt; 0) throw new IllegalArgumentException(); return new HeapByteBuffer(capacity, capacity); } 8. public static ByteBuffer wrap(byte[] array, int offset, int length) 将字节数组封装到缓冲区中。\n新缓冲区将基于给定的字节数组，也就是说，对缓冲区的修改将导致数组被修改，反之亦然。新缓冲区的容量将为数组的长度，其位置将为偏移量，其限制将为偏移量加数组长度，其标记将未定义。它的支持数组将是给定的数组，其数组偏移量将为零。\n参数：\narray：将支持新缓冲区的数组 offset：要使用的子数组的偏移量；必须是非负的并且不大于数组的长度。新缓冲区的位置将设置为此值。 length：要使用的子数组的长度；必须是非负数，并且不大于 数组长度 - offset。新缓冲区的限制将被设置为 offset + length。 public static ByteBuffer wrap(byte[] array, int offset, int length) { try { return new HeapByteBuffer(array, offset, length); } catch (IllegalArgumentException x) { throw new IndexOutOfBoundsException(); } } 9. public static ByteBuffer wrap(byte[] array) 将字节数组封装到缓冲区中。\n新缓冲区将由给定的字节数组支持；也就是说，对缓冲区的修改将导致数组被修改，反之亦然。新缓冲区的容量和限制将为数组的长度，其位置将为零，其标记将未定义。它的支持数组将是给定的数组，其数组偏移量将为零。\npublic static ByteBuffer wrap(byte[] array) { return wrap(array, 0, array.length); } 10. public abstract ByteBuffer slice(); 创建一个新的字节缓冲区，其内容是这个缓冲区内容的共享子序列。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余的字节数，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n11. public abstract ByteBuffer duplicate(); 创建一个新的字节缓冲区，与这个缓冲区共享内容。\n新缓冲区的内容将与这个缓冲区的内容相同。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的容量、限制、位置和标记值将与这个缓冲区的完全相同。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n12. public abstract ByteBuffer asReadOnlyBuffer(); 创建一个新的只读字节缓冲区，与这个缓冲区共享内容。\n新缓冲区的内容将与这个缓冲区的内容相同。对这个缓冲区内容的更改将在新缓冲区中可见；然而，新缓冲区本身是只读的，不允许修改共享的内容。两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的容量、限制、位置和标记值将与这个缓冲区的完全相同。\n如果这个缓冲区本身是只读的，那么这个方法的行为与duplicate方法完全相同。\n13. public abstract byte get(); 相对 get 方法。读取这个缓冲区当前位置的字节，然后增加位置。\n14. public abstract ByteBuffer put(byte b); 相对 put 方法（可选操作）。\n将给定的字节写入此缓冲区的当前位置，然后增加位置。\n15. public abstract byte get(int index); 绝对获取方法。读取给定索引处的字节。\n16. public abstract ByteBuffer put(int index, byte b); 绝对 put 方法（可选操作）。\n将给定的字节写入到此缓冲区给定的索引位置。\n17. public ByteBuffer get(byte[] dst, int offset, int length) 相对批量获取方法。\n这个方法将字节从这个缓冲区传输到给定的目标数组。如果在缓冲区中剩余的字节少于请求所需的字节，也就是说，如果 length \u0026gt; remaining()，那么将不会传输任何字节，并抛出BufferUnderflowException异常。\n否则，这个方法将从这个缓冲区的当前位置开始，复制length长度的字节到给定数组中给定的偏移量位置。然后，这个缓冲区的位置会增加length。\n换句话说，以src.get(dst, off, len)形式调用这个方法，其效果与以下循环完全相同：\nfor (int i = off; i \u0026lt; off + len; i++) dst[i] = src. get(): 除了在执行循环之前，它首先检查这个缓冲区中是否有足够的字节，并且它的效率可能要高得多。\n参数说明：\ndst：要写入字节的数组 offset：数组中第一个要写入的字节的偏移量；必须是非负数，并且不大于 dst.length。 length：写入给定数组的最大字节数；必须是非负数，并且不大于 dst.length - offset。 public ByteBuffer get(byte[] dst, int offset, int length) { checkBounds(offset, length, dst.length); if (length \u0026gt; remaining()) throw new BufferUnderflowException(); int end = offset + length; for (int i = offset; i \u0026lt; end; i++) dst[i] = get(); return this; } 18. public ByteBuffer get(byte[] dst) 相对的批量 get 方法。 这个方法将字节从这个缓冲区传输到给定的目标数组。以src.get(a)形式调用这个方法的行为与调用src.get(a, 0, a.length)完全相同。\npublic ByteBuffer get(byte[] dst) { return get(dst, 0, dst.length); } 19. public ByteBuffer put(ByteBuffer src) 相对的批量 put 方法（可选操作）。\n这个方法将给定源缓冲区中剩余的字节传输到当前缓冲区。如果在源缓冲区中剩余的字节比这个缓冲区多，也就是说，如果src.remaining() \u0026gt; remaining()，那么将不会传输任何字节，并抛出BufferOverflowException异常。\n否则，这个方法从给定的缓冲区复制n个字节到这个缓冲区（n = src.remaining()），从每个缓冲区的当前位置开始，然后两个缓冲区的位置都增加 n。\n换句话说，以dst.put(src)形式调用这个方法的效果与以下循环完全相同：\nwhile (src. hasRemaining()) dst. put(src. get()); 除了它首先检查这个缓冲区中是否有足够的空间，并且可能效率要高得多。\npublic ByteBuffer put(ByteBuffer src) { if (src == this) throw new IllegalArgumentException(); if (isReadOnly()) throw new ReadOnlyBufferException(); int n = src.remaining(); if (n \u0026gt; remaining()) throw new BufferOverflowException(); for (int i = 0; i \u0026lt; n; i++) put(src.get()); return this; } 20. public ByteBuffer put(byte[] src, int offset, int length) 相对的批量 put 方法（可选操作）。\n这个方法将字节从给定的源数组传输到这个缓冲区。如果从数组中要复制的字节多于这个缓冲区剩余的字节，也就是说，如果length \u0026gt; remaining()，那么将不会传输任何字节，并抛出BufferOverflowException异常。\n否则，这个方法从给定数组中复制数量为length的字节到这个缓冲区，从数组中的给定偏移量开始，以及从这个缓冲区的当前位置开始。然后这个缓冲区的位置增加了 length。\n换句话说，以dst.put(src, off, len)形式调用这个方法的效果与以下循环完全相同：\nfor (int i = off; i \u0026lt; off + len; i++) { dst.put(a[i]); } 除了它首先检查这个缓冲区中是否有足够的空间，并且可能效率要高得多。\npublic ByteBuffer put(byte[] src, int offset, int length) { checkBounds(offset, length, src.length); if (length \u0026gt; remaining()) throw new BufferOverflowException(); int end = offset + length; for (int i = offset; i \u0026lt; end; i++) this.put(src[i]); return this; } 21. public final ByteBuffer put(byte[] src) 相对的批量 put 方法（可选操作）。 这个方法将给定源字节数组的全部内容传输到这个缓冲区。以dst.put(a)形式调用这个方法的行为与调用如下方法完全相同：\ndst.put(a, 0, a.length) 源码：\npublic final ByteBuffer put(byte[] src) { return put(src, 0, src.length); } 22. public final boolean hasArray() 判断这个缓冲区是否由一个可访问的字节数组支持。 如果这个方法返回true，那么可以安全地调用array和arrayOffset方法。\npublic final boolean hasArray() { return (hb != null) \u0026amp;\u0026amp; !isReadOnly; } 23. public final byte[] array() 返回支持这个缓冲区的字节数组（可选操作）。\n对这个缓冲区内容的修改将导致返回数组的内容被修改，反之亦然。\n在调用这个方法之前，先调用hasArray方法，以确保这个缓冲区有一个可访问的支持数组。\npublic final byte[] array() { if (hb == null) throw new UnsupportedOperationException(); if (isReadOnly) throw new ReadOnlyBufferException(); return hb; } 24. public final int arrayOffset() 返回这个缓冲区支持数组中第一个元素的偏移量（可选操作）。\n如果这个缓冲区是由一个数组支持的，那么缓冲区位置 p 对应于数组索引 p + arrayOffset()。\n在调用这个方法之前，先调用hasArray方法，以确保这个缓冲区有一个可访问的支持数组。\npublic final int arrayOffset() { if (hb == null) throw new UnsupportedOperationException(); if (isReadOnly) throw new ReadOnlyBufferException(); return offset; } 25. public abstract ByteBuffer compact(); 压缩这个缓冲区（可选操作）。\n缓冲区当前位置和限制之间如果存在字节，这些字节被复制到缓冲区的开头。也就是说，在索引 p = position() 处的字节被复制到索引0处，索引 p + 1 处的字节被复制到索引1处，以此类推，直到索引 limit() - 1 处的字节被复制到索引 n = limit() - 1 - p。然后，缓冲区的位置被设置为 n + 1，其限制被设置为其容量。如果已定义了标记，标记将被丢弃。\n缓冲区的位置被设置为已复制的字节数，而不是零，这样，这个方法的调用可以立即跟随另一个相对 put 方法的调用。\n在从缓冲区写入数据后调用此方法，以防写入不完整。例如，以下循环通过缓冲区buf将字节从一个通道复制到另一个通道：\nbuf. clear(); // 准备缓冲区以备使用 while (in. read(buf) \u0026gt;= 0 || buf. position != 0) { buf.flip(); out.write(buf); buf.compact(); // 如果是部分写入 } 26. public abstract boolean isDirect(); 返回这个字节缓冲区是否是直接的。\n27. public String toString() 返回一个字符串，总结此缓冲区的状态。\npublic String toString() { StringBuffer sb = new StringBuffer(); sb.append(getClass().getName()); sb.append(\u0026#34;[pos=\u0026#34;); sb.append(position()); sb.append(\u0026#34; lim=\u0026#34;); sb.append(limit()); sb.append(\u0026#34; cap=\u0026#34;); sb.append(capacity()); sb.append(\u0026#34;]\u0026#34;); return sb.toString(); } 28. public int hashCode() 返回这个缓冲区的当前哈希码。\n一个字节缓冲区的哈希码仅取决于其剩余元素；也就是说，取决于从 position() 到包括 limit() - 1 位置的元素。\n因为缓冲区的哈希码是内容依赖的，所以不建议在哈希映射或类似数据结构中使用缓冲区作为键，除非知道它们的内容不会改变。\npublic int hashCode() { int h = 1; int p = position(); for (int i = limit() - 1; i \u0026gt;= p; i--) h = 31 * h + (int)get(i); return h; } 29. public boolean equals(Object ob) 判断这个缓冲区是否等于另一个对象。\n当且仅当满足以下条件时，两个字节缓冲区相等：\n它们具有相同的元素类型， 它们具有相同数量的剩余元素 两个剩余元素序列（考虑他们的起始位置），是逐点相等的。 字节缓冲区不等于任何其他类型的对象。\npublic boolean equals(Object ob) { if (this == ob) return true; if (!(ob instanceof ByteBuffer)) return false; ByteBuffer that = (ByteBuffer)ob; int thisPos = this.position(); int thisLim = this.limit(); int thatPos = that.position(); int thatLim = that.limit(); int thisRem = thisLim - thisPos; int thatRem = thatLim - thatPos; if (thisRem \u0026lt; 0 || thisRem != thatRem) return false; for (int i = thisLim - 1, j = thatLim - 1; i \u0026gt;= thisPos; i--, j--) if (!equals(this.get(i), that.get(j))) return false; return true; } 30. private static boolean equals(byte x, byte y) 判断两个字节是否相等。\nprivate static boolean equals(byte x, byte y) { return x == y; } 31. public int compareTo(ByteBuffer that) 将这个缓冲区与另一个缓冲区进行比较。\n两个字节缓冲区通过比较它们的剩余元素序列来进行字典顺序比较，而不考虑每个序列在相应缓冲区内的起始位置。两个字节元素被比较，是通过调用Byte.compare(byte, byte)来进行的。\n一个字节缓冲区与任何其他类型的对象都不具有可比性。\npublic int compareTo(ByteBuffer that) { int thisPos = this.position(); int thisRem = this.limit() - thisPos; int thatPos = that.position(); int thatRem = that.limit() - thatPos; int length = Math.min(thisRem, thatRem); if (length \u0026lt; 0) return -1; int n = thisPos + Math.min(thisRem, thatRem); for (int i = thisPos, j = thatPos; i \u0026lt; n; i++, j++) { int cmp = compare(this.get(i), that.get(j)); if (cmp != 0) return cmp; } return thisRem - thatRem; } 32. private static int compare(byte x, byte y) 比较两个字节。\nprivate static int compare(byte x, byte y) { return Byte.compare(x, y); } 33. boolean bigEndian = true; 标识是否是大端序。\n34. boolean nativeByteOrder = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN); 标识本机的字节序是否是大端序。\n35. public final ByteOrder order() 获取当前缓冲区的字节序。\n字节序用在读取或写入多字节值时，以及在创建这个字节缓冲区视图的缓冲区时。新创建的字节缓冲区的顺序总是BIG_ENDIAN（大端序）。\npublic final ByteOrder order() { return bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN; } 36. public final ByteBuffer order(ByteOrder bo) 修改此缓冲区的字顺序。\npublic final ByteBuffer order(ByteOrder bo) { bigEndian = (bo == ByteOrder.BIG_ENDIAN); nativeByteOrder = (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN)); return this; } 37. abstract byte _get(int i); 供ByteBufferAs-X-Buffer类使用的get方法。\n38. abstract void _put(int i, byte b); 供ByteBufferAs-X-Buffer类使用的put方法。\n39. public abstract char getChar(); 相对 get 方法，用于读取char类型的值。\n读取这个缓冲区当前位置的下两个字节，根据当前字节序将它们组合成一个char类型的值，然后将位置增加 2。\n40. public abstract ByteBuffer putChar(char value); 相对 put 方法，用于写入char类型的值（可选操作）。 将给定的char值转换为两个字节，并按照当前字节序写入到这个缓冲区的当前位置，然后将位置增加 2。\n41. public abstract char getChar(int index); 绝对 get 方法，用于读取char类型的值。 在给定的索引处读取两个字节，根据当前字节序将它们组合成一个char类型的值。\n42. public abstract ByteBuffer putChar(int index, char value); 绝对 put 方法，用于写入char类型的值（可选操作）。 将给定的char值按照当前字节序转换为两个字节，并写入到这个缓冲区的给定索引位置。\n43. public abstract CharBuffer asCharBuffer(); 创建这个字节缓冲区作为char缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以二的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n44. public abstract short getShort(); 相对 get 方法，用于读取short类型的值。\n读取这个缓冲区当前位置的下两个字节，根据当前字节序将它们组合成一个short类型的值，然后将位置增加 2。\n45. public abstract ByteBuffer putShort(short value); 相对 put 方法，用于写入short类型的值（可选操作）。 将给定的short值按照当前字节序转换为两个字节，并写入到这个缓冲区的当前位置，然后将位置增加 2。\n46. public abstract short getShort(int index); 绝对 get 方法，用于读取short类型的值。 在给定的索引处读取两个字节，根据当前字节序将它们组合成一个short类型的值。\n47. public abstract ByteBuffer putShort(int index, short value); 绝对 put 方法，用于写入short类型的值（可选操作）。 将给定的short值按照当前字节序转换为两个字节，并写入到这个缓冲区的给定索引位置。\n48. public abstract ShortBuffer asShortBuffer(); 创建这个字节缓冲区作为short缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以二的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n\u0026ndash;\n49. public abstract int getInt(); 相对 get 方法，用于读取int类型的值。 读取这个缓冲区当前位置的下一个四个字节，根据当前字节序将它们组合成一个int类型的值，然后将位置增加 4。\n50. public abstract ByteBuffer putInt(int value); 相对 put 方法，用于写入int类型的值（可选操作）。 将给定的int值按照当前字节序转换为四个字节，并写入到这个缓冲区的当前位置，然后将位置增加 4。\n51. public abstract int getInt(int index); 绝对 get 方法，用于读取int类型的值。 在给定的索引处读取四个字节，根据当前字节序将它们组合成一个int类型的值。\n52. public abstract ByteBuffer putInt(int index, int value); 绝对 put 方法，用于写入int类型的值（可选操作）。 将给定的int值按照当前字节序转换为四个字节，并写入到这个缓冲区的给定索引位置。\n53. public abstract IntBuffer asIntBuffer(); 创建这个字节缓冲区作为int缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以四的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n54. public abstract long getLong(); 相对 get 方法，用于读取long类型的值。\n读取这个缓冲区当前位置的下八个字节，根据当前字节序将它们组合成一个long类型的值，然后将位置增加 8。\n55. public abstract ByteBuffer putLong(long value); 相对 put 方法，用于写入long类型的值（可选操作）。\n将给定的long值按照当前字节序转换为八个字节，并写入到这个缓冲区的当前位置，然后将位置增加 8。\n56. public abstract long getLong(int index); 绝对 get 方法，用于读取long类型的值。\n在给定的索引处读取八个字节，根据当前字节序将它们组合成一个long类型的值。\n57. public abstract ByteBuffer putLong(int index, long value); 绝对 put 方法，用于写入long类型的值（可选操作）。\n将给定的long值按照当前字节序转换为八个字节，并写入到这个缓冲区的给定索引位置。\n58. public abstract LongBuffer asLongBuffer(); 创建这个字节缓冲区作为long缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以八的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n59. public abstract float getFloat(); 相对 get 方法，用于读取float类型的值。\n读取这个缓冲区当前位置的下四个字节，根据当前字节序将它们组合成一个float类型的值，然后将位置增加 4。\n60. public abstract ByteBuffer putFloat(float value); 相对 put 方法，用于写入float类型的值（可选操作）。\n将给定的float值按照当前字节序转换为四个字节，并写入到这个缓冲区的当前位置，然后将位置增加 4。\n61. public abstract float getFloat(int index); 绝对 get 方法，用于读取float类型的值。\n在给定的索引处读取四个字节，根据当前字节序将它们组合成一个float类型的值。\n62. public abstract ByteBuffer putFloat(int index, float value); 绝对 put 方法，用于写入float类型的值（可选操作）。\n将给定的float值按照当前字节序转换为四个字节，并写入到这个缓冲区的给定索引位置。\n63. public abstract FloatBuffer asFloatBuffer(); 创建这个字节缓冲区作为float缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以四的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n64. public abstract double getDouble(); 相对 get 方法，用于读取double类型的值。\n读取这个缓冲区当前位置的下八个字节，根据当前字节序将它们组合成一个double类型的值，然后将位置增加 8。\n65. public abstract ByteBuffer putDouble(double value); 相对 put 方法，用于写入double类型的值（可选操作）。\n将给定的double值按照当前字节序转换为八个字节，并写入到这个缓冲区的当前位置，然后将位置增加 8。\n66. public abstract double getDouble(int index); 绝对 get 方法，用于读取double类型的值。 在给定的索引处读取八个字节，根据当前字节序将它们组合成一个double类型的值。\n67. public abstract ByteBuffer putDouble(int index, double value); 绝对 put 方法，用于写入double类型的值（可选操作）。\n将给定的double值按照当前字节序转换为八个字节，并写入到这个缓冲区的给定索引位置。\n68. public abstract DoubleBuffer asDoubleBuffer(); 创建这个字节缓冲区作为double缓冲区的视图。\n新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见，反之亦然；两个缓冲区的位置、限制和标记值将是独立的。\n新缓冲区的位置将为零，其容量和限制将是这个缓冲区剩余字节数除以八的结果，其标记将未定义。如果这个缓冲区是直接的，新缓冲区也将是直接的，如果这个缓冲区是只读的，新缓冲区也将是只读的。\n","description":"1. final byte[] hb; 2. final int offset; 3. boolean isReadOnly; 4. ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) 5. ByteBuffer(int mark, int pos, int lim, int cap) 6. public static ByteBuffer allocateDirect(int capacity) 7. public static ByteBuffer allocate(int capacity) 8. public static ByteBuffer wrap(byte[] array, int offset, int length) 9. public static ByteBuffer wrap(byte[] array) 10. public abstract ByteBuffer slice(); 11. public abstract ByteBuffer duplicate(); 12."},{"id":7,"href":"/jdk8-src-note/java/nio/Buffer/","title":"Buffer","parent":"nio","content":" 1. static final int SPLITERATOR_CHARACTERISTICS 2. private int mark = -1 3. private int position = 0 4. private int limit 5. private int capacity 6. long address 7. Buffer(int mark, int pos, int lim, int cap) 8. public final int capacity() 9. public final int position() 10. public final Buffer position(int newPosition) 11. public final int limit() 12. public final Buffer limit(int newLimit) 13. public final Buffer mark() 14. public final Buffer reset() 15. public final Buffer clear() 16. public final Buffer flip() 17. public final Buffer rewind() 18. public final int remaining() 19. public final boolean hasRemaining() 20. public abstract boolean isReadOnly() 21. public abstract boolean hasArray() 22. public abstract Object array() 23. public abstract int arrayOffset() 24. public abstract boolean isDirect() 25. final int nextGetIndex() 26. final int nextGetIndex(int nb) 27. final int nextPutIndex() 28. final int nextPutIndex(int nb) 29. final int checkIndex(int i) 30. final int checkIndex(int i, int nb) 31. final int markValue() 32. final void truncate() 33. final void discardMark() 34. static void checkBounds(int off, int len, int size) 一种用于存储特定原始类型数据的容器。\n缓冲区是具有特定原始类型元素的线性、有限序列。除了其内容外，缓冲区的基本属性包括其容量（capacity）、限制（limit）和位置（position）：\n缓冲区的容量是指它所能包含的元素数量。缓冲区的容量永远不会是负数，并且在设置之后永远不会改变。 缓冲区的限制是指第一个不应该被读取或写的元素的索引。缓冲区的限制不会是负数，并且永远不会大于它的容量（capacity）。 缓冲区的位置是指下一个要被读取或写的元素的索引。缓冲区的位置不会是负数，并且永远不会大于它的限制（limit）。 对于每种非布尔的原始类型此类都有一个对应的子类。\n传输数据\n这个类的每个子类定义了两类 get 和 put 操作：\n相对操作从当前位置开始读取或写入一个或多个元素，然后按传输的元素数量增加位置。如果请求超出了限制，那么相对 get 操作会抛出 BufferUnderflowException 异常，相对 put 操作会抛出 BufferOverflowException 异常；在任一情况下，都不会传输数据。 绝对操作需要一个明确的元素索引，并且不影响位置。如果索引参数超出限制，绝对 get 和 put 操作会抛出IndexOutOfBoundsException异常。 数据当然也可以通过对应通道的输入/输出操作转移到缓冲区中或从缓冲区中转出，这些操作始终是相对于当前位置的。\n标记和重置\n缓冲区的标记（mark）是当调用reset方法时其位置将被重置到的索引。标记（mark）并不会总是被定义，但当它被定义时，它永远不会是负数，并且永远不会大于位置（position）。如果已定义标记，那么当位置（position）或限制（limit）被调整到一个比标记小的值时，标记将被丢弃。如果标记未定义，那么调用reset方法将导致抛出InvalidMarkException异常。\n不变式\n以下不变量适用于标记、位置、限制和容量值：\n0 \u0026lt;= mark \u0026lt;= position \u0026lt;= limit \u0026lt;= capacity\n新创建的缓冲区总是位置（position）为零，并且标记（mark）是未定义的。初始的限制（limit）可能是零，或者它可能是取决于缓冲区的类型以及构建方式的其他值。新分配的缓冲区的每个元素都被初始化为零。\n清除、翻转、倒带\n除了访问位置、限制和容量值以及标记和重置的方法外，此类还定义了对缓冲器的以下操作：\nclear使缓冲区准备好进行新的一系列通道读取或相对 put 操作序列：它将限制（limit）设置为容量（capacity），将位置（position）设置为零。 flip使缓冲区准备好进行新的一系列通道写入或相对 get 操作序列：它将限制（limit）设置为当前位置（position），然后将位置（position）设置为零。 rewind使缓冲区准备好重新读取它已经包含的数据：它保持限制不变，并将位置设置为零。 只读缓冲区\n每个缓冲区都是可读的，但不是每个缓冲区都是可写的。每个缓冲区类的变异方法被指定为可选操作，当在只读缓冲区上调用这些方法时，会抛出ReadOnlyBufferException异常。只读缓冲区不允许更改其内容，但其标记、位置和限制值是可变的。可以通过调用其isReadOnly方法来确定缓冲区是否为只读。\n线程安全性\n多个并发线程使用同一个缓冲区是不安全的。如果一个缓冲区要由多个线程使用，那么应该通过适当的同步来控制对该缓冲区的访问。\n调用链\n这个类中没有其他返回值要返回的方法被指定为返回它们被调用的缓冲区。这样可以将方法调用链接在一起；例如，语句：\nb.flip(); b.position(23); b.limit(42); 可以用一个更紧凑的语句代替：\nb. flip().position(23).limit(42); 1. static final int SPLITERATOR_CHARACTERISTICS 在缓冲区中维护的元素进行遍历和分割的拆分器的特性。\nstatic final int SPLITERATOR_CHARACTERISTICS = Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED; 2. private int mark = -1 标记，不变式：mark \u0026lt;= position \u0026lt;= limit \u0026lt;= capacity\n3. private int position = 0 位置。\n4. private int limit 限制。\n5. private int capacity 容量。\n6. long address 仅由直接缓冲区使用。 注意：为了提高 JNI 中 GetDirectBufferAddress 的速度，这里提升了它。\n7. Buffer(int mark, int pos, int lim, int cap) 在检查不变式之后，创建一个具有给定标记、位置、限制和容量的新缓冲区。\nBuffer(int mark, int pos, int lim, int cap) { // package-private if (cap \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Negative capacity: \u0026#34; + cap); this.capacity = cap; limit(lim); position(pos); if (mark \u0026gt;= 0) { if (mark \u0026gt; pos) throw new IllegalArgumentException(\u0026#34;mark \u0026gt; position: (\u0026#34; + mark + \u0026#34; \u0026gt; \u0026#34; + pos + \u0026#34;)\u0026#34;); this.mark = mark; } } 8. public final int capacity() 返回此缓冲区的容量。\npublic final int capacity() { return capacity; } 9. public final int position() 返回此缓冲区的位置。\npublic final int position() { return position; } 10. public final Buffer position(int newPosition) 设置此缓冲区的位置。如果标记已定义且大于新位置，则会将其丢弃。\npublic final Buffer position(int newPosition) { if ((newPosition \u0026gt; limit) || (newPosition \u0026lt; 0)) throw new IllegalArgumentException(); position = newPosition; if (mark \u0026gt; position) mark = -1; return this; } 11. public final int limit() 返回此缓冲区的限制。\npublic final int limit() { return limit; } 12. public final Buffer limit(int newLimit) 设置此缓冲区的限制。如果位置大于新限制，则将其设置为新限制。如果标记被定义并且大于新的限制，那么它将被丢弃。\npublic final Buffer limit(int newLimit) { if ((newLimit \u0026gt; capacity) || (newLimit \u0026lt; 0)) throw new IllegalArgumentException(); limit = newLimit; if (position \u0026gt; newLimit) position = newLimit; if (mark \u0026gt; newLimit) mark = -1; return this; } 13. public final Buffer mark() 将此缓冲区的标记设置在其位置。\npublic final Buffer mark() { mark = position; return this; } 14. public final Buffer reset() 将此缓冲区的位置重置为先前标记的位置。\n调用此方法既不会更改也不会丢弃标记的值。\npublic final Buffer reset() { int m = mark; if (m \u0026lt; 0) throw new InvalidMarkException(); position = m; return this; } 15. public final Buffer clear() 清除此缓冲区。位置设置为零，限制设置为容量，标记被丢弃。\n在使用一系列通道读取或放置操作来填充此缓冲区之前，请调用此方法。例如：\nbuf.clear(); // 准备用于读取的缓冲区 in.read(buf); // 读取数据 这种方法实际上并不会擦除缓冲区中的数据，但它被命名为擦除，因为它最常用于这种情况。\npublic final Buffer clear() { position = 0; limit = capacity; mark = -1; return this; } 16. public final Buffer flip() 翻转此缓冲区。将限制设置为当前位置，然后将位置设置为零。如果定义了标记，则会将其丢弃。\n在一系列通道读取或放置操作之后，调用此方法为一系列通道写入或相对获取操作做准备。例如：\nbuf.put(magic); // 准备标头 in.read(buf); // 将数据读取到缓冲区的其余部分 buf.flip(); // 翻转缓冲区 out.write(buf); // 将标头+数据写入通道 当数据从一个地方传输到另一个地方时，此方法经常与compact方法结合使用。\npublic final Buffer flip() { limit = position; position = 0; mark = -1; return this; } 17. public final Buffer rewind() 回退此缓冲区。位置被设置为零，标记被丢弃。\n在一系列通道写入或获取操作之前调用此方法，假设已经适当设置了限制。例如：\nout.write(buf); // 写入剩余数据 buf.rewind(); // 回退缓冲区 buf.get(array); // 复制数据进数组 18. public final int remaining() 返回当前位置和限制之间的元素数。\npublic final int remaining() { return limit - position; } 19. public final boolean hasRemaining() 返回当前位置和限制之间是否有任何元素。\npublic final boolean hasRemaining() { return position \u0026lt; limit; } 20. public abstract boolean isReadOnly() 返回当前缓冲区是否是只读的。\n21. public abstract boolean hasArray() 判断这个缓冲区是否基于一个可访问的数组。\n如果此方法返回true，则可以安全地调用array和arrayOffset方法。\n22. public abstract Object array() 返回支持此缓冲区的数组（可选操作）。\n此方法旨在使基于数组的缓冲区能够更有效地传递给原生代码。具体的子类为这个方法提供了更强类型的返回值。\n对此缓冲区内容的修改将导致返回数组的内容被修改，反之亦然。\n在调用此方法之前先调用hasArray方法，以确保此缓冲区具有可访问的后备数组。\n23. public abstract int arrayOffset() 返回缓冲区第一个元素的缓冲区后备数组中的偏移量（可选操作）。\n如果此缓冲区是基于数组的，则缓冲区位置p对应于数组索引p + arrayOffset()。\n在调用此方法之前先调用hasArray方法，以确保此缓冲区具有可访问的后备数组。\n24. public abstract boolean isDirect() 返回这个缓冲区是否是直接缓冲区。\n当且仅返回true时此缓冲区是直接缓冲区。\n25. final int nextGetIndex() 根据限制检查当前位置，如果当前位置不小于限制，则抛出BufferUnderflowException，否则递增位置。\n返回其递增之前的当前位置值。\nfinal int nextGetIndex() { // package-private int p = position; if (p \u0026gt;= limit) throw new BufferUnderflowException(); position = p + 1; return p; } 26. final int nextGetIndex(int nb) 和上面的nextGetIndex方法类似，只不过上面的方法是尝试给位置+1，而此方法尝试给当前位置加指定的数量（参数nb）。\nfinal int nextGetIndex(int nb) { // package-private int p = position; if (limit - p \u0026lt; nb) throw new BufferUnderflowException(); position = p + nb; return p; } 27. final int nextPutIndex() 根据限制检查当前位置，如果不小于限制，则抛出BufferOverflowException，否则递增位置。\n返回其递增之前的当前位置值。\nfinal int nextPutIndex() { // package-private int p = position; if (p \u0026gt;= limit) throw new BufferOverflowException(); position = p + 1; return p; } 28. final int nextPutIndex(int nb) 和上面的nextPutIndex方法类似，只不过上面的方法是尝试给位置+1，而此方法尝试给当前位置加指定的数量（参数nb）。\nfinal int nextPutIndex(int nb) { // package-private int p = position; if (limit - p \u0026lt; nb) throw new BufferOverflowException(); position = p + nb; return p; } 29. final int checkIndex(int i) 根据限制检查给定的索引，如果该索引不小于限制或小于零，则抛出IndexOutOfBoundsException。\nfinal int checkIndex(int i) { // package-private if ((i \u0026lt; 0) || (i \u0026gt;= limit)) throw new IndexOutOfBoundsException(); return i; } 30. final int checkIndex(int i, int nb) 检查索引是否还能增加nb。\nfinal int checkIndex(int i, int nb) { // package-private if ((i \u0026lt; 0) || (nb \u0026gt; limit - i)) throw new IndexOutOfBoundsException(); return i; } 31. final int markValue() 返回标记。\nfinal int markValue() { // package-private return mark; } 32. final void truncate() 截断。\nfinal void truncate() { // package-private mark = -1; position = 0; limit = 0; capacity = 0; } 33. final void discardMark() 放弃标记。\nfinal void discardMark() { // package-private mark = -1; } 34. static void checkBounds(int off, int len, int size) 检查边界。\nstatic void checkBounds(int off, int len, int size) { // package-private if ((off | len | (off + len) | (size - (off + len))) \u0026lt; 0) throw new IndexOutOfBoundsException(); } ","description":"1. static final int SPLITERATOR_CHARACTERISTICS 2. private int mark = -1 3. private int position = 0 4. private int limit 5. private int capacity 6. long address 7. Buffer(int mark, int pos, int lim, int cap) 8. public final int capacity() 9. public final int position() 10. public final Buffer position(int newPosition) 11. public final int limit() 12. public final Buffer limit(int newLimit) 13. public final Buffer mark() 14."},{"id":8,"href":"/jdk8-src-note/java/nio/","title":"nio","parent":"java","content":" Buffer BufferOverflowException BufferUnderflowException ByteBuffer ByteOrder InvalidMarkException ReadOnlyBufferException ","description":" Buffer BufferOverflowException BufferUnderflowException ByteBuffer ByteOrder InvalidMarkException ReadOnlyBufferException "},{"id":9,"href":"/jdk8-src-note/java/io/Closeable/","title":"Closeable","parent":"io","content":" 1. public void close() throws IOException; Closeable是数据的源或目的地，它可以被关闭。调用close方法是为了释放对象持有的资源（如打开的文件）。\n1. public void close() throws IOException; 关闭此流，并释放与它关联的任何系统资源。如果流已经被关闭，那么调用这个方法将不会有任何影响。\n正如在AutoCloseable.close()中所指出的，关闭操作可能失败的情况需要特别注意。强烈建议在抛出IOException之前，先释放底层资源，并在内部将Closeable标记为已关闭。\n","description":"1. public void close() throws IOException; Closeable是数据的源或目的地，它可以被关闭。调用close方法是为了释放对象持有的资源（如打开的文件）。\n1. public void close() throws IOException; 关闭此流，并释放与它关联的任何系统资源。如果流已经被关闭，那么调用这个方法将不会有任何影响。\n正如在AutoCloseable.close()中所指出的，关闭操作可能失败的情况需要特别注意。强烈建议在抛出IOException之前，先释放底层资源，并在内部将Closeable标记为已关闭。"},{"id":10,"href":"/jdk8-src-note/java/lang/AutoCloseable/","title":"AutoCloseable","parent":"lang","content":" 1. void close() throws Exception; 一个可能包含资源（比如文件或套接字句柄）的对象，在被关闭之前会一直持有这些资源。实现了AutoCloseable接口的对象，且该对象已在资源声明头部被声明，则该对象会在退出一个try-with-resources语句块时自动调用其close()方法。这种结构确保了及时释放资源，避免了资源耗尽异常以及可能发生的其他错误。\n基类实现AutoCloseable接口是可以的，也是常见的情况，即使不是所有的子类或实例都会持有可释放的资源。对于那些需要完全泛化操作的代码，或者当知道AutoCloseable实例需要释放资源时，推荐使用try-with-resources语句。然而，在使用像java.util.stream.Stream这类同时支持基于I/O和非I/O形式的功能时，在采用非I/O形式时，通常不需要使用try-with-resources语句块。\n1. void close() throws Exception; 关闭此资源，释放其持有的任何底层资源。这个方法会在由try-with-resources语句所管理的对象上自动调用。\n尽管此接口方法声明可能会抛出异常，但强烈建议实现者声明具体的close方法以抛出更具体的异常，或者如果关闭操作不会失败，则根本不抛出异常。\n关闭操作可能会失败的情况需要实现者特别注意。强烈建议在抛出异常之前先释放底层资源，并在内部将资源标记为已关闭。close方法不太可能会多次被调用，这样确保了资源能够及时释放。此外，这也减少了当资源包装其他资源或被其他资源包装时可能出现的问题。\n强烈建议实现此接口的开发者也被不要让close方法抛出InterruptedException。\n这个异常与线程的中断状态有关，如果InterruptedException被忽略，很可能会出现运行时的错误行为。\n更一般地说，如果一个异常被忽略会引起问题，AutoCloseable的close方法就不应该抛出该异常。\n请注意，与java.io.Closeable的close方法不同，这个close方法不要求是幂等的。换句话说，多次调用这个close方法可能会有一些可见的副作用，而Closeable的close如果多次调用则要求没有影响。\n即便如此，仍强烈建议实现此接口的开发者使他们的close方法成为幂等的。\n","description":"1. void close() throws Exception; 一个可能包含资源（比如文件或套接字句柄）的对象，在被关闭之前会一直持有这些资源。实现了AutoCloseable接口的对象，且该对象已在资源声明头部被声明，则该对象会在退出一个try-with-resources语句块时自动调用其close()方法。这种结构确保了及时释放资源，避免了资源耗尽异常以及可能发生的其他错误。\n基类实现AutoCloseable接口是可以的，也是常见的情况，即使不是所有的子类或实例都会持有可释放的资源。对于那些需要完全泛化操作的代码，或者当知道AutoCloseable实例需要释放资源时，推荐使用try-with-resources语句。然而，在使用像java.util.stream.Stream这类同时支持基于I/O和非I/O形式的功能时，在采用非I/O形式时，通常不需要使用try-with-resources语句块。\n1. void close() throws Exception; 关闭此资源，释放其持有的任何底层资源。这个方法会在由try-with-resources语句所管理的对象上自动调用。\n尽管此接口方法声明可能会抛出异常，但强烈建议实现者声明具体的close方法以抛出更具体的异常，或者如果关闭操作不会失败，则根本不抛出异常。\n关闭操作可能会失败的情况需要实现者特别注意。强烈建议在抛出异常之前先释放底层资源，并在内部将资源标记为已关闭。close方法不太可能会多次被调用，这样确保了资源能够及时释放。此外，这也减少了当资源包装其他资源或被其他资源包装时可能出现的问题。\n强烈建议实现此接口的开发者也被不要让close方法抛出InterruptedException。\n这个异常与线程的中断状态有关，如果InterruptedException被忽略，很可能会出现运行时的错误行为。\n更一般地说，如果一个异常被忽略会引起问题，AutoCloseable的close方法就不应该抛出该异常。\n请注意，与java.io.Closeable的close方法不同，这个close方法不要求是幂等的。换句话说，多次调用这个close方法可能会有一些可见的副作用，而Closeable的close如果多次调用则要求没有影响。\n即便如此，仍强烈建议实现此接口的开发者使他们的close方法成为幂等的。"},{"id":11,"href":"/jdk8-src-note/java/lang/reflect/Member/","title":"Member","parent":"reflect","content":" 1. public static final int PUBLIC = 0; 2. public static final int DECLARED = 1; 3. public Class getDeclaringClass(); 4. public String getName(); 5. public int getModifiers(); 6. public boolean isSynthetic(); Member是一个接口，在反射时标识单个成员（字段或方法）或构造函数的信息。\n1. public static final int PUBLIC = 0; 标识类或接口的所有公共成员的集合，包括继承的成员。\n2. public static final int DECLARED = 1; 标识类或接口的声明成员集合。继承的成员不包括在内。\n3. public Class getDeclaringClass(); 返回一个Class对象，该对象表示由当前Member实例所代表的成员或构造函数的类或接口。\n4. public String getName(); 返回此成员表示的基础成员或构造函数的简单名称。\n5. public int getModifiers(); 以整数形式返回此成员表示的成员或构造函数的Java语言修饰符。Modifier类应用于解码整数的修饰符。\n6. public boolean isSynthetic(); 如果此成员是由编译器引入的，则返回true，否则返回false。\n","description":"1. public static final int PUBLIC = 0; 2. public static final int DECLARED = 1; 3. public Class getDeclaringClass(); 4. public String getName(); 5. public int getModifiers(); 6. public boolean isSynthetic(); Member是一个接口，在反射时标识单个成员（字段或方法）或构造函数的信息。\n1. public static final int PUBLIC = 0; 标识类或接口的所有公共成员的集合，包括继承的成员。\n2. public static final int DECLARED = 1; 标识类或接口的声明成员集合。继承的成员不包括在内。\n3. public Class getDeclaringClass(); 返回一个Class对象，该对象表示由当前Member实例所代表的成员或构造函数的类或接口。\n4. public String getName(); 返回此成员表示的基础成员或构造函数的简单名称。\n5. public int getModifiers(); 以整数形式返回此成员表示的成员或构造函数的Java语言修饰符。Modifier类应用于解码整数的修饰符。\n6. public boolean isSynthetic(); 如果此成员是由编译器引入的，则返回true，否则返回false。"},{"id":12,"href":"/jdk8-src-note/java/lang/reflect/","title":"reflect","parent":"lang","content":" Member ","description":" Member "},{"id":13,"href":"/jdk8-src-note/javax/annotation/Resources/","title":"Resources","parent":"annotation","content":" 1. Resource[] value(); 此类用于允许多个资源声明。\n@Documented @Retention(RUNTIME) @Target(TYPE) public @interface Resources { } 1. Resource[] value(); 用于多个资源声明的数组。\n","description":"1. Resource[] value(); 此类用于允许多个资源声明。\n@Documented @Retention(RUNTIME) @Target(TYPE) public @interface Resources { } 1. Resource[] value(); 用于多个资源声明的数组。"},{"id":14,"href":"/jdk8-src-note/javax/annotation/Resource/","title":"Resource","parent":"annotation","content":" 1. String name() default \u0026ldquo;\u0026rdquo;; 2. String lookup() default \u0026ldquo;\u0026rdquo;; 3. Class type() default java.lang.Object.class; 4. enum AuthenticationType 5. AuthenticationType authenticationType() default AuthenticationType.CONTAINER; 6. boolean shareable() default true; 7. String mappedName() default \u0026ldquo;\u0026rdquo;; 8. String description() default \u0026ldquo;\u0026rdquo;; Resource注解用于标记一个资源是应用所需要的。该注解可能应用于某个应用组件类，或者组件类的属性或方法。当该注解用于某应用组件的属性或者方法时，容器会在初始化该组件时注入一个请求资源的实例到该组件。如果该注解应用于一个组件类，\t该注解会定义一个资源，然后应用可能在运行时查找它。\n尽管该注解没有被标记为Inherited，开发工具仍需检查所有组件类的超类，以发现超类中所有使用该注解的地方。这些注解表明应用组件需要这些资源。注意，这些组件可能出现在超类的私有属性或方法上，容器在这些场景下也需要执行注入。\n@Target({TYPE, FIELD, METHOD}) @Retention(RUNTIME) public @interface Resource { } 1. String name() default \u0026ldquo;\u0026rdquo;; 资源的JNDI名称。该注解标注到到字段上时，默认值为字段名。标注到方法上时，默认值是与该方法对应的JavaBeans属性名。标注到类上时，没有默认值，该属性必须指定。\n2. String lookup() default \u0026ldquo;\u0026rdquo;; 引用指向的资源的名称。它可以使用全局JNDI名称链接到任何兼容的资源。\n3. Class type() default java.lang.Object.class; 资源的Java类型。该注解标注到字段上时，默认值是字段的类型。标注到方法上时，默认值是JavaBeans属性的类型。标注到类上时，没有默认值，该属性必须指定。\n4. enum AuthenticationType 资源的两种可能的身份验证类型。\nenum AuthenticationType { CONTAINER, APPLICATION } 5. AuthenticationType authenticationType() default AuthenticationType.CONTAINER; 用于此资源的身份验证类型。可以为代表任何支持类型的连接工厂的资源指定，而不能为其他类型的资源指定。\n6. boolean shareable() default true; 标识此资源是否可以在此组件和其他组件之间共享。可以为代表任何支持类型的连接工厂的资源指定，而不能为其他类型的资源指定。\n7. String mappedName() default \u0026ldquo;\u0026rdquo;; 此资源应映射到的产品特定名称。此资源的名称由name元素定义或采用的默认值，它是在使用该资源的应用程序组件中的本地名称。（它是JNDI命名空间java:comp/env中的一个名称。）许多应用服务器都提供了一种将这些本地名称映射到应用服务器已知资源名称的方法。此映射名称通常是全局JNDI名称，但也可以是任何形式的名称。\n应用程序服务器不需要支持任何特定形式或类型的映射名称，也不需要具备使用映射名称的能力。映射名称取决于产品，通常取决于安装。映射名称的使用不可移植。\n8. String description() default \u0026ldquo;\u0026rdquo;; 此资源的描述。描述应使用部署应用程序的系统的默认语言。该描述可以提供给开发者，以帮助选择正确的资源。\n","description":"1. String name() default \u0026ldquo;\u0026rdquo;; 2. String lookup() default \u0026ldquo;\u0026rdquo;; 3. Class type() default java.lang.Object.class; 4. enum AuthenticationType 5. AuthenticationType authenticationType() default AuthenticationType.CONTAINER; 6. boolean shareable() default true; 7. String mappedName() default \u0026ldquo;\u0026rdquo;; 8. String description() default \u0026ldquo;\u0026rdquo;; Resource注解用于标记一个资源是应用所需要的。该注解可能应用于某个应用组件类，或者组件类的属性或方法。当该注解用于某应用组件的属性或者方法时，容器会在初始化该组件时注入一个请求资源的实例到该组件。如果该注解应用于一个组件类，\t该注解会定义一个资源，然后应用可能在运行时查找它。\n尽管该注解没有被标记为Inherited，开发工具仍需检查所有组件类的超类，以发现超类中所有使用该注解的地方。这些注解表明应用组件需要这些资源。注意，这些组件可能出现在超类的私有属性或方法上，容器在这些场景下也需要执行注入。\n@Target({TYPE, FIELD, METHOD}) @Retention(RUNTIME) public @interface Resource { } 1. String name() default \u0026ldquo;\u0026rdquo;; 资源的JNDI名称。该注解标注到到字段上时，默认值为字段名。标注到方法上时，默认值是与该方法对应的JavaBeans属性名。标注到类上时，没有默认值，该属性必须指定。\n2. String lookup() default \u0026ldquo;\u0026rdquo;; 引用指向的资源的名称。它可以使用全局JNDI名称链接到任何兼容的资源。\n3. Class type() default java.lang.Object.class; 资源的Java类型。该注解标注到字段上时，默认值是字段的类型。标注到方法上时，默认值是JavaBeans属性的类型。标注到类上时，没有默认值，该属性必须指定。\n4. enum AuthenticationType 资源的两种可能的身份验证类型。"},{"id":15,"href":"/jdk8-src-note/javax/annotation/","title":"annotation","parent":"javax","content":" Resource Resources ","description":" Resource Resources "},{"id":16,"href":"/jdk8-src-note/javax/","title":"javax","parent":"JDK8源码阅读笔记","content":" annotation Resource Resources ","description":" annotation Resource Resources "},{"id":17,"href":"/jdk8-src-note/java/util/AbstractMap/","title":"AbstractMap","parent":"util","content":" 1. protected AbstractMap() 2. public int size() 3. public boolean isEmpty() 4. public boolean containsValue(Object value) 5. public boolean containsKey(Object key) 6. public V get(Object key) 7. public V put(K key, V value) 8. public V remove(Object key) 9. public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 10. public void clear() 11. transient Set\u0026lt;K\u0026gt; keySet; 12. transient Collection\u0026lt;V\u0026gt; values; 13. public Set\u0026lt;K\u0026gt; keySet() 14. public Collection\u0026lt;V\u0026gt; values() 15. public abstract Set\u0026lt;Entry\u0026lt;K,V\u0026raquo; entrySet(); 16. public boolean equals(Object o) 17. public int hashCode() 18. public String toString() 19. protected Object clone() throws CloneNotSupportedException 20. private static boolean eq(Object o1, Object o2) 21. public static class SimpleEntry\u0026lt;K,V\u0026gt; implements Entry\u0026lt;K,V\u0026gt;, java.io.Serializable 21.1 private final K key; 21.2 private V value; 21.3 public SimpleEntry(K key, V value) 21.4 public SimpleEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) 21.5 public K getKey() 21.6 public V getValue() 21.7 public V setValue(V value) 21.8 public boolean equals(Object o) 21.9 public int hashCode() 21.10 public String toString() 22. public static class SimpleImmutableEntry\u0026lt;K,V\u0026gt; implements Entry\u0026lt;K,V\u0026gt;, java.io.Serializable 22.1 private final K key; 22.2 private final V value; 22.3 public SimpleImmutableEntry(K key, V value) 22.4 public SimpleImmutableEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) 22.5 public K getKey() 22.6 public V getValue() 22.7 public V setValue(V value) 22.8 public boolean equals(Object o) 22.9 public int hashCode() 22.10 public String toString() 此类提供了Map接口的框架实现，以最大程度减少实现此接口所需的工作量。\n要实现一个不可修改的map，编程者只需扩展这个类，并为entrySet方法提供一个实现，该方法返回map映射的set视图。通常，返回的set将基于AbstractSet实现。此set不应支持add或remove方法，其迭代器不应支持remove方法。\n要实现一个可修改的map，编程者必须额外重写这个类的put方法（否则会抛出一个UnsupportedOperationException），并且由entrySet().iterator()返回的迭代器必须额外实现它的remove方法。\n根据Map接口规范中的建议，编程者通常应提供一个void（无参数）构造函数和一个参数为map的构造函数。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的map允许更有效的实现，则这些方法中的每一个都可能被重写。\n本类是Java集合框架的成员。\n1. protected AbstractMap() 唯一的构造器。（子类构造函数调用，通常是隐式的。）\nprotected AbstractMap() { } 2. public int size() 返回当前map的元素个数，本实现是返回的entrySet().size()。\npublic int size() { return entrySet().size(); } 3. public boolean isEmpty() 判断当前map是否为空。\npublic boolean isEmpty() { return size() == 0; } 4. public boolean containsValue(Object value) 本实现遍历entrySet()以找到一个值为参数所指定的value的条目。如果找到了这样的条目，则返回true，如果遍历完也没有找到这样的条目，则返回false。请注意，此实现需要map大小的线性时间。\npublic boolean containsValue(Object value) { // 先调用entrySet()获取条目的Set，然后再获取该Set的迭代器 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); // 在遍历集合的外面先判断出value是否为空，避免每迭代到一个条目都进行一次判断 if (value==null) { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (e.getValue()==null) return true; } } else { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (value.equals(e.getValue())) return true; } } return false; } 5. public boolean containsKey(Object key) 本实现遍历entrySet()以找到一个键为参数所指定的key的条目。如果找到了这样的条目，则返回true，如果遍历完也没有找到这样的条目，则返回false。请注意，此实现需要map大小的线性时间，许多实现将重写此方法。\n源码如下：\npublic boolean containsKey(Object key) { // 获取条目的集合的迭代器 Iterator\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); // 区分指定的key是否为空，然后遍历集合找出指定键的条目 if (key==null) { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (e.getKey()==null) return true; } } else { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (key.equals(e.getKey())) return true; } } return false; } 6. public V get(Object key) 本实现遍历entrySet()以找到一个键为参数所指定的key的条目。如果找到了这样的条目，则返回该条目的值，如果遍历完也没有找到这样的条目，则返回null。请注意，此实现需要map大小的线性时间，许多实现将重写此方法。\n源码如下：\npublic V get(Object key) { // 该方法与containsKey类似，区别在于找到对应条目后，containsKey是返回true，而get是返回条码的值 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); if (key==null) { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (e.getKey()==null) return e.getValue(); } } else { while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (key.equals(e.getKey())) return e.getValue(); } } return null; } 7. public V put(K key, V value) 向当前map中添加（或更新）键值对。此默认实现中是抛出UnsupportedOperationException，所以如果想实现可修改的Map需要重写该方法。\n源码如下：\npublic V put(K key, V value) { throw new UnsupportedOperationException(); } 8. public V remove(Object key) 此实现遍历ntrySet()以找到一个键为参数所指定的key的条目。如果找到这样一个条目，则使用其getValue操作获取其值，使用迭代器的remove操作从集合（和后备map）中删除该条目，并返回刚取出的值。如果遍历终止时没有找到这样的条目，则返回null。请注意，此实现需要map大小的线性时间，许多实现将覆盖此方法。\n注意，如果entrySet的迭代器不支持remove方法并且当前map包含指定键的映射，则本实现会抛出UnsupportedOperationException。\n源码如下：\npublic V remove(Object key) { // 获取到entrySet的迭代器 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); // 定义一个变量用于指向要寻找的条目（即键为参数中指定的key） Entry\u0026lt;K,V\u0026gt; correctEntry = null; // 根据指定键是否为空来确认是采用“==null”判断还是采用“equals”判断 if (key==null) { // 如果要寻找的条目为空则继续遍历集合 while (correctEntry==null \u0026amp;\u0026amp; i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); // 如果符合条件，则将当前迭代到的条目赋值给变量correctEntry if (e.getKey()==null) correctEntry = e; } } else { while (correctEntry==null \u0026amp;\u0026amp; i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); if (key.equals(e.getKey())) correctEntry = e; } } // 定义一个变量oldValue用于指向旧值 V oldValue = null; // 如果correctEntry不为空，说明找到了对应的条目 if (correctEntry !=null) { // 取出该条目的值赋值给oldValue oldValue = correctEntry.getValue(); // 然后使用迭代器的remove方法删除此条目 i.remove(); } // 返回旧值，当然如果当前map不包含指定键，则返回null return oldValue; } 9. public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 此实现遍历指定map的entrySet()集合，并为遍历到的每个条目调用一次本map的put操作。\n请注意，如果此映射不支持put操作且指定的map非空，则此实现将抛出一个UnsupportedOperationException。\n源码如下：\npublic void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { for (Map.Entry\u0026lt;? extends K, ? extends V\u0026gt; e : m.entrySet()) put(e.getKey(), e.getValue()); } 10. public void clear() 本实现调用entrySet().clear()以删除当前map内的所有映射。\n注意，如果entrySet不支持clear操作，则本实现将抛出UnsupportedOperationException。\npublic void clear() { entrySet().clear(); } 11. transient Set\u0026lt;K\u0026gt; keySet; 在第一次请求此视图时，这些字段中的每个字段都会初始化为包含相应视图的实例。视图是无状态的，因此没有理由创建多个视图。\n由于在访问这些字段时没有执行同步，因此使用这些字段的java.util.Map视图类应该没有非final的字段（或除此之外的任何字段）。遵守这一规则将使这些领域的竞赛变得良性。\n实现也必须只读取一次字段，如：\npublic Set\u0026lt;K\u0026gt; keySet() { Set\u0026lt;K\u0026gt; ks = keySet; // single racy read if (ks == null) { ks = new KeySet(); keySet = ks; } return ks; } 12. transient Collection\u0026lt;V\u0026gt; values; 在第一次请求此视图时，这些字段中的每个字段都会初始化为包含相应视图的实例。视图是无状态的，因此没有理由创建多个视图。\n13. public Set\u0026lt;K\u0026gt; keySet() 此实现返回一个AbstractSet的子类的集。子类的迭代器方法在该映射的entrySet()迭代器上返回一个“包装器对象”。size方法委托给此map的size方法，contains方法委托给此map的containsKey方法。\n在第一次调用此方法时创建该集合，并在响应所有后续调用时返回该集合。因为没有执行同步，因此对该方法的多个调用很可能不会全部返回同一个集合。\n源码如下：\npublic Set\u0026lt;K\u0026gt; keySet() { Set\u0026lt;K\u0026gt; ks = keySet; // 先看类变量keySet是否为null if (ks == null) { // 若为空，则创建一个AbstractSet的子类的实例 ks = new AbstractSet\u0026lt;K\u0026gt;() { // 迭代器方法实现 public Iterator\u0026lt;K\u0026gt; iterator() { return new Iterator\u0026lt;K\u0026gt;() { // 获取entrySet()方法所返回集合的迭代器，以下三个方法均基于该迭代器 private Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); public boolean hasNext() { return i.hasNext(); } public K next() { return i.next().getKey(); } public void remove() { i.remove(); } }; } // 以下四个方法均基于AbstractMap的对应方法 public int size() { return AbstractMap.this.size(); } public boolean isEmpty() { return AbstractMap.this.isEmpty(); } public void clear() { AbstractMap.this.clear(); } public boolean contains(Object k) { return AbstractMap.this.containsKey(k); } }; // 将刚创建的实例赋值给类变量keySet keySet = ks; } // 若不为空，直接返回 return ks; } 14. public Collection\u0026lt;V\u0026gt; values() 此实现返回一个AbstractCollection的子类的集合。子类的迭代器方法在该映射的entrySet()迭代器上返回一个“包装器对象”。size方法委托给此map的size方法，contains方法委托给此map的containsKey方法。\n在第一次调用此方法时创建该集合，并在响应所有后续调用时返回该集合。因为没有执行同步，因此对该方法的多个调用很可能不会全部返回同一个集合。\n源码如下：\n// 该方法在实现思路上与public Set\u0026lt;K\u0026gt; keySet()方法完全一致 public Collection\u0026lt;V\u0026gt; values() { Collection\u0026lt;V\u0026gt; vals = values; if (vals == null) { vals = new AbstractCollection\u0026lt;V\u0026gt;() { public Iterator\u0026lt;V\u0026gt; iterator() { return new Iterator\u0026lt;V\u0026gt;() { private Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); public boolean hasNext() { return i.hasNext(); } public V next() { return i.next().getValue(); } public void remove() { i.remove(); } }; } public int size() { return AbstractMap.this.size(); } public boolean isEmpty() { return AbstractMap.this.isEmpty(); } public void clear() { AbstractMap.this.clear(); } public boolean contains(Object v) { return AbstractMap.this.containsValue(v); } }; values = vals; } return vals; } 15. public abstract Set\u0026lt;Entry\u0026lt;K,V\u0026raquo; entrySet(); 抽象方法，获取当前map的条目的集合。\n16. public boolean equals(Object o) 比较指定对象是否与当前map相等。如果给定的对象也是一个map并且这两个map表示相同的映射，则返回true。更正式地说，如果两个mapm1、m2满足m1.entrySet().equals(m2.entrySet())，则m1和m2表示相同的映射。这确保equals方法在Map接口的不同实现中正常工作。\n这个实现首先检查指定的对象是否是本映射，如果是，则返回true。然后，检查指定对象是否是大小与此map的大小相同，如果不是，则返回false，如果是这样，它将迭代此map的entrySet集合，并检查指定的map是否包含此map包含的每个映射。如果指定的map未能包含这样的映射，则返回false。如果迭代完成，则返回true。\n源码如下：\npublic boolean equals(Object o) { // 若指定对象就是当前map，则直接返回true if (o == this) return true; // 若指定对象不是Map，则直接返回false if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; // 若指定对象是map，但元素数量与当前map不一致，则直接返回false if (m.size() != size()) return false; try { // 迭代所有键值对 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); // 取值当前映射的键和值 K key = e.getKey(); V value = e.getValue(); // 按照值是否为空采取不同的判断方式 if (value == null) { // 当前map的当前映射的值为空，则参数中指定的map的当前值也应该为空包含当前key，否则一票否决，直接返回false if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } // 迭代完，所有校验都通过了，返回true return true; } 17. public int hashCode() 返回此map的哈希码值。map的哈希码定义为map的entrySet()视图中每个条目的哈希码之和。这确保对于任何两个map m1和m2来说m1.equals(m2)意味着m1.hashCode()==m2.hashCode()，这也是Object的hashCode通用规范要求。\n此实现迭代entrySet()，对集合中的每个元素（条目）调用Map.Entry.hashCode()，并将结果相加。\n源码如下：\npublic int hashCode() { int h = 0; // 遍历所有条目，将每个条目的hash编码值加起来得到本map的hash编码值 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) h += i.next().hashCode(); return h; } 18. public String toString() 返回此map的字符串表示形式。字符串表示法由键值映射列表组成，其顺序为map的entrySet视图的迭代器返回，并用大括号\u0026quot;{}\u0026quot;括起来。相邻映射由字符\u0026quot;, \u0026quot;（逗号和空格）分隔。每个键值映射都呈现为键后跟一个等号（\u0026quot;=\u0026quot;），后跟对应的值。键和值通过String的valueOf(Object)转换为字符串。\n源码如下：\npublic String toString() { // 先获取entrySet的迭代器 Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); // 如果没有键值映射，则直接返回{} if (! i.hasNext()) return \u0026#34;{}\u0026#34;; // 使用StringBuilder来拼接字符串 StringBuilder sb = new StringBuilder(); // 先拼一个开头 sb.append(\u0026#39;{\u0026#39;); // 遍历条目集合 for (;;) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); // 如果key是当前map本身，则使用\u0026#34;(this Map)\u0026#34;来表示 sb.append(key == this ? \u0026#34;(this Map)\u0026#34; : key); // key与value之间的连接符 sb.append(\u0026#39;=\u0026#39;); // 如果value是当前map本身，则使用\u0026#34;(this Map)\u0026#34;来表示 sb.append(value == this ? \u0026#34;(this Map)\u0026#34; : value); if (! i.hasNext()) // 如果已迭代结束，则拼接一个结尾，然后返回字符串 return sb.append(\u0026#39;}\u0026#39;).toString(); // 未迭代结束，则拼接分隔符，此处不直接\u0026#34;sb.append(\u0026#39;, \u0026#39;)\u0026#34;而是\u0026#34;sb.append(\u0026#39;,\u0026#39;).append(\u0026#39; \u0026#39;)\u0026#34;是出于什么考虑呢？ sb.append(\u0026#39;,\u0026#39;).append(\u0026#39; \u0026#39;); } } 19. protected Object clone() throws CloneNotSupportedException 返回此AbstractMap实例的浅层副本：键和值本身不会被克隆。\n源码如下：\nprotected Object clone() throws CloneNotSupportedException { // 调用Object类的clone方法获取一个AbstractMap实例 AbstractMap\u0026lt;?,?\u0026gt; result = (AbstractMap\u0026lt;?,?\u0026gt;)super.clone(); // 将keySet和values均置空 result.keySet = null; result.values = null; return result; } 20. private static boolean eq(Object o1, Object o2) SimpleEntry和SimpleImmutableEntry的实用方法。测试是否相等，检查是否为空。\n源码如下：\nprivate static boolean eq(Object o1, Object o2) { return o1 == null ? o2 == null : o1.equals(o2); } 21. public static class SimpleEntry\u0026lt;K,V\u0026gt; implements Entry\u0026lt;K,V\u0026gt;, java.io.Serializable 一个条目维护一个键和一个值。可使用setValue方法更改该值。此类简化了构建自定义map实现的过程。例如，在方法Map.entrySet().toArray中返回SimpleEntry实例的数组就可能很方便。\n21.1 private final K key; 当前条码的键。\n21.2 private V value; 当前条目的值。\n21.3 public SimpleEntry(K key, V value) 创建代表从指定键到指定值的映射的条目。\n源码如下：\npublic SimpleEntry(K key, V value) { this.key = key; this.value = value; } 21.4 public SimpleEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) 创建代表与指定条目相同映射的条目。\n源码如下：\npublic SimpleEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) { this.key = entry.getKey(); this.value = entry.getValue(); } 21.5 public K getKey() 返回当前条目对应的键。\npublic K getKey() { return key; } 21.6 public V getValue() 返回当前条目对应的值。\npublic V getValue() { return value; } 21.7 public V setValue(V value) 用指定的值替换此条目当前对应的值。\npublic V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } 21.8 public boolean equals(Object o) 比较给定的对象是否与当前条目相等。如果给定的对象也是map的条目，且与当前条目代表相同的键值映射，则返回true。更准确的说，两个条目e1和e2满足如下条件则认为其代表相同的映射：\n(e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) \u0026amp;\u0026amp; (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) 这确保了equals方法在Map.Entry接口的不同实现中正常工作。\n源码如下：\npublic boolean equals(Object o) { // 如果指定对象不是Map.Entry实现，则直接返回true if (!(o instanceof Map.Entry)) return false; Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry\u0026lt;?,?\u0026gt;)o; // 使用私有方法eq进行判断键是否相等、值是否相等 return eq(key, e.getKey()) \u0026amp;\u0026amp; eq(value, e.getValue()); } 21.9 public int hashCode() 返回当前map条目的哈希编码值。map条目的哈希编码值被定义为：(e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())。这也满足了Object的通用规范，即对任意两个条目e1和e2来说e1.equals(e2)也就意味着e1.hashCode()==e2.hashCode()。\npublic int hashCode() { return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } 21.10 public String toString() 返回当前map条目的字符串形式。本实现所返回的字符串形式为：条目的键的字符串形式后面是等于号（=），再后面是条目的值的字符串形式。\npublic String toString() { return key + \u0026#34;=\u0026#34; + value; } 22. public static class SimpleImmutableEntry\u0026lt;K,V\u0026gt; implements Entry\u0026lt;K,V\u0026gt;, java.io.Serializable 本Entry维护了不可变的键和值。该类不支持setValue方法。本类可便于在返回线程安全的键值映射快照方法中使用。\n22.1 private final K key; 当前条目所维护的键。\n22.2 private final V value; 当前条目所维护的值。\n22.3 public SimpleImmutableEntry(K key, V value) 创建一个代表映射的条目，从指定的键指向指定的值。\npublic SimpleImmutableEntry(K key, V value) { this.key = key; this.value = value; } 22.4 public SimpleImmutableEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) 创建与指定条目相同映射的条目。\npublic SimpleImmutableEntry(Entry\u0026lt;? extends K, ? extends V\u0026gt; entry) { this.key = entry.getKey(); this.value = entry.getValue(); } 22.5 public K getKey() 返回当前条码的键。\npublic K getKey() { return key; } 22.6 public V getValue() 返回当前条目的值。\npublic V getValue() { return value; } 22.7 public V setValue(V value) 用指定的值代替当前条目的值（可选操作）。这个实现只是抛出UnsupportedOperationException，因为这个类实现了一个不可变的映射条目。\npublic V setValue(V value) { throw new UnsupportedOperationException(); } 22.8 public boolean equals(Object o) 比较给定的对象是否与当前条目相等。如果给定的对象也是map的条目，且与当前条目代表相同的键值映射，则返回true。更准确的说，两个条目e1和e2满足如下条件则认为其代表相同的映射：\n(e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) \u0026amp;\u0026amp; (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) 这确保了equals方法在Map.Entry接口的不同实现中正常工作。\npublic boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry\u0026lt;?,?\u0026gt;)o; return eq(key, e.getKey()) \u0026amp;\u0026amp; eq(value, e.getValue()); } 该方法与SimpleEntry的equals方法完全相同。\n22.9 public int hashCode() 返回当前map条目的哈希编码值。map条目的哈希编码值被定义为：(e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())。这也满足了Object的通用规范，即对任意两个条目e1和e2来说e1.equals(e2)也就意味着e1.hashCode()==e2.hashCode()。\npublic int hashCode() { return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } 该方法与SimpleEntry的hashCode方法完全相同。\n22.10 public String toString() 返回当前map条目的字符串形式。本实现所返回的字符串形式为：条目的键的字符串形式后面是等于号（=），再后面是条目的值的字符串形式。\npublic String toString() { return key + \u0026#34;=\u0026#34; + value; } 该方法与SimpleEntry的toString方法完全相同。\n","description":"1. protected AbstractMap() 2. public int size() 3. public boolean isEmpty() 4. public boolean containsValue(Object value) 5. public boolean containsKey(Object key) 6. public V get(Object key) 7. public V put(K key, V value) 8. public V remove(Object key) 9. public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 10. public void clear() 11. transient Set\u0026lt;K\u0026gt; keySet; 12. transient Collection\u0026lt;V\u0026gt; values; 13. public Set\u0026lt;K\u0026gt; keySet() 14. public Collection\u0026lt;V\u0026gt; values() 15. public abstract Set\u0026lt;Entry\u0026lt;K,V\u0026raquo; entrySet(); 16."},{"id":18,"href":"/jdk8-src-note/java/util/Vector/","title":"Vector","parent":"util","content":" 1. protected Object[] elementData; 2. protected int elementCount; 3. protected int capacityIncrement; 4. private static final long serialVersionUID = -2767605614048989439L; 5. public Vector(int initialCapacity, int capacityIncrement) 6. public Vector(int initialCapacity) 7. public Vector() 8. public Vector(Collection\u0026lt;? extends E\u0026gt; c) 9. public synchronized void copyInto(Object[] anArray) 10. public synchronized void trimToSize() 11. public synchronized void ensureCapacity(int minCapacity) 12. private void ensureCapacityHelper(int minCapacity) 13. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 14. private void grow(int minCapacity) 15. private static int hugeCapacity(int minCapacity) 16. public synchronized void setSize(int newSize) 17. public synchronized int capacity() 18. public synchronized int size() 19. public synchronized boolean isEmpty() 20. public Enumeration\u0026lt;E\u0026gt; elements() 21. public boolean contains(Object o) 22. public int indexOf(Object o) 23. public synchronized int indexOf(Object o, int index) 24. public synchronized int lastIndexOf(Object o) 25. public synchronized int lastIndexOf(Object o, int index) 26. public synchronized E elementAt(int index) 27. public synchronized E firstElement() 28. public synchronized E lastElement() 29. public synchronized void setElementAt(E obj, int index) 30. public synchronized void removeElementAt(int index) 31. public synchronized void insertElementAt(E obj, int index) 32. public synchronized void addElement(E obj) 33. public synchronized boolean removeElement(Object obj) 34. public synchronized void removeAllElements() 35. public synchronized Object clone() 36. public synchronized Object[] toArray() 37. public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a) 38. E elementData(int index) 39. public synchronized E get(int index) 40. public synchronized E set(int index, E element) 41. public synchronized boolean add(E e) 42. public boolean remove(Object o) 43. public void add(int index, E element) 44. public synchronized E remove(int index) 45. public void clear() 46. public synchronized boolean containsAll(Collection c) 47. public synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 48. public synchronized boolean removeAll(Collection c) 49. public synchronized boolean retainAll(Collection c) 50. public synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 51. public synchronized boolean equals(Object o) 52. public synchronized int hashCode() 53. public synchronized String toString() 54. public synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 55. protected synchronized void removeRange(int fromIndex, int toIndex) 56. private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException 57. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 58. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index) 59. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator() 60. public synchronized Iterator\u0026lt;E\u0026gt; iterator() 61. private class Itr implements Iterator\u0026lt;E\u0026gt; 61.1 int cursor; 61.2 int lastRet = -1; 61.3 int expectedModCount = modCount; 61.4 public boolean hasNext() 61.5 public E next() 61.6 public void remove() 61.7 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 61.8 final void checkForComodification() 62. final class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; 62.1 ListItr(int index) 62.2 public boolean hasPrevious() 62.3 public int nextIndex() 62.4 public int previousIndex() 62.5 public E previous() 62.6 public void set(E e) 62.7 public void add(E e) 63. public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action) 64. public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 65. public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 66. public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c) 67. public Spliterator\u0026lt;E\u0026gt; spliterator() 68. static final class VectorSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt; 68.1 private final Vector\u0026lt;E\u0026gt; list; 68.2 private Object[] array; 68.3 private int index; 68.4 private int fence; 68.5 private int expectedModCount; 68.6 VectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount) 68.7 private int getFence() 68.8 public Spliterator\u0026lt;E\u0026gt; trySplit() 68.9 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 68.10 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 68.11 public long estimateSize() 68.12 public int characteristics() Vector类实现了一个可增长的对象数组。像数组一样，它包含可以使用整数索引访问的组件。但是，Vector的大小可以根据需要增加或缩小，以在Vector创建后能够添加和删除项目。\n每个vector都尝试通过维护一个capacity和一个capacityIncrement来优化存储管理。capacity始终至少与vector大小一样大，通常它会更大，因为随着组件添加到vector中，vector的存储以块的形式增加capacityIncrement的大小。一个应用程序可以在插入大量组件之前增加一个vector的容量，这将减少增量重新分配的次数。\n此类的iterator和listIterator方法返回的迭代器是“快速失败”的：如果在创建迭代器后的任何时间对vector进行结构上的修改，除了通过迭代器自己的remove或add方法之外，迭代器将抛出一个ConcurrentModificationException。因此，面对并发修改，迭代器快速而干净地失败，而不是在未来不确定的时间冒任意、不确定行为的风险。elements方法返回的Enumeration不是快速失败的。\n请注意，无法保证迭代器的快速失败行为，因为一般而言，在存在非同步地并发修改的情况下不可能做出任何严格保证。快速失败的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写一个依赖于这个异常来保证其正确性的程序是错误的：迭代器的快速失败行为应该只用于检测错误。\n从 Java 2 平台 v1.2 开始，该类经过改造实现了List接口，使其成为“Java 集合框架”的成员。与新的集合实现不同，Vector是同步的。如果不需要线程安全的实现，建议使用ArrayList代替Vector。\n1. protected Object[] elementData; 存储vector组件的数组缓冲区。vector的容量是这个数组缓冲区的长度，并且至少足够包含vector的所有元素。\nVector中最后一个元素之后的任何数组元素都为空。\n2. protected int elementCount; 此Vector对象中的有效组件数。组件elementData[0]到elementData[elementCount-1]是实际的条目。\n3. protected int capacityIncrement; 当vector的大小要变得大于其容量时，vector的容量自动增加的量。如果容量增量小于或等于零，则每次需要增长时，vector的容量都会增加一倍。\n4. private static final long serialVersionUID = -2767605614048989439L; 使用 JDK 1.0.2 中的 serialVersionUID 实现互通性。\n5. public Vector(int initialCapacity, int capacityIncrement) 构造一个具有指定初始容量和容量增量的空vector。\n其源码如下：\npublic Vector(int initialCapacity, int capacityIncrement) { // 调用AbstractList() super(); // 初始容量不可小于0 if (initialCapacity \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); // 初始化组件数组，也即元素数组 this.elementData = new Object[initialCapacity]; // 设定容量增量 this.capacityIncrement = capacityIncrement; } 6. public Vector(int initialCapacity) 构造一个具有指定初始容量且容量增量为零的空vector。\n源码如下：\npublic Vector(int initialCapacity) { this(initialCapacity, 0); } 7. public Vector() 构造一个空vector，使其内部数据数组的大小为10并且其标准容量增量为零。\n源码如下：\npublic Vector() { this(10); } 8. public Vector(Collection\u0026lt;? extends E\u0026gt; c) 构造一个包含指定集合元素的vector，按照集合的迭代器返回的顺序。\n源码如下：\npublic Vector(Collection\u0026lt;? extends E\u0026gt; c) { // 将参数中给定集合转化为数组 Object[] a = c.toArray(); // 数组长度即本Vector实例的元素数量 elementCount = a.length; // 如果指定集合是ArrayList，则数组a可直接赋值给本Vector实例用于存储数据的数组 if (c.getClass() == ArrayList.class) { elementData = a; } else { // 非ArrayList，可能与Vector实现差异较大，此处进行数组复制 elementData = Arrays.copyOf(a, elementCount, Object[].class); } } 9. public synchronized void copyInto(Object[] anArray) 将此vector的组件（即元素）复制到指定的数组中。此vector中索引k处的项目被复制到anArray的k位置。\n源码如下：\npublic synchronized void copyInto(Object[] anArray) { System.arraycopy(elementData, 0, anArray, 0, elementCount); } 10. public synchronized void trimToSize() 将此vector的容量修剪为vector的当前大小。如果此vector的容量大于其当前大小，则通过将其内部数据数组替换为较小的数组，将容量更改为等于大小，该数组保存在字段elementData中。应用程序可以使用此操作来最小化vector的存储。\npublic synchronized void trimToSize() { // 增加修改次数 modCount++; // 取出当前数组长度 int oldCapacity = elementData.length; // 如果当前元素个数 小于 当前数组长度 if (elementCount \u0026lt; oldCapacity) { // 复制当前数组存放了数据的部分，也即丢弃数组后面未存放元素的部分 elementData = Arrays.copyOf(elementData, elementCount); } } 11. public synchronized void ensureCapacity(int minCapacity) 如有必要，增加此vector的容量，以确保它至少可以容纳由最小容量参数指定的组件数量。\n如果此vector的当前容量小于minCapacity，则通过将其保存在字段elementData中的内部数据数组替换为更大的数组来增加其容量。新数据数组的大小为旧大小加上capacityIncrement，除非capacityIncrement的值小于或等于0，在这种情况下，新容量将是旧容量的两倍；但如果这个新大小仍然小于minCapacity，那么新容量将是minCapacity。\n源码如下：\npublic synchronized void ensureCapacity(int minCapacity) { if (minCapacity \u0026gt; 0) { // 增加修改次数 modCount++; // 调用确保容量方法的非同步版本 ensureCapacityHelper(minCapacity); } } 12. private void ensureCapacityHelper(int minCapacity) 本方法实现了ensureCapacity的非同步版本。本类中的同步方法可以在内部调用此方法以确保容量，而不会产生额外同步的成本。\n源码如下：\nprivate void ensureCapacityHelper(int minCapacity) { // overflow-conscious code // 如果参数中的最小容量大于当前vector存放数据的数组容量，则调用grow方法增大数组的容量 if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } 13. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 要分配的数组的最大大小。\n一些 VM 在数组中保留一些头字。\n尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出 VM 限制\n14. private void grow(int minCapacity) 增加数组elementData大小。\n源码如下：\nprivate void grow(int minCapacity) { // overflow-conscious code // 取出当前数组elementData的容量 int oldCapacity = elementData.length; // 如果容量增量大于0，则 新数组容量 = 旧数组容量 + 容量增量 // 否则， 新数组容量 = 旧数组容量 + 旧数组容量 int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); // 经上述逻辑计算出的新数组容量如果仍小于参数中指定的最小容量，则新数组容量直接取参数中的最小容量 if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; // 经上述逻辑计算出的新数组容量如果大于Vector限定的数组最大数量，则调用获取最大容量方法 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // 将elementData复制到扩容后的新数组 elementData = Arrays.copyOf(elementData, newCapacity); } 15. private static int hugeCapacity(int minCapacity) 获取巨大的容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { // 如果最小容量小于0，则抛出OutOfMemoryError if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 如果最小容量大于Vector设定的最大数组容量，则巨大容量取Integer的最大值 // 否则，巨大容量取Vector设定的最大数组容量 return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 16. public synchronized void setSize(int newSize) 设置此vector的大小。如果新大小大于当前大小，则往此vector的末尾添加null。如果新大小小于当前大小，则索引newSize位置及其之后的所有组件都将被丢弃。\n源码如下：\npublic synchronized void setSize(int newSize) { // 增加修改次数 modCount++; // 如果新大小大于当前元素个数，则调用ensureCapacityHelper确保数组容量 if (newSize \u0026gt; elementCount) { ensureCapacityHelper(newSize); } else { // 新大小小于等于当前元素个数，则遍历数组从新大小到元素个数-1位置的部分 // 将遍历到的每个元素都置为null for (int i = newSize ; i \u0026lt; elementCount ; i++) { elementData[i] = null; } } // 将元素个数置为新大小 elementCount = newSize; } 17. public synchronized int capacity() 返回此vector的当前容量。\n当前容量：其内部数据数组（即此vector的elementData字段）的长度。\n源码如下：\npublic synchronized int capacity() { return elementData.length; } 18. public synchronized int size() 返回此vector中的组件数（即元素个数）。\n源码如下：\npublic synchronized int size() { return elementCount; } 19. public synchronized boolean isEmpty() 测试此vector是否没有组件。\n源码如下：\npublic synchronized boolean isEmpty() { return elementCount == 0; } 20. public Enumeration\u0026lt;E\u0026gt; elements() 返回此vector的组件的枚举。返回的Enumeration对象将生成此向量中的所有项目。生成的第一项是索引0处的项，然后是索引1处的项，依此类推。\n源码如下：\npublic Enumeration\u0026lt;E\u0026gt; elements() { // 因为Enumeration是一个接口，所以此处返回的是一个它的匿名内部类 // 该接口有两个方法：hasMoreElements()、nextElement() return new Enumeration\u0026lt;E\u0026gt;() { // 从0开始计数，此处count可以理解为游标 int count = 0; // 判断是否还有其他元素 public boolean hasMoreElements() { // 判断当前游标是否小于元素个数 return count \u0026lt; elementCount; } // 获取下一个元素 public E nextElement() { synchronized (Vector.this) { if (count \u0026lt; elementCount) { // 如果当前游标小于当前元素个数，则返回当前游标位置的元素 return elementData(count++); } } throw new NoSuchElementException(\u0026#34;Vector Enumeration\u0026#34;); } }; } 21. public boolean contains(Object o) 如果此vector包含指定的元素，则返回true。更正式地说，当且仅当此vector包含至少一个元素e使得(o==null ? e==null : o.equals(e))时才返回true。\n源码如下：\npublic boolean contains(Object o) { // 调用indexOf方法判断指定元素在数组中的索引位置是否大于等于0 return indexOf(o, 0) \u0026gt;= 0; } 22. public int indexOf(Object o) 返回指定元素在此vector中第一次出现的索引，如果此向量不包含该元素，则返回-1。更正式地说，返回最小索引i使得(o==null ? get(i)==null : o.equals(get(i)))，或者如果有是没有这样的索引则返回-1。\n源码如下：\npublic int indexOf(Object o) { // 从索引位置0处开始匹配 return indexOf(o, 0); } 23. public synchronized int indexOf(Object o, int index) 返回此vector中指定元素第一次出现的索引，从index开始搜索，如果未找到该元素，则返回-1。更正式地说，返回最小索引i使得(i \u0026gt;= index \u0026amp;\u0026amp; (o==null ? get(i)==null : o.equals(get(i))))，如果没有这样的索引，则返回-1。\n源码如下：\npublic synchronized int indexOf(Object o, int index) { if (o == null) { // 指定对象为null，则遍历数组找到元素为null的索引位置 for (int i = index ; i \u0026lt; elementCount ; i++) if (elementData[i]==null) return i; } else { // 指定对象不为null，则遍历数组找到equals为true的元素的索引位置 for (int i = index ; i \u0026lt; elementCount ; i++) if (o.equals(elementData[i])) return i; } // 找不到则返回-1 return -1; } 24. public synchronized int lastIndexOf(Object o) 返回指定元素在此vector中最后一次出现的索引，如果此vector不包含该元素，则返回-1。更正式地，返回最大索引i使得(o==null ? get(i)==null : o.equals(get(i)))，或者如果没有这样的索引则返回-1。\n源码如下：\npublic synchronized int lastIndexOf(Object o) { return lastIndexOf(o, elementCount-1); } 25. public synchronized int lastIndexOf(Object o, int index) 返回指定元素在此vector中最后一次出现的索引，从index开始向前搜索（即向索引变小的方向搜索），如果未找到该元素，则返回-1。更正式地说，返回最高索引i使得(i \u0026lt;= index \u0026amp;\u0026amp; (o==null ? get(i)==null : o.equals(get(i))))，如果没有这样的索引则返回-1。\n源码如下：\npublic synchronized int lastIndexOf(Object o, int index) { // 检查开始索引是否大于等于元素个数，如果是则抛出数组越界异常 if (index \u0026gt;= elementCount) throw new IndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34;+ elementCount); // 和indexOf方法类似，指定对象是否为空走不同的逻辑 if (o == null) { // 从index位置开始，一直往前遍历（索引变小的方向） for (int i = index; i \u0026gt;= 0; i--) // 命中即返回 if (elementData[i]==null) return i; } else { for (int i = index; i \u0026gt;= 0; i--) if (o.equals(elementData[i])) return i; } // 未找到，则返回-1 return -1; } 26. public synchronized E elementAt(int index) 返回指定索引处的组件（即元素）。\n此方法在功能上与get(int)方法相同（get(int)是List接口的方法之一）。\n源码如下：\npublic synchronized E elementAt(int index) { // 数组越界检查 if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } // 调用elementData方法 return elementData(index); } 27. public synchronized E firstElement() 返回此vector的第一个组件（索引0处的项目）。\n源码如下：\npublic synchronized E firstElement() { if (elementCount == 0) { throw new NoSuchElementException(); } // 没有特殊逻辑，就是从数组中根据索引0取数据 return elementData(0); } 28. public synchronized E lastElement() 返回vector的最后一个组件。\n源码如下：\npublic synchronized E lastElement() { if (elementCount == 0) { throw new NoSuchElementException(); } // 返回elementData数组中最后一个元素，对应索引位置为：元素个数 - 1 return elementData(elementCount - 1); } 29. public synchronized void setElementAt(E obj, int index) 将此vector的指定index处的组件设置为指定对象，该位置之前的组件将被丢弃。\n该索引必须大于或等于0且小于vector的当前大小。\n此方法在功能上与set(int, E)方法（它是List接口的方法之一）相同。请注意，set方法颠倒了参数的顺序，以更紧密地匹配数组用法。另请注意，set方法会返回存储在指定位置的旧值。\n源码如下：\npublic synchronized void setElementAt(E obj, int index) { if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } elementData[index] = obj; } 30. public synchronized void removeElementAt(int index) 删除指定索引处的组件。此vector中索引大于或等于指定index的每个组件向前移动，使其索引比之前的值小 1。这个vector的大小减少1。\n索引必须是大于或等于0且小于vector的当前大小的值。\n此方法在功能上与remove(int)方法（它是List接口的一部分）相同。需要注意，remove方法会返回存储在指定位置的旧值。\n源码如下：\npublic synchronized void removeElementAt(int index) { // 增加修改次数 modCount++; // 校验指定的索引index是否出于合理区间（即：大于等于0且小于元素个数） if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } else if (index \u0026lt; 0) { throw new ArrayIndexOutOfBoundsException(index); } // 计算出所需要异动位置的元素个数 int j = elementCount - index - 1; if (j \u0026gt; 0) { // 进行数组复制 // 将elementData数组的“index+1”及之后的元素复制到elementData数组的“index”处及之后的位置 // 复制元素的个数为j System.arraycopy(elementData, index + 1, elementData, index, j); } // 元素个数减一 elementCount--; // 将末尾的元素置为null，以使其可被垃圾回收 elementData[elementCount] = null; /* to let gc do its work */ } 31. public synchronized void insertElementAt(E obj, int index) 将指定对象作为组件插入此vector中指定index处。此vector中索引大于或等于指定index的每个组件向后移动，使其索引比之前的值大 1。\n索引必须是大于等于0且小于等于vector的当前大小的值。（如果索引等于vector的当前大小，则新元素将追加到当前vector。）\n此方法在功能上与add(int, E)方法（它是List接口的一部分）相同。需要注意，add方法颠倒了参数的顺序，以更接近数组用法。\n源码如下：\npublic synchronized void insertElementAt(E obj, int index) { // 修改次数加1 modCount++; // 校验指定的索引index是否在合理的区间内 if (index \u0026gt; elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt; \u0026#34; + elementCount); } // 确保vector容量足够 ensureCapacityHelper(elementCount + 1); // 执行数组复制，将elementData数组index及之后的元素复制到elementData的index+1处及之后的位置 // 复制的元素个数为元素个数-指定索引index System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); // 此时给index位置替换元素为指定的元素obj elementData[index] = obj; // 元素个数加1 elementCount++; } 32. public synchronized void addElement(E obj) 将指定的组件添加到此vector的末尾，将其大小增加 1。如果该vector的大小变得大于其容量，则该vector的容量会增加。\n此方法在功能上与add(E)方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized void addElement(E obj) { // 修改次数加1 modCount++; // 确保容量足够（不够的话会进行扩容） ensureCapacityHelper(elementCount + 1); // 将指定元素拼接到vector的末尾 elementData[elementCount++] = obj; } 33. public synchronized boolean removeElement(Object obj) 从此vector中删除指定参数的第一次（最低索引）出现。如果在此vector中找到对象，则向量中索引大于或等于该指定对象索引的每个元素将向前移动，使其索引比之前的值减1。\n此方法在功能上与remove(Object)方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized boolean removeElement(Object obj) { // 修改次数加1 modCount++; // 找到指定元素的索引位置（最小的那个） int i = indexOf(obj); // 如果找到了，则删除并返回true，否则返回false if (i \u0026gt;= 0) { // 删除指定索引位置的元素 removeElementAt(i); return true; } return false; } 34. public synchronized void removeAllElements() 删除此vector中的所有组件并将其大小设置为零。\n此方法在功能上与clear方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized void removeAllElements() { // 修改次数加1 modCount++; // Let gc do its work // 遍历数组，将所有元素置为null，以使其可被垃圾回收 for (int i = 0; i \u0026lt; elementCount; i++) elementData[i] = null; // 将元素个数置为0 elementCount = 0; } 35. public synchronized Object clone() 返回此vector的克隆。该副本将包含对内部数据数组副本的引用，而不是对这个Vector对象的原始内部数据数组的引用。\n源码如下：\npublic synchronized Object clone() { try { // 调用Object的clone方法获取一个Vector对象，但此时持有元素的数据数组未被复制 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Vector\u0026lt;E\u0026gt; v = (Vector\u0026lt;E\u0026gt;) super.clone(); // 将持有元素的数据数组复制一份，并赋值给上面新得到的Vector对象 v.elementData = Arrays.copyOf(elementData, elementCount); // 修改次数赋值为0 v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn\u0026#39;t happen, since we are Cloneable throw new InternalError(e); } } 36. public synchronized Object[] toArray() 以正确的顺序返回包含此Vector中所有元素的数组。\n源码如下：\npublic synchronized Object[] toArray() { // 返回的是内部数据数组的副本 return Arrays.copyOf(elementData, elementCount); } 37. public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a) 以正确的顺序返回包含此Vector中所有元素的数组；返回数组的运行时类型是指定数组的类型。如果Vector适合指定的数组，则在其中返回。否则，将使用指定数组的运行时类型和此Vector的大小分配一个新数组。\n如果Vector适合指定的数组并有剩余空间（即，该数组的元素比Vector多），则紧跟Vector末尾的数组中的元素将设置为null。（如果调用者知道Vector不包含任何空元素，这对于确定Vector的长度很有用。）\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a) { // 如果指定的数组a的大小小于当前Vector对象的元素个数，则直接数组复制到一个新的数组并返回 if (a.length \u0026lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 指定数组a的大小大于等于当前Vector对象的元素个数，说明其可以承载当前Vector的所有元素 // 将Vector对象中持有元素的数据数组复制到指定的数组a System.arraycopy(elementData, 0, a, 0, elementCount); // 如果指定的数组a的容量大于当前Vector对象的大小，则在数组a的最后一个元素的下一个元素设置为null（也即elementCount索引位置） if (a.length \u0026gt; elementCount) a[elementCount] = null; return a; } 38. E elementData(int index) 获取指定索引位置的元素。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) E elementData(int index) { // 直接从数组中取出指定索引位置的元素 return (E) elementData[index]; } 39. public synchronized E get(int index) 返回此Vector中指定位置的元素。\npublic synchronized E get(int index) { // 指定索引的合法性检查 if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 返回数组中指定位置的元素 return elementData(index); } 40. public synchronized E set(int index, E element) 用指定的元素替换此Vector中指定位置的元素。\n源码如下：\npublic synchronized E set(int index, E element) { // 指定索引的合法性检查 if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 取出指定索引位置的原值 E oldValue = elementData(index); // 将指定索引位置的元素替换为指定的元素 elementData[index] = element; // 返回此索引位置的原值 return oldValue; } 41. public synchronized boolean add(E e) 将指定的元素附加到此Vector的末尾。\n源码如下：\npublic synchronized boolean add(E e) { // 修改次数加1 modCount++; // 确保容量足够 ensureCapacityHelper(elementCount + 1); // 将数组的elementCount索引位置设置为指定元素e，然后将elementCount加1 elementData[elementCount++] = e; return true; } 42. public boolean remove(Object o) 移除此Vector中第一次出现的指定元素，如果Vector不包含该元素，则它保持不变。更正式地说，删除满足(o==null ? get(i)==null : o.equals(get(i)))的最低索引i的元素，（如果存在这样的元素）。\n源码如下：\npublic boolean remove(Object o) { return removeElement(o); } 43. public void add(int index, E element) 在此Vector的指定位置插入指定元素。将当前在该位置的元素（如果有）和任何后续元素向右移动（将它们的索引加一）。\n源码如下：\npublic void add(int index, E element) { insertElementAt(element, index); } 44. public synchronized E remove(int index) 移除此Vector中指定位置的元素。将任何后续元素向左移动（将它们的索引中减一）。返回从Vector中删除的元素。\n源码如下：\npublic synchronized E remove(int index) { // 修改次数加1 modCount++; // 指定索引的合法性校验 if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 取出指定索引位置的原值 E oldValue = elementData(index); // 需要移动索引位置的元素个数 = 指定索引及其后面的元素 int numMoved = elementCount - index - 1; // 需要移动索引的元素个数大于0，则通过数组复制进行批量移动 if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将元素个数减1，然后将元素个数位置的元素置为null，以使其可被垃圾回收 elementData[--elementCount] = null; // Let gc do its work // 返回原值 return oldValue; } 45. public void clear() 从此Vector中删除所有元素。此调用返回后，Vector将为空（除非它引发异常）。\n源码如下：\npublic void clear() { removeAllElements(); } 46. public synchronized boolean containsAll(Collection c) 如果此Vector包含指定Collection中的所有元素，则返回true。\n当指定的集合为空时，会抛出NullPointerException。\n源码如下：\npublic synchronized boolean containsAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的containsAll进行判断 return super.containsAll(c); } 47. public synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定Collection中的所有元素按照指定该集合的迭代器返回的顺序追加到此Vector的末尾。如果在操作进行时修改了指定的Collection，则此操作的行为将变得未知。 （这意味着如果指定的Collection是此Vector且此Vector非空，则此次调用的行为未知。）\n如果此Vector由于调用而更改，则返回true。\n源码如下：\npublic synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 修改次数加1 modCount++; // 将指定的集合转化为数组 Object[] a = c.toArray(); // 取出数组的长度 int numNew = a.length; // 确保容量足够容纳下此数组 ensureCapacityHelper(elementCount + numNew); // 将数组a复制到此Vector的最后一个元素后面 System.arraycopy(a, 0, elementData, elementCount, numNew); // 增加元素个数 elementCount += numNew; // 返回新增加的元素个数是否不为0，不为0说明有新元素添加到此Vector，返回true return numNew != 0; } 48. public synchronized boolean removeAll(Collection c) 从此Vector中删除包含在指定Collection中的所有元素。\n源码如下：\npublic synchronized boolean removeAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的removeAll方法 return super.removeAll(c); } 49. public synchronized boolean retainAll(Collection c) 仅保留此Vector中包含在指定Collection中的元素。换句话说，从此Vector中删除所有未包含在指定Collection中的元素。\n源码如下：\npublic synchronized boolean retainAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的retainAll方法 return super.retainAll(c); } 50. public synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 将指定Collection中的所有元素插入此Vector的指定位置。将当前在该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的迭代器返回的顺序出现在Vector中。\npublic synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 增加修改次数 modCount++; // 指定索引的合法性校验，大于等于0 且 小于等于元素个数 if (index \u0026lt; 0 || index \u0026gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); // 将指定集合转化为数组 Object[] a = c.toArray(); // 数组大小 int numNew = a.length; // 确保此Vector的容量足够容纳下指定集合的所有元素 ensureCapacityHelper(elementCount + numNew); // 需移动索引的元素个数 int numMoved = elementCount - index; // 如果需移动索引的元素个数大于0，则执行数组复制，先往后移动这些元素 if (numMoved \u0026gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将指定集合转化的数组复制到此Vector数据数组的指定位置 System.arraycopy(a, 0, elementData, index, numNew); // 元素个数增加 elementCount += numNew; // 返回是否新增了元素至此Vector return numNew != 0; } 51. public synchronized boolean equals(Object o) 比较指定的Object与此Vector是否相等。当且仅当指定的Object也是一个List，两个List的大小相同，并且两个List中所有对应的元素对都相等时，才返回true。（如果(e1==null ? e2==null : e1.equals(e2))，说明两个元素e1和e2相等。）换句话说, 如果两个List以相同的顺序包含相同的元素，则它们被定义为相等。\n源码如下：\npublic synchronized boolean equals(Object o) { // 调用AbstractList的equals方法 return super.equals(o); } 52. public synchronized int hashCode() 返回此Vector的哈希编码值。\n源码如下：\npublic synchronized int hashCode() { // 调用AbstractList的hashCode方法 return super.hashCode(); } 53. public synchronized String toString() 返回此Vector的字符串表示形式，其中包含每个元素的字符串表示形式。\n源码如下：\npublic synchronized String toString() { // 调用AbstractCollection的toString方法 return super.toString(); } 54. public synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 返回此List中的fromIndex(包含)和toIndex(不包含)之间部分的视图。 （如果fromIndex和toIndex相等，则返回的List为空。）返回的List基于此List，因此返回的List中的更改会反映在此List中，反之亦然。返回的List支持此List支持的所有可选List操作。\n这种方法消除了对显式范围操作（数组通常存在的排序）的需要。通过对子列表视图而不是整个列表进行操作，任何需要列表的操作都可以用作范围操作。例如，以下惯用语法从List中删除一系列元素：list.subList(from, to).clear();，可以为indexOf和lastIndexOf构造类似的习惯用法，并且Collections类中的所有算法都可以应用于子列表。\n如果基础列表（即此列表）以除了通过返回列表以外的任何方式进行了结构修改，则此方法返回的列表的语义将变得未知。 （结构修改是那些改变List的大小，或者以其他方式扰乱它，以致正在进行的迭代可能会产生不正确的结果。）\n源码如下：\npublic synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { // 调用Collections中的方法获取一个同步的列表 return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); } 55. protected synchronized void removeRange(int fromIndex, int toIndex) 从此列表中删除所有索引在fromIndex（含）和toIndex（不含）之间的所有元素。将所有后续元素向左移动（减小其索引）。此调用减小列表的（toIndex-fromIndex）个元素。 （如果toIndex == fromIndex，则此操作无效。）\n源码如下：\nprotected synchronized void removeRange(int fromIndex, int toIndex) { // 增加修改次数 modCount++; // 计算出需移动多少个元素 int numMoved = elementCount - toIndex; // 将需移动的元素往前移动至fromIndex处 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work // 此时，Vector对象的元素个数未变，因为要被删除的范围内的元素已被其后的元素覆盖 // 需要将移动前的索引位置的元素置为空，以促使垃圾回收 // 例如： // 原Vector：[0, 1, 2, 3, 4]，现在对其调用removeRange(1, 3)方法 // 数组复制后：[0, 3, 4, 3, 4] // 最终：[0, 3, 4] int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; } 56. private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException 从流中加载Vector实例（即反序列化它）。此方法执行检查以确保字段的一致性。\n源码如下：\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { // 从流中读取出字段信息 ObjectInputStream.GetField gfields = in.readFields(); // 取出elementCount字段的值 int count = gfields.get(\u0026#34;elementCount\u0026#34;, 0); // 取出elementData字段的值 Object[] data = (Object[])gfields.get(\u0026#34;elementData\u0026#34;, null); // 对取出字段的合理性做校验 // 判断包括：count不能小于0 且 data不能为空 且count需与data的长度一致 if (count \u0026lt; 0 || data == null || count \u0026gt; data.length) { throw new StreamCorruptedException(\u0026#34;Inconsistent vector internals\u0026#34;); } // 将流中的elementCount赋值给当前Vector的elementCount elementCount = count; // 将流中的elementData数组的拷贝赋值给当前Vector的elementData elementData = data.clone(); } 57. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 将Vector实例的状态保存到流中（即序列化它）。该方法执行同步以保证序列化数据的一致性。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) { // 将capacityIncrement放入流 fields.put(\u0026#34;capacityIncrement\u0026#34;, capacityIncrement); // 将elementCount放入流 fields.put(\u0026#34;elementCount\u0026#34;, elementCount); // 执行对象数组的复制 data = elementData.clone(); } // 将对象数组的拷贝放入流 fields.put(\u0026#34;elementData\u0026#34;, data); // 将上述设定写入流中 s.writeFields(); } 58. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index) 返回在此列表元素上从指定位置开始的列表迭代器（以适当的顺序）。指定的索引指示初始调用next将返回的第一个元素。初次调用previous将返回指定索引减一的元素。\n返回的列表迭代器是“快速失败”的。\n源码如下：\npublic synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 指定索引的合理性校验 if (index \u0026lt; 0 || index \u0026gt; elementCount) throw new IndexOutOfBoundsException(\u0026#34;Index: \u0026#34;+index); // 返回一个ListItr实例 return new ListItr(index); } 59. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator() 返回此列表中的元素的列表迭代器（按适当顺序）。\n返回的列表迭代器是“快速失败”的。\n源码如下：\npublic synchronized ListIterator\u0026lt;E\u0026gt; listIterator() { // 返回一个从索引位置0处开始的列表迭代器实例 return new ListItr(0); } 60. public synchronized Iterator\u0026lt;E\u0026gt; iterator() 返回在此列表中元素上的迭代器（以正确的顺序）。\n返回的迭代器是“快速失败”的。\n源码如下：\npublic synchronized Iterator\u0026lt;E\u0026gt; iterator() { // 返回一个Itr实例 return new Itr(); } 61. private class Itr implements Iterator\u0026lt;E\u0026gt; AbstractList.Itr的优化版本。\n61.1 int cursor; 要返回的下一个元素的索引，也即“游标“。\n61.2 int lastRet = -1; 返回的最后一个元素的索引，如果还没有返回过元素，则是-1。\n61.3 int expectedModCount = modCount; 期望更新次数，默认值取当前Vector的修改次数。\n61.4 public boolean hasNext() 判断是否还有下一个元素可返回，若有，则返回true。\n源码如下：\npublic boolean hasNext() { // Racy but within spec, since modifications are checked // within or after synchronization in next/previous // 返回当前游标是否处于elementCount索引位置 return cursor != elementCount; } 61.5 public E next() 获取下一个元素。\n源码如下：\npublic E next() { synchronized (Vector.this) { // 检查是否有修改 checkForComodification(); int i = cursor; // 如果当前游标大于等于元素个数，则抛出无此元素异常 if (i \u0026gt;= elementCount) throw new NoSuchElementException(); // 游标后移一位（即加1） cursor = i + 1; // 将移动前的原游标位置赋值给最后返回的索引字段，然后取出该位置的元素返回 return elementData(lastRet = i); } } 61.6 public void remove() 删除当前迭代器最近一次返回的元素。\n源码如下：\npublic void remove() { // 如果最后返回索引字段的值为-1，说明要么还未调用next获取过元素，要么已经删除过该元素 if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); // 调用Vector的remove方法删除最后返回索引位置的元素 Vector.this.remove(lastRet); // 更新期望更新次数 expectedModCount = modCount; } // 当前游标置于最近一次返回的索引处 cursor = lastRet; // 最近返回的索引字段的值置为-1 lastRet = -1; } 61.7 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对迭代器尚未遍历到的元素执行给定的操作。\n源码如下：\n@Override public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); synchronized (Vector.this) { final int size = elementCount; int i = cursor; // 如果当前游标位置大于等于元素个数，在说明没有未遍历到的元素了，此时直接返回 if (i \u0026gt;= size) { return; } // 啊，这个缩进看的真难受 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前Vector存放数据的数组 final E[] elementData = (E[]) Vector.this.elementData; // 如果当前游标位置大于等于数组长度，说明可能存在并发修改，此时将抛出异常 if (i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 遍历剩余的元素，每次都执行并发修改检查 while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { // 对遍历到的元素执行给定的操作 action.accept(elementData[i++]); } // update once at end of iteration to reduce heap write traffic // 在遍历结束时更新一次以减少堆写入流量 cursor = i; lastRet = i - 1; // 再执行并发修改检查 checkForComodification(); } } 61.8 final void checkForComodification() 检查是否存在并发修改。\n源码如下：\nfinal void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 62. final class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; AbstractList.ListItr的优化版本。\n62.1 ListItr(int index) 构建一个ListItr。\n源码如下：\nListItr(int index) { super(); cursor = index; } 62.2 public boolean hasPrevious() 判断前面是否还有元素可返回，若有，则返回true。\n源码如下：\npublic boolean hasPrevious() { // 若当前游标不在索引位置0处，说明前面还有元素可返回 return cursor != 0; } 62.3 public int nextIndex() 返回下一个元素的索引。\n源码如下：\npublic int nextIndex() { // 即返回游标位置 return cursor; } 62.4 public int previousIndex() 返回上一个元素的索引。\n源码如下：\npublic int previousIndex() { // 返回当前游标位置减1 return cursor - 1; } 62.5 public E previous() 返回上一个元素。\n源码如下：\npublic E previous() { synchronized (Vector.this) { checkForComodification(); // 取出前面一个元素的索引位置 int i = cursor - 1; // 如果得到的索引位置小于0，则说明前面没有元素了，此时抛出异常 if (i \u0026lt; 0) throw new NoSuchElementException(); // 将得到的索引位置赋值给游标 cursor = i; // 将得到的索引位置赋值给最近一次返回的元素索引字段，然后返回该位置的元素 return elementData(lastRet = i); } } 62.6 public void set(E e) 替换掉最近一次返回的元素。\n源码如下：\npublic void set(E e) { // 如果最近返回的元素索引位置为-1，说明此时没有最近一次返回的元素（也可能已被删除），则此时抛出异常 if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); // 调用Vector的set方法 替换最近一次返回的元素为指定的元素 Vector.this.set(lastRet, e); } } 62.7 public void add(E e) 在最近一次返回的元素后面添加参数中指定的元素。\n源码如下：\npublic void add(E e) { int i = cursor; synchronized (Vector.this) { checkForComodification(); // 在当前游标位置插入指定的元素e Vector.this.add(i, e); // 更新期望更新次数 expectedModCount = modCount; } // 游标后移一位 cursor = i + 1; // 最近返回的元素索引置为-1 lastRet = -1; } 63. public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action) 对当前Vector实例的每个元素执行给定的动作。\n源码如下：\n@Override public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) final E[] elementData = (E[]) this.elementData; final int elementCount = this.elementCount; // 遍历当前Vector的对象数组 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; elementCount; i++) { // 对每个元素执行给定动作 action.accept(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 64. public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 删除当前Vector实例中满足给定条件的元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); // 先找出要被删除的元素 // figure out which elements are to be removed // 判断过程中抛出了任何异常，都不会导致此集合改变 // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final int size = elementCount; // 创建一个BitSet实例，用于记录要被删除记录的索引 final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; // 遍历当前Vector的对象数组 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前位置的元素 final E element = (E) elementData[i]; // 对当前位置的元素执行给定的条件判断 if (filter.test(element)) { // 如果判断的结果为true，则记录当前索引 removeSet.set(i); removeCount++; } } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } // shift surviving elements left over the spaces left by removed elements // 将未删除的元素向左移 final boolean anyToRemove = removeCount \u0026gt; 0; if (anyToRemove) { // 计算出剩余后的元素个数 final int newSize = size - removeCount; // 遍历对象数组，i代表了原数组索引，j代表新数组索引 for (int i=0, j=0; (i \u0026lt; size) \u0026amp;\u0026amp; (j \u0026lt; newSize); i++, j++) { // 取出i及以后的第一个未被删除的元素的索引 i = removeSet.nextClearBit(i); // 将该未被删除的元素放置到j位置 elementData[j] = elementData[i]; } // 遍历新对象数组（指完成元素移动后的数组），将后部的元素置为null for (int k=newSize; k \u0026lt; size; k++) { elementData[k] = null; // Let gc do its work } elementCount = newSize; if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } return anyToRemove; } 65. public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 对每个元素执行给定的操作，并用得到的返回值替换该元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = elementCount; // 遍历对象数组 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { // 对当前元素执行给定的操作，用计算出的结果替换当前元素 elementData[i] = operator.apply((E) elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 66. public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c) 使用给定的比较器对当前Vector进行排序。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c) { final int expectedModCount = modCount; // 使用Arrays.sort方法对对象数组进行排序 Arrays.sort((E[]) elementData, 0, elementCount, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 67. public Spliterator\u0026lt;E\u0026gt; spliterator() 在此列表的元素上创建一个“延迟绑定”、“快速失败”的拆分器。\n该拆分器报告的特征有：Spliterator#SIZED、Spliterator#SUBSIZED、Spliterator#ORDERED。覆盖该实现时应该记录附加的特征值的报告。\n源码如下：\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { // 返回一个VectorSpliterator实例 return new VectorSpliterator\u0026lt;\u0026gt;(this, null, 0, -1, 0); } 68. static final class VectorSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt; Vector的拆分器，类似于ArrayList的拆分器。\n68.1 private final Vector\u0026lt;E\u0026gt; list; 当前拆分器所持有的Vector实例。\n68.2 private Object[] array; 当前拆分器所持有的Vector实例（即上面的list）的元素数据数组（elementData）。\n68.3 private int index; 当前索引，在前进和拆分时修改。\n68.4 private int fence; 在使用前一直为-1；然后是从1到最后一个索引。\n68.5 private int expectedModCount; 设置围栏（fence）时初始化该值。\n68.6 VectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount) 创建覆盖给定范围的新拆分器，也是当前拆分器类的唯一构造函数。\n源码如下：\nVectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount) { this.list = list; this.array = array; this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; } 68.7 private int getFence() 首次使用时初始化围栏的值。\n源码如下：\nprivate int getFence() { // initialize on first use int hi; // 围栏小于0才执行初始化，否则直接返回当前的围栏值 if ((hi = fence) \u0026lt; 0) { synchronized(list) { // 初始化array属性，将其值置为列表的元素数据数组 array = list.elementData; // 期望修改次数置为列表的修改次数 expectedModCount = list.modCount; // 将围栏设置为列表的元素个数 hi = fence = list.elementCount; } } return hi; } 68.8 public Spliterator\u0026lt;E\u0026gt; trySplit() 执行拆分。\n源码如下：\npublic Spliterator\u0026lt;E\u0026gt; trySplit() { // 获取围栏位置、当前索引位置，然后基于这俩计算出从当前索引至围栏位置的中间位置 int hi = getFence(), lo = index, mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1; // 只有当当前索引小于上面计算出的中间位置时拆分才有意义，所以，不满足时不会进行拆分 return (lo \u0026gt;= mid) ? null : // 如果需要拆分时，创建一个新的VectorSpliterator实例，其范围为当前索引至中间位置 // 同时index = mid这一步，将当前拆分器的当前索引位置推后至中间位置 // 至此，完成拆分 new VectorSpliterator\u0026lt;E\u0026gt;(list, array, lo, index = mid, expectedModCount); } 68.9 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 对当前索引位置的元素执行给定的操作，然后将当前索引右移一位（即加一）。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { int i; if (action == null) throw new NullPointerException(); // 当前索引不可大于等于围栏位置 if (getFence() \u0026gt; (i = index)) { // 上面已经取出了当前索引的位置，赋值给了i，此处对当前索引进行右移操作，即加一 index = i + 1; // 对i位置的元素执行给定的操作 action.accept((E)array[i]); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } 68.10 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对当前拆分器的剩余元素依次执行给的操作。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { int i, hi; // hoist accesses and checks from loop Vector\u0026lt;E\u0026gt; lst; Object[] a; if (action == null) throw new NullPointerException(); // list不可为空 if ((lst = list) != null) { // 如果围栏小于0，则重新获取围栏 if ((hi = fence) \u0026lt; 0) { synchronized(lst) { expectedModCount = lst.modCount; a = array = lst.elementData; hi = fence = lst.elementCount; } } else a = array; // 如果数组不为空 且 当前索引大于等于0 且 围栏位置小于等于数组长度，则遍历数组 // 此处有个隐秘操作：index = hi，这一步将当前索引位置推至围栏位置，这样就不用每遍历到一个元素就对index进行加1了 if (a != null \u0026amp;\u0026amp; (i = index) \u0026gt;= 0 \u0026amp;\u0026amp; (index = hi) \u0026lt;= a.length) { // 遍历数组，从当前索引位置到围栏位置 while (i \u0026lt; hi) // 依次执行给定操作 action.accept((E) a[i++]); if (lst.modCount == expectedModCount) return; } } throw new ConcurrentModificationException(); } 68.11 public long estimateSize() 获取剩余元素的预估个数。\n源码如下：\npublic long estimateSize() { // 围栏位置减去当前索引位置 return (long) (getFence() - index); } 68.12 public int characteristics() 获取当前拆分器报告的特征值。\n源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } ","description":"1. protected Object[] elementData; 2. protected int elementCount; 3. protected int capacityIncrement; 4. private static final long serialVersionUID = -2767605614048989439L; 5. public Vector(int initialCapacity, int capacityIncrement) 6. public Vector(int initialCapacity) 7. public Vector() 8. public Vector(Collection\u0026lt;? extends E\u0026gt; c) 9. public synchronized void copyInto(Object[] anArray) 10. public synchronized void trimToSize() 11. public synchronized void ensureCapacity(int minCapacity) 12. private void ensureCapacityHelper(int minCapacity) 13. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 14."},{"id":19,"href":"/jdk8-src-note/java/util/Queue/","title":"Queue","parent":"util","content":" 1. boolean add(E e) 2. boolean offer(E e) 3. E remove() 4. E poll() 5. E element() 6. E peek() 设计用于在处理之前存放元素的集合。除了基本的Collection操作之外，队列还提供其他插入，提取和检查操作。这些方法均以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值（null或false，具体取决于操作）。插入操作的后一种形式是专门为与有限容量的Queue实现一起使用而设计的；在大多数实现中，插入操作不会失败。\nQueue方法摘要：\n抛出异常 返回特殊值 插入 add(e) offer(e) 删除 remove() poll() 检索 element() peek() 队列通常但不一定以FIFO（先进先出）的方式对元素进行排序。例外情况包括优先级队列（根据提供的比较器对元素进行排序或元素的自然排序）和LIFO（后进先出）队列（或堆栈）。无论使用哪种排序，队列的head都是通过调用remove()或poll()来删除的元素。在FIFO队列中，所有新元素都插入到队列的尾部。其他种类的队列可能使用不同的放置规则。每个Queue实现都必须指定其排序属性。\noffer方法在可能的情况下插入一个元素，否则返回false。这与Collection.add方法不同，该方法只能通过引发未经检查的异常来表示添加元素失败。offer方法被设计用于在正常情况下（而不是在例外情况下）发生故障（例如在固定容量（或“有界”）队列中）时使用。\nremove()和poll()方法删除并返回队列的开头（head）。确切地说，从队列中删除哪个元素是队列的排序策略决定的，不同实现的实现方法不同。remove()和poll()方法的区别仅在于队列为空时它们的行为：remove()方法引发异常，而poll()方法返回null。\nelement()和peek()方法返回（但不删除）队列头（head）。\nQueue接口未定义在并发编程中常见的阻塞队列方法。这些等待元素出现或空间可用的方法在java.util.concurrent.BlockingQueue接口中进行了定义，该接口扩展了Queue接口。\nQueue实现通常不允许插入null元素，尽管某些实现（例如LinkedList）不禁止插入null。即使在允许的实现中，也不应将null插入Queue中，因为poll方法也将null用作特殊的返回值，以指示队列不包含任何元素。\nQueue实现通常不定义equals和hashCode方法基于元素的版本，而是从类Object继承基于身份的版本，因为基于元素的相等性并不总是明确定义对于具有相同元素但排序属性不同的队列。\n该接口也是Java集合框架的成员。\n1. boolean add(E e) 如果可以立即将指定的元素插入此队列，而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出IllegalStateException。\n2. boolean offer(E e) 如果不会违反容量限制可以立即将指定的元素插入此队列。当使用容量受限的队列时，此方法通常比add更可取，后者插入元素时只能通过引发异常来标识无法插入。\n3. E remove() 检索并删除此队列的头。此方法与poll的不同之处仅在于，如果此队列为空，它将引发异常。\n4. E poll() 检索并删除此队列的开头，如果此队列为空，则返回null。\n5. E element() 检索但不删除此队列的头。此方法与peek的不同之处仅在于，如果此队列为空，它将引发异常。\n6. E peek() 检索但不删除此队列的开头，如果此队列为空，则返回null。\n","description":"1. boolean add(E e) 2. boolean offer(E e) 3. E remove() 4. E poll() 5. E element() 6. E peek() 设计用于在处理之前存放元素的集合。除了基本的Collection操作之外，队列还提供其他插入，提取和检查操作。这些方法均以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值（null或false，具体取决于操作）。插入操作的后一种形式是专门为与有限容量的Queue实现一起使用而设计的；在大多数实现中，插入操作不会失败。\nQueue方法摘要：\n抛出异常 返回特殊值 插入 add(e) offer(e) 删除 remove() poll() 检索 element() peek() 队列通常但不一定以FIFO（先进先出）的方式对元素进行排序。例外情况包括优先级队列（根据提供的比较器对元素进行排序或元素的自然排序）和LIFO（后进先出）队列（或堆栈）。无论使用哪种排序，队列的head都是通过调用remove()或poll()来删除的元素。在FIFO队列中，所有新元素都插入到队列的尾部。其他种类的队列可能使用不同的放置规则。每个Queue实现都必须指定其排序属性。\noffer方法在可能的情况下插入一个元素，否则返回false。这与Collection.add方法不同，该方法只能通过引发未经检查的异常来表示添加元素失败。offer方法被设计用于在正常情况下（而不是在例外情况下）发生故障（例如在固定容量（或“有界”）队列中）时使用。\nremove()和poll()方法删除并返回队列的开头（head）。确切地说，从队列中删除哪个元素是队列的排序策略决定的，不同实现的实现方法不同。remove()和poll()方法的区别仅在于队列为空时它们的行为：remove()方法引发异常，而poll()方法返回null。\nelement()和peek()方法返回（但不删除）队列头（head）。\nQueue接口未定义在并发编程中常见的阻塞队列方法。这些等待元素出现或空间可用的方法在java.util.concurrent.BlockingQueue接口中进行了定义，该接口扩展了Queue接口。\nQueue实现通常不允许插入null元素，尽管某些实现（例如LinkedList）不禁止插入null。即使在允许的实现中，也不应将null插入Queue中，因为poll方法也将null用作特殊的返回值，以指示队列不包含任何元素。\nQueue实现通常不定义equals和hashCode方法基于元素的版本，而是从类Object继承基于身份的版本，因为基于元素的相等性并不总是明确定义对于具有相同元素但排序属性不同的队列。\n该接口也是Java集合框架的成员。\n1. boolean add(E e) 如果可以立即将指定的元素插入此队列，而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出IllegalStateException。\n2. boolean offer(E e) 如果不会违反容量限制可以立即将指定的元素插入此队列。当使用容量受限的队列时，此方法通常比add更可取，后者插入元素时只能通过引发异常来标识无法插入。\n3. E remove() 检索并删除此队列的头。此方法与poll的不同之处仅在于，如果此队列为空，它将引发异常。\n4. E poll() 检索并删除此队列的开头，如果此队列为空，则返回null。\n5. E element() 检索但不删除此队列的头。此方法与peek的不同之处仅在于，如果此队列为空，它将引发异常。\n6. E peek() 检索但不删除此队列的开头，如果此队列为空，则返回null。"},{"id":20,"href":"/jdk8-src-note/java/util/LinkedList/","title":"LinkedList","parent":"util","content":" 1. transient int size = 0; 2. transient Node first; 3. transient Node last; 4. public LinkedList() 5. public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) 6. private void linkFirst(E e) 7. void linkLast(E e) 8. void linkBefore(E e, Node succ) 9. private E unlinkFirst(Node f) 10. private E unlinkLast(Node l) 11. E unlink(Node x) 12. public E getFirst() 13. public E getLast() 14. public E removeFirst() 15. public E removeLast() 16. public void addFirst(E e) 17. public void addLast(E e) 18. public boolean contains(Object o) 19. public int size() 20. public boolean add(E e) 21. public boolean remove(Object o) 22. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 23. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 24. public void clear() 25. public E get(int index) 26. public E set(int index, E element) 27. public void add(int index, E element) 28. public E remove(int index) 29. private boolean isElementIndex(int index) 30. private boolean isPositionIndex(int index) 31. private String outOfBoundsMsg(int index) 32. private void checkElementIndex(int index) 33. private void checkPositionIndex(int index) 34. Node node(int index) 35. public int indexOf(Object o) 36. public int lastIndexOf(Object o) 37. public E peek() 38. public E element() 39. public E poll() 40. public E remove() 41. public boolean offer(E e) 42. public boolean offerFirst(E e) 43. public boolean offerLast(E e) 44. public E peekFirst() 45. public E peekLast() 46. public E pollFirst() 47. public E pollLast() 48. public void push(E e) 49. public E pop() 50. public boolean removeFirstOccurrence(Object o) 51. public boolean removeLastOccurrence(Object o) 52. public ListIterator listIterator(int index) 53. private class ListItr implements ListIterator 53.1 private Node lastReturned; 53.2 private Node next; 53.3 private int nextIndex; 53.4 private int expectedModCount = modCount; 53.5 ListItr(int index) 53.6 public boolean hasNext() 53.7 public E next() 53.8 public boolean hasPrevious() 53.9 public E previous() 53.10 public int nextIndex() 53.11 public int previousIndex() 53.12 public void remove() 53.13 public void set(E e) 53.14 public void add(E e) 53.15 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 53.16 final void checkForComodification() 54. private static class Node 54.1 E item; 54.2 Node next; 54.3 Node prev; 54.4 Node(Node prev, E element, Node next) 55. public Iterator descendingIterator() 56. private class DescendingIterator implements Iterator 56.1 private final ListItr itr = new ListItr(size()); 56.2 public boolean hasNext() 56.3 public E next() 56.4 public void remove() 57. private LinkedList superClone() 58. public Object clone() 59. public Object[] toArray() 60. public T[] toArray(T[] a) 61. private static final long serialVersionUID = 876323262645176354L; 62. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 63. private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException 64. public Spliterator spliterator() 65. static final class LLSpliterator implements Spliterator 65.1 static final int BATCH_UNIT = 1 \u0026laquo; 10; 65.2 static final int MAX_BATCH = 1 \u0026laquo; 25; 65.3 final LinkedList list; 65.4 Node current; 65.5 int est; 65.6 int expectedModCount; 65.6 int batch; 65.7 LLSpliterator(LinkedList list, int est, int expectedModCount) 65.8 final int getEst() 65.9 public long estimateSize() 65.10 public Spliterator trySplit() 65.11 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 65.12 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 65.13 public int characteristics() List和Deque接口的双向链表实现。实现所有可选的列表操作，并允许所有元素（包括null）。\n所有操作均按双向链表的预期执行。索引到列表中的操作将从列表的开头或结尾开始遍历列表，从开头遍历还是从结尾遍历主要看哪个更接近指定索引的位置。\n请注意，此实现是不同步的。如果多个线程同时访问一个链表，并且至少一个线程在结构上修改了链表，则它必须在外部保证同步。（结构修改是添加或删除一个或多个元素的任何操作；仅设置元素的值不是结构修改。）通常，通过在自然封装列表的某个对象上进行同步来完成此操作。\n如果不存在这样的对象，则应使用Collections.synchronizedList方法“包装”列表。最好在创建时完成此操作，以防止意外的不同步访问列表：\nList list = Collections.synchronizedList(new LinkedList(...)); 此类的iterator和listIterator方法返回的迭代器是“快速失败”的：如果在创建迭代器后的任何时间除了通过迭代器自己的remove或add方法之外对列表进行结构修改，则迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间内冒任意、不确定行为的风险。\n请注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。快速失败的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常以确保其正确性的程序是错误的：迭代器的快速失败行为应仅用于检测错误。\n该类是Java集合框架的成员。\n1. transient int size = 0; 列表元素的数量。\n2. transient Node first; 指向第一个结点的指针。\n恒成立：(first == null \u0026amp;\u0026amp; last == null) || (first.prev == null \u0026amp;\u0026amp; first.item != null)\n3. transient Node last; 指向最后一个结点的指针。\n恒成立：(first == null \u0026amp;\u0026amp; last == null) || (last.next == null \u0026amp;\u0026amp; last.item != null)\n4. public LinkedList() 构造一个空列表。\n5. public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) 构造一个列表，该列表包含给定集合的元素，其顺序为该集合的迭代器返回顺序。\n先调用无参构造函数，再调用 addAll 将参数中指定集合的元素添加进当前链表。\n6. private void linkFirst(E e) 将参数中给定的元素 e 作为当前链表的第一个元素。\n操作方法如下：\nprivate void linkFirst(E e) { // 取出链表的第一结点 final Node\u0026lt;E\u0026gt; f = first; // 构造一个新的结点，该新结点的前驱结点为null、持有元素为e、后继结点为原第一结点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 设置新结点为第一结点 first = newNode; if (f == null) // 原第一结点为空，也即原链表是空的，并无结点，此时也设置当前列表的最后结点为上述新结点 last = newNode; else // 原第一结点不为空，说明原链表非空，此时需调整原第一结点的前驱结点为上述结点 f.prev = newNode; size++; modCount++; } 7. void linkLast(E e) 将参数中给定的元素 e 作为当前链表的最后一个元素。\n操作方法与 linkFirst 类似，只不过该方法是在链表的尾部进行操作。\n8. void linkBefore(E e, Node succ) 在非null结点succ之前插入元素e。\nvoid linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // 此处未对succ进行判空，但要求其必须非空，否则会抛出NPE // assert succ != null; // 取出给定结点的前驱结点 final Node\u0026lt;E\u0026gt; pred = succ.prev; // 构造一个新结点，以达成在给定结点与给定结点的前驱结点之间，将给定元素插入 // 该新结点的前驱结点为参数中给定结点的前驱结点 // 该新结点持有的元素为参数中给定的元素 // 该新结点的后继结点为参数中给定的结点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 将该新结点设置为给定结点的前驱结点 succ.prev = newNode; if (pred == null) // 如果给定结点的前驱结点为空，也即给定结点就是当前链表的第一结点，则设置链表的第一结点为该新结点 first = newNode; else // 如果给定结点的前驱结点不为空，则需要设置该前驱结点的后继结点为该新结点 pred.next = newNode; size++; modCount++; } 9. private E unlinkFirst(Node f) 取消到非空的第一结点f的链接。\nprivate E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // 给定的结点f需要是头结点并且不为空 // assert f == first \u0026amp;\u0026amp; f != null; // 取出给定结点所持有的元素 final E element = f.item; // 取出给定结点的后继结点 final Node\u0026lt;E\u0026gt; next = f.next; // 将给定结点所持有的元素置为空 f.item = null; // 将给定结点的后继结点置为null，帮助垃圾回收 f.next = null; // help GC // 将上述取出的给定结点的后继结点设置为当前列表的头结点 first = next; if (next == null) // 如果给定结点的后继结点为空，也即原链表仅一个结点，此时将链表的最后结点设置为null last = null; else // 如果给定结点的后继结点不为空，此时将该后继结点的前驱结点置为null，因为该后继结点已经成为链表的头结点了 next.prev = null; size--; modCount++; return element; } 10. private E unlinkLast(Node l) 取消到非空的尾结点l的链接。\n该方法与unlinkFirst类似，只不过在链表的尾部进行操作。\n11. E unlink(Node x) 取消到非null结点x链接。\n本方法主要用于在链表中拆掉某个结点，其本质就是改变链表中该结点及其前驱和后继结点的关系，源码如下：\nE unlink(Node\u0026lt;E\u0026gt; x) { // 结点x不可为空，否则会抛出NPE // assert x != null; // 取出结点x所持有的元素 final E element = x.item; // 取出结点x的后继结点 final Node\u0026lt;E\u0026gt; next = x.next; // 取出结点x的前驱结点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 修改前驱关系 if (prev == null) { // 前驱结点为空，说明给定的结点x是链表的头结点 // 此时将头结点设置给结点x的后继结点，这样就相当于从链表中拆掉了结点x first = next; } else { // 前驱结点不为空，说明给定的结点x并非链表的头结点 // 此时将此前驱结点的后继结点设置为结点x的后继结点 prev.next = next; // 同时将结点x的前驱结点设置为空 x.prev = null; } // 修改后继关系 if (next == null) { // 后继结点为空，说明给定的结点x是链表的尾结点 // 此时将链表的最后结点设置为结点x的前驱结点，相当于从链表中拆掉了结点x last = prev; } else { // 后继结点不为空，说明给定结点x并非链表的尾结点 // 此时，将结点x的后继结点的前驱结点设置为结点x的前驱结点 next.prev = prev; // 同时将结点x的后继结点置为空 x.next = null; } x.item = null; size--; modCount++; return element; } 12. public E getFirst() 返回此列表中的第一个元素。\n直接获取该链表的头结点 first ，如果该结点为空，则抛出 NoSuchElementException ，否则返回该结点所持有的元素。\n13. public E getLast() 返回此列表中的最后一个元素。\n与 getFirst() 方法类似，只不过操作的是尾结点。\n14. public E removeFirst() 从此列表中删除并返回第一个元素。\n该方法首先获取该链表的头结点 first ，如果该结点为空，则抛出 NoSuchElementException ，否则调用 unlinkFirst 方法拆除当前链表的头结点，该拆除方法将返回头结点所持有的元素，然后也作为本方法的返回值返回。\n15. public E removeLast() 从此列表中删除并返回最后一个元素。\n该方法与 removeLast 方法类似，只不过操作的是尾结点，调用的拆除方法是 unlinkLast 。\n16. public void addFirst(E e) 将给定的元素插入到此列表的开头。\n该方法直接调用 linkFirst 方法。\n17. public void addLast(E e) 将给定的元素追加到此列表的末尾。\n该方法直接调用 linkLast 方法。\n18. public boolean contains(Object o) 如果当前列表包含给定的元素 o 则返回 true 。更准确的说，当且仅当当前列表包含至少一个元素 o 满足 (o==null ? e==null : o.equals(e)) 时返回 true 。\n该方法的主要逻辑是：通过 indexOf 方法判断得到的返回值是否为 -1 ，如果为 -1 则说明不包含该元素。\n19. public int size() 返回此列表中的元素数。也就是返回当前列表的属性 size 。\n20. public boolean add(E e) 将指定的元素追加到此列表的末尾。\n直接调用 linkLast 方法，然后返回 true 。\n21. public boolean remove(Object o) 如果列表中存在指定元素，则从该列表中删除该元素的第一次出现。如果此列表不包含该元素，则它保持不变。更准确地说，删除满足 (o==null ? get(i)==null : o.equals(get(i))) 的最小索引 i 位置的元素（如果存在的话）。如果此列表包含指定的元素（或者等效地，如果此列表由于当前方法被调用而更改），则返回true。\n该方法的源码如下：\npublic boolean remove(Object o) { if (o == null) { // 当给定元素为null时，从头开始遍历链表，找到第一个元素为null的结点，然后调用unlink方法将其从链表中拆除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 给定元素不为null时，从头开始遍历链表，找到第一个元素与给定元素equals的结点，调用unlink将其拆除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } // 未找到给定元素，返回false return false; } 22. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 按照给定集合的迭代器返回的顺序，将给定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了给定的集合，则此操作的行为是不确定的。 （请注意，如果给定的集合是此列表，并且是非空的，则将发生这种情况。）\n该方法的源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 调用可指定插入位置的addAll方法，指定的位置为列表的末尾 // 这也意味着，默认的addAll是将给定集合的元素拼接到链表的结尾的，除非用户指定插入位置 return addAll(size, c); } 23. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 从指定位置开始，将指定集合中的所有元素插入此列表。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按指定集合的迭代器返回的顺序出现在列表中。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断给定的索引位置是否合理，需要大于等于0并小于等于size checkPositionIndex(index); // 将指定的集合转化为数组 Object[] a = c.toArray(); int numNew = a.length; // 如果数组长度为0，也即指定的集合为空集合，此时返回false if (numNew == 0) return false; // 定义两个结点，一个前驱结点、一个后继结点，这一步主要是找到将指定集合中元素编入链表的位置 // 指定集合的所有元素将放置在该前驱结点和后继结点之间 Node\u0026lt;E\u0026gt; pred, succ; if (index == size) { // index等于size，也就意味着此次是将指定集合的元素插入到列表的末尾 // 后继结点置空， succ = null; // 前驱结点置为当前链表的尾结点 pred = last; } else { // 取出指定索引位置index处的结点作为后继结点 succ = node(index); // 取出指定索引位置index处的前驱结点作为前驱结点 pred = succ.prev; } // 遍历指定的集合所转化的数组a，将其中的元素逐个编入链表 for (Object o : a) { // 将数组a中的元素强转为当前列表所持有的类型 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新结点，持有当前遍历到的元素 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); if (pred == null) // 如果前驱结点为null，说明是当前结点是头结点 first = newNode; else // 前驱结点不为null，则设置该前驱结点的后继结点为当前结点，从而实现将当前结点编入链表中 pred.next = newNode; // 设置前驱结点变量为当前结点，作为下一个结点的前驱结点 pred = newNode; } // 这一步主要是将原链表指定索引位置index以后的结点挂在指定集合最后一个元素所在结点的后面 if (succ == null) { // 后继结点为空，说明指定集合的元素是拼接到链表尾部的，则设置链表的尾部为当前结点（即指定结合最后元素所在的结点） last = pred; } else { // 后继结点不为空，则设置当前结点（即指定结合最后元素所在的结点）的后继结点为该后继结点 pred.next = succ; // 设置该后继结点的前驱结点为当前结点（即指定结合最后元素所在的结点） succ.prev = pred; } size += numNew; modCount++; return true; } 24. public void clear() 从此列表中删除所有元素。此调用返回后，该列表将为空。\npublic void clear() { // Clearing all of the links between nodes is \u0026#34;unnecessary\u0026#34;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator // 从头开始遍历链表 for (Node\u0026lt;E\u0026gt; x = first; x != null; ) { // 先把当前结点的后继结点取出 Node\u0026lt;E\u0026gt; next = x.next; // 然后将当前结点的元素、前驱结点、后继结点置为空 x.item = null; x.next = null; x.prev = null; x = next; } // 将链表的头部结点、尾部结点置为null first = last = null; size = 0; modCount++; } 25. public E get(int index) 返回此列表中指定位置的元素。\n源码如下：\npublic E get(int index) { // 校验元素索引 checkElementIndex(index); // 使用node方法取出指定索引位置的结点，然后返回该结点所持有的元素 return node(index).item; } 26. public E set(int index, E element) 用指定的元素替换此列表中指定位置的元素。\n元素如下：\npublic E set(int index, E element) { // 检查指定索引是否是当前列表元素的索引 checkElementIndex(index); // 取出指定索引位置的结点 Node\u0026lt;E\u0026gt; x = node(index); // 取出指定位置结点的元素 E oldVal = x.item; // 替换指定位置结点的元素为指定的元素 x.item = element; // 返回当前结点原来的元素 return oldVal; } 27. public void add(int index, E element) 将指定的元素插入此列表中的指定位置。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引添加一个）。\n源码如下：\npublic void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); if (index == size) // 如果index等于size，则说明指定元素需要拼接到结尾 linkLast(element); else // index不等于size，则先使用node方法取出指定位置的结点 // 然后调用linkBefore将指定元素插入到该结点之前 linkBefore(element, node(index)); } 28. public E remove(int index) 删除当前列表中指定位置的元素。然后将后面的元素左移（即索引减1）。返回被删除的元素。\n源码如下：\npublic E remove(int index) { // 先判断指定索引是否是当前列表元素的索引 checkElementIndex(index); // 先调用node方法获取指定索引位置的结点，再调用unlink方法将此结点从当前链表中拆除 return unlink(node(index)); } 29. private boolean isElementIndex(int index) 判断参数是否为现有元素的索引。要求索引大于等于0并且小于size。\n源码如下：\nprivate boolean isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } 30. private boolean isPositionIndex(int index) 判断参数是否是迭代器或添加操作的有效位置的索引。\n其源码如下：\nprivate boolean isPositionIndex(int index) { // index必须大于等于0，并且小于等于列表的size // 此处给定的索引位置等于size也可以是因为该方法还用于插入元素时的索引判断，而插入时可以插入到列表的末尾，此时的插入位置正好为size return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= size; } 31. private String outOfBoundsMsg(int index) 构造一个 IndexOutOfBoundsException 异常的详细信息。在许多可能的错误处理代码重构中，这种“概述”在服务器和客户机vm中都表现得最好。\n32. private void checkElementIndex(int index) 检查指定索引是否是当前列表元素的索引，不满足的话则抛出数组越界异常。\n源码如下：\nprivate void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 33. private void checkPositionIndex(int index) 检查位置索引，其源码如下：\nprivate void checkPositionIndex(int index) { // 此处调用位置索引判断方法，如果是非合理索引位置，则抛出数组越界异常 if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 34. Node node(int index) 返回指定元素索引处的（非空）结点。\n源码如下：\nNode\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1，对size做右移1位的操作，类似于对其做除以2的操作，但不会四舍五入而是直接舍弃 // 此处判断指定的索引index是更靠近链表的开头还是结尾，从更靠近index的一端开始遍历可以节省开销 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { // 从头部开始遍历 Node\u0026lt;E\u0026gt; x = first; // 一直找到指定索引位置的结点，然后返回 for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 从尾部开始遍历 Node\u0026lt;E\u0026gt; x = last; // 一直找到指定索引位置的结点，然后返回 for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } 35. public int indexOf(Object o) 返回给定的元素在当前列表中第一次出现的索引位置，或者如果该元素在当前列表中不存在的话返回 -1 。更准确的说，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最小索引 i ，或者无此索引的话返回 -1 。\n索引，更像是基于数组的存储结构中才有的。其实， indexOf 是 List 接口中定义的方法，所以， LinkedList 中也实现了该方法，其并不能像基于数组的存储结构中那样，直接返回该元素在数组中的索引，而是从头开始遍历链表，从0开始计数，每经过一个结点，该计数值加1，命中的时候直接返回该计数值，源码如下：\npublic int indexOf(Object o) { // 从0开始计数 int index = 0; if (o == null) { // 给定对象为空时，判断结点持有的元素是否为空，为空则命中 // 从头开始遍历当前链表 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { // 判断结点持有的元素是否为空，若是，则返回当前计数值 if (x.item == null) return index; // 当前结点未命中，计数值加1 index++; } } else { // 给定对象不为空空时，通过equals判断结点持有的元素与给定元素是否相等，相等则命中 // 从头开始遍历当前链表 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { // 通过equals判断结点持有的元素与给定元素是否相等，若是，则返回当前计数值 if (o.equals(x.item)) return index; // 当前结点未命中，计数值加1 index++; } } // 当前列表中未匹配到给定的元素，返回-1 return -1; } 36. public int lastIndexOf(Object o) 返回当前列表中指定元素的最后一次出现的索引位置，或者如果指定元素在当前列表中不存在的话返回-1。更准确地说，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最大索引 i 或者指定元素不存在的话返回-1。\n该方法与 indexOf 类似，只不过当前方法是从链表的尾部开始向前遍历。\n37. public E peek() 检索但不删除列表的头部元素（第一个元素）。\n该方法的源码如下：\npublic E peek() { // 首先取到头部结点 final Node\u0026lt;E\u0026gt; f = first; // 如果头部结点为空，则返回空，否则返回头部结点所持有的元素 return (f == null) ? null : f.item; } 38. public E element() 检索但不删除列表的头部元素（第一个元素）。\n该方法的源码如下：\npublic E element() { // 直接调用getFirst方法 return getFirst(); } 当前方法与 peek 的不同之处在于，当前方法在获取到的头部结点为空时，抛出 NoSuchElementException 。\n39. public E poll() 检索以及删除列表的头部元素（第一个元素）。\n当前方法的源码如下：\npublic E poll() { // 先取出列表的头部结点 final Node\u0026lt;E\u0026gt; f = first; // 如果头部结点为空则返回空，否则调用unlinkFirst方法拆除当前头部结点 return (f == null) ? null : unlinkFirst(f); } 40. public E remove() 检索以及删除列表的头部元素（第一个元素）。\n当前方法的源码如下：\npublic E remove() { // 直接调用removeFirst方法 return removeFirst(); } 该方法与 poll 方法的不同之处在于，该方法在获取到的头部结点为空时会抛出 NoSuchElementException 。\n41. public boolean offer(E e) 将给定的元素添加到列表的尾部（最后一个元素）。\n当前方法的源码如下：\npublic boolean offer(E e) { // 直接调用add方法 return add(e); } 42. public boolean offerFirst(E e) 将指定的元素插入到列表的前面。\n源码如下：\npublic boolean offerFirst(E e) { // 直接调用addFirst方法 addFirst(e); return true; } 43. public boolean offerLast(E e) 将指定的元素插入到列表的后面。\n源码如下：\npublic boolean offerLast(E e) { // 直接调用addLast方法 addLast(e); return true; } 44. public E peekFirst() 检索但不删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } 45. public E peekLast() 检索但不删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } 46. public E pollFirst() 检索并且删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; // 与peekFirst的不同之处就在于此处不是直接返回头结点的元素，而是调用unlinkFirst方法拆除头结点 return (f == null) ? null : unlinkFirst(f); } 47. public E pollLast() 检索并删除列表的最后一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E pollLast() { final Node\u0026lt;E\u0026gt; l = last; // 调用unlinkLast拆除尾部结点 return (l == null) ? null : unlinkLast(l); } 48. public void push(E e) 将元素压入此列表所表示的堆栈。换句话说，将元素插入此列表的前面。\n该方法直接调用了 addFirst 方法。\n49. public E pop() 从此列表所表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素。\n该方法直接调用了 removeFirst 方法。\n50. public boolean removeFirstOccurrence(Object o) 删除此列表中第一次出现的指定元素（从头到尾遍历列表）。如果列表不包含该元素，则它保持不变。\n该方法直接调用 remove 方法。\n51. public boolean removeLastOccurrence(Object o) 删除此列表中最后一次出现的指定元素（从头到尾遍历列表）。如果列表不包含该元素，则它保持不变。\n该方法的源码如下：\npublic boolean removeLastOccurrence(Object o) { // 判断指定的对象是否为空，以区分是使用 == null 进行判断还是使用equals进行判断 if (o == null) { // 从尾部开始遍历，命中则使用unlink方法拆除结点 for (Node\u0026lt;E\u0026gt; x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { for (Node\u0026lt;E\u0026gt; x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 52. public ListIterator listIterator(int index) 从列表中的指定位置开始（按适当顺序）返回此列表中元素的列表迭代器。遵守List.listIterator(int)的通用规范。\n该列表迭代器是“快速失败”的：如果在创建Iterator之后的任何时间对列表进行结构修改，除非是通过列表迭代器自己的remove或add方法，否则列表迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会干净利落地失败，而不会在未来的不确定时间内冒任意不确定行为的风险。\n该方法的源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 检查指定索引是否大于等于0且小于等于size checkPositionIndex(index); // 返回ListItr return new ListItr(index); } 53. private class ListItr implements ListIterator 该类是 LinkedList 的私有类，提供了 ListIterator 的实现。\n53.1 private Node lastReturned; 最后返回的结点。\n53.2 private Node next; 下一个要返回的结点。\n53.3 private int nextIndex; 下一个结点的索引位置。\n53.4 private int expectedModCount = modCount; 期望的修改次数。\n53.5 ListItr(int index) 当前类的唯一构造方法。\n该方法的源码如下：\nListItr(int index) { // assert isPositionIndex(index); // 如果指定的索引等于当前列表的元素个数，则设定下一个结点为null，否则就设置为指定索引位置的结点 next = (index == size) ? null : node(index); // 设定下一个结点的索引为指定索引 nextIndex = index; } 53.6 public boolean hasNext() 判断当前迭代器是否还有下一个元素。源码如下：\npublic boolean hasNext() { // 判断下一个结点的索引是否小于列表的元素个数，若小于则说明还有下一个元素 return nextIndex \u0026lt; size; } 53.7 public E next() 获取下一个元素。源码如下：\npublic E next() { // 检查是否存在并发修改，存在则抛出异常 checkForComodification(); // 判断是否有下一个元素，若没有则抛出异常 if (!hasNext()) throw new NoSuchElementException(); // 设置最后返回的结点为下一个结点 lastReturned = next; // 设置下一个结点的下一个结点为下一个结点，类似于游标后移一位 next = next.next; // 下一个结点索引加1 nextIndex++; // 返回最后返回结点所持有的元素，其实该最后返回的结点正是之前的下一个结点（next） return lastReturned.item; } 53.8 public boolean hasPrevious() 判断前面是否还有元素。源码如下：\npublic boolean hasPrevious() { // 判断下一个索引是否大于0，若是，则认定为前面还有元素 return nextIndex \u0026gt; 0; } 53.9 public E previous() 获取当前迭代器的上一个元素，源码如下：\npublic E previous() { // 进行并发修改检查 checkForComodification(); // 不存在上一个元素，则抛出异常 if (!hasPrevious()) throw new NoSuchElementException(); // 如果下一个结点为空，设定上一个返回的结点、下一个结点为列表的尾结点 // 如果下一个结点不为空，设定上一个返回的结点、下一个结点为下一个结点的前驱结点 lastReturned = next = (next == null) ? last : next.prev; // 下一个结点的索引减1 nextIndex--; // 返回最后返回结点所持有的元素 return lastReturned.item; } 53.10 public int nextIndex() 返回下一个元素的索引，源码如下：\npublic int nextIndex() { return nextIndex; } 53.11 public int previousIndex() 返回上一个元素的索引，源码如下：\npublic int previousIndex() { // 返回下一个元素的索引减1 return nextIndex - 1; } 53.12 public void remove() 删除当前遍历到的结点，也即最后返回的结点。源码如下：\npublic void remove() { // 进行并发修改检查 checkForComodification(); // 如果最后返回的结点为空，则抛出异常 if (lastReturned == null) throw new IllegalStateException(); // 取出最后返回结点的下一个结点 Node\u0026lt;E\u0026gt; lastNext = lastReturned.next; // 调用unlink方法拆除最后返回的结点 unlink(lastReturned); // 如果迭代器的下一个结点和最后返回的结点是同一个，则设置下一个结点为最后返回结点的下一个结点 // 否则，下一个结点的索引减1 if (next == lastReturned) next = lastNext; else nextIndex--; // 设定最后返回结点为空 lastReturned = null; // 期望修改次数加1 expectedModCount++; } 53.13 public void set(E e) 替换最后一次返回的元素为参数中指定的元素。源码如下：\npublic void set(E e) { // 如果最后一次返回的结点为空，则抛出 IllegalStateException if (lastReturned == null) throw new IllegalStateException(); // 检查是否存在并发修改 checkForComodification(); // 替换最后一次返回结点所持有的元素 lastReturned.item = e; } 53.14 public void add(E e) 在最后一次返回的元素之后添加指定的元素。源码如下：\npublic void add(E e) { // 进行并发修改检查 checkForComodification(); // 将最后返回的结点置为空 lastReturned = null; // 如果next为空，说明迭代器当前所在的结点即为尾结点，直接使用linkLast方法把指定元素凭借到尾部即可 // 如果next不为空，则把指定元素加到next结点之前 if (next == null) linkLast(e); else linkBefore(e, next); // 下一个元素索引加1 nextIndex++; // 期望并发修改次数加1 expectedModCount++; } 53.15 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对迭代器尚未遍历到的元素执行指定的操作。源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { // 指定的操作不可为空 Objects.requireNonNull(action); // 在没有并发修改且尚有未遍历到的元素时进行遍历 while (modCount == expectedModCount \u0026amp;\u0026amp; nextIndex \u0026lt; size) { // 对当前遍历到的元素执行给定操作 action.accept(next.item); // 设置最后返回结点为下一个结点 lastReturned = next; // 设置下一个结点为下一个结点的下一个结点 next = next.next; // 下一个元素索引加1 nextIndex++; } // 检查是否存在并发修改 checkForComodification(); } 53.16 final void checkForComodification() 检查是否存在并发修改，存在则抛出异常。源码如下：\nfinal void checkForComodification() { // 当前修改数与期望修改数不同，则抛出并发修改异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 54. private static class Node 链表中的结点，其持有一个元素，并记录当前结点的前驱结点、后继结点。\n54.1 E item; 当前结点持有的元素。\n54.2 Node next; 当前结点持有的后继结点，用于记录当前结点的下一个结点是哪个。\n54.3 Node prev; 当前结点持有的前驱结点，用于记录当前结点的上一个结点是哪个。\n54.4 Node(Node prev, E element, Node next) 当前结点类的构造函数，也是唯一一个构造函数，用于构造一个结点。参数包括了一个结点的所需的所有要素。\n55. public Iterator descendingIterator() 获取一个降序的迭代器，即从尾部向头部开始遍历。\n该方法创建一个DescendingIterator实例并返回。\n56. private class DescendingIterator implements Iterator 通过ListItr.previous提供降序迭代器的适配器。\n56.1 private final ListItr itr = new ListItr(size()); ListItr 实例，本类基于此实例对外提供服务。遍历的位置初始化为列表的尾部。\n56.2 public boolean hasNext() 判断是否还有下一个，因为此类提供的是反向的遍历。所以， hasNext 返回的是列表是否还有上一个元素。其源码如下：\npublic boolean hasNext() { // 遍历方向是从列表的尾部向头部，所以此处返回的是迭代器的hasPrevious() return itr.hasPrevious(); } 56.3 public E next() 获取下一个要遍历到的元素。此处也与上个方法相同， next 其实是列表的上一个元素。其源码如下：\npublic E next() { return itr.previous(); } 56.4 public void remove() 删除当前遍历到的结点。源码如下：\npublic void remove() { itr.remove(); } 57. private LinkedList superClone() 调用父类的 clone 方法，也即 Object.clone 方法，源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) private LinkedList\u0026lt;E\u0026gt; superClone() { try { // 调用父类的clone方法 return (LinkedList\u0026lt;E\u0026gt;) super.clone(); } catch (CloneNotSupportedException e) { // 如果捕获到不支持clone的异常，则包装成内部异常抛出 throw new InternalError(e); } } 58. public Object clone() 返回此LinkedList的浅复制副本。 （元素本身不会被克隆）\npublic Object clone() { LinkedList\u0026lt;E\u0026gt; clone = superClone(); // 将clone对象置为初始状态 // Put clone into \u0026#34;virgin\u0026#34; state clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // 为clone对象初始化元素 // Initialize clone with our elements for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) clone.add(x.item); return clone; } 59. public Object[] toArray() 以正确的顺序（从第一个元素到最后一个元素）返回一个包含此列表中所有元素的数组。\n返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，此方法必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n源码如下：\npublic Object[] toArray() { // 创建一个数组 Object[] result = new Object[size]; int i = 0; // 然后从头开始遍历列表，将每个元素放入数组 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) result[i++] = x.item; return result; } 60. public T[] toArray(T[] a) 该方法返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。\n如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接列表末尾的数组中的元素将设置为null。 （如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n源码如下：\npublic \u0026lt;T\u0026gt; T[] toArray(T[] a) { // 如果指定的数组a的长度小于当前列表的长度，则先对数组进行扩容，扩到size大小 if (a.length \u0026lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; Object[] result = a; // 从头开始遍历数组，将每个元素放到数组中 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) result[i++] = x.item; // 如果数组a的长度大于列表的size，则设置数组列表元素的后面位置为null if (a.length \u0026gt; size) a[size] = null; return a; } 61. private static final long serialVersionUID = 876323262645176354L; 序列化版本ID。\n62. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 将此LinkedList实例的状态保存到流中（即，对其进行序列化）。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // 将当前类的非静态和非瞬态字段写入此流 // Write out any hidden serialization magic s.defaultWriteObject(); // 写出size // Write out size s.writeInt(size); // 写出所有元素 // Write out all elements in the proper order. for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) s.writeObject(x.item); } 63. private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException 从流中重新构造此LinkedList实例（即，将其反序列化）。\n源码如下：\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // 从此流中读取所有非静态、非瞬态的属性 // Read in any hidden serialization magic s.defaultReadObject(); // 读取size // Read in size int size = s.readInt(); // 读取所有元素 // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) linkLast((E)s.readObject()); } 64. public Spliterator spliterator() 创建一个包含此列表所有元素的“后期绑定”和“快速失败”的 Spliterator 。\n该Spliterator报告SIZED和ORDERED。重写该实现时应记录其他特征值的报告。\nSpliterator还报告SUBSIZED并实现trySplit以允许有限的并行性。\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { return new LLSpliterator\u0026lt;E\u0026gt;(this, -1, 0); } 65. static final class LLSpliterator implements Spliterator LinkedList的拆分器实现，其 LL 即 LinkedList 的缩写。\n65.1 static final int BATCH_UNIT = 1 \u0026laquo; 10; 批处理数组大小的增量，默认为1024。\n65.2 static final int MAX_BATCH = 1 \u0026laquo; 25; 批次最大数组大小，默认为33554432。因为拆分的时候会将“被拆分出”结点的元素放入数组，然后再构建成拆分器返回，此字段即是此处用作限制该数组容量上限的。\n65.3 final LinkedList list; 该拆分器所持有的LinkedList，除非遍历，否则可为null。\n65.4 Node current; 当前结点，在初始化之前为null。\n65.5 int est; 估计的大小，在第一次需要之前为-1。\n65.6 int expectedModCount; 期望修改次数，设置 est 时初始化。\n65.6 int batch; 拆分的批次大小。\n65.7 LLSpliterator(LinkedList list, int est, int expectedModCount) 当前类唯一的构造方法。\nLLSpliterator(LinkedList\u0026lt;E\u0026gt; list, int est, int expectedModCount) { // 设定属性值 this.list = list; this.est = est; this.expectedModCount = expectedModCount; } 65.8 final int getEst() 获取列表预估的大小。主要用途包括确认是从头部开始遍历还是尾部开始遍历。\n源代码如下：\nfinal int getEst() { int s; // force initialization final LinkedList\u0026lt;E\u0026gt; lst; // 判断如果预估的大小大于0，则直接返回。因为est在第一次使用前为-1 if ((s = est) \u0026lt; 0) { if ((lst = list) == null) // 如果列表为空，则预估大小为0 s = est = 0; else { // 列表不为空 // 赋值期望修改次数为列表的修改次数 expectedModCount = lst.modCount; // 设置当前结点为列表的头结点 current = lst.first; // 设置预估大小为列表的大小 s = est = lst.size; } } return s; } 65.9 public long estimateSize() 获取预估大小，其实就是 getEst() 的 public 版本。不同之处还在于，当前方法会把返回结果强转为 long 类型。\n源码如下：\npublic long estimateSize() { return (long) getEst(); } 65.10 public Spliterator trySplit() 执行拆分。源码如下：\npublic Spliterator\u0026lt;E\u0026gt; trySplit() { Node\u0026lt;E\u0026gt; p; // 获取预估大小 int s = getEst(); // 预估大小大于1 且 当前结点不为空 才执行拆分，否则返回空 if (s \u0026gt; 1 \u0026amp;\u0026amp; (p = current) != null) { // n取当前批次数 + 批次增量、列表预估大小、最大批次数组大小 三者中最小的那个 int n = batch + BATCH_UNIT; if (n \u0026gt; s) n = s; if (n \u0026gt; MAX_BATCH) n = MAX_BATCH; // 声明一个对象数组，容量为前面计算出的n Object[] a = new Object[n]; int j = 0; // 从当前结点开始往后遍历，取出每个结点的元素放入数组，直至列表末尾或数组被塞满 do { a[j++] = p.item; } while ((p = p.next) != null \u0026amp;\u0026amp; j \u0026lt; n); // 将上面遍历到的最后一个结点设置为拆分器的当前结点 current = p; // 将上面遍历的结点个数设置为拆分器的批次大小 batch = j; // 设置拆分器的预估大小为上一次的预估大小减去本次拆分出的结点数 est = s - j; // 基于以上条件构造一个拆分器并返回 return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED); } return null; } 65.11 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对当前拆分器的剩余未遍历到的元素执行给定的操作。\n源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Node\u0026lt;E\u0026gt; p; int n; // 指定操作不可为空 if (action == null) throw new NullPointerException(); // 仅在拆分器的预估大小大于0 并且 当前结点不为空时执行 if ((n = getEst()) \u0026gt; 0 \u0026amp;\u0026amp; (p = current) != null) { // 将当前结点置为null，也就是遍历完成后的状态 current = null; // 将预估大小置为null，也就是遍历完成后的状态 est = 0; // 从当前结点开始遍历，直接拆分器持有的最后一个结点，对每个元素执行给定操作 do { E e = p.item; p = p.next; action.accept(e); } while (p != null \u0026amp;\u0026amp; --n \u0026gt; 0); } // 执行并发修改检查 if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); } 65.12 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 对当前拆分器的当前结点执行给定的操作。\n源码如下：\npublic boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { Node\u0026lt;E\u0026gt; p; // 给定操作不可为空 if (action == null) throw new NullPointerException(); // 预估大小大于0 并且 当前结点不为空才执行 if (getEst() \u0026gt; 0 \u0026amp;\u0026amp; (p = current) != null) { // 对预估大小执行减1操作 --est; // 取出当前结点所持有的元素 E e = p.item; // 设置当前结点为下一个结点 current = p.next; // 对元素执行给定的操作 action.accept(e); // 判断是否存在并发修改 if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); // 返回成功 return true; } return false; } 65.13 public int characteristics() 返回当前拆分器的特征值。源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } ","description":"1. transient int size = 0; 2. transient Node first; 3. transient Node last; 4. public LinkedList() 5. public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) 6. private void linkFirst(E e) 7. void linkLast(E e) 8. void linkBefore(E e, Node succ) 9. private E unlinkFirst(Node f) 10. private E unlinkLast(Node l) 11. E unlink(Node x) 12. public E getFirst() 13. public E getLast() 14. public E removeFirst() 15. public E removeLast() 16. public void addFirst(E e) 17."},{"id":21,"href":"/jdk8-src-note/java/util/Deque/","title":"Deque","parent":"util","content":" 1. void addFirst(E e) 2. void addLast(E e) 3. boolean offerFirst(E e) 4. boolean offerLast(E e) 5. E removeFirst() 6. E removeLast() 7. E pollFirst() 8. E pollLast() 9. E getFirst() 10. E getLast() 11. E peekFirst() 12. E peekLast() 13. boolean removeFirstOccurrence(Object o) 14. boolean removeLastOccurrence(Object o) 15. boolean add(E e) 16. boolean offer(E e) 17. E remove() 18. E poll() 19. E element() 20. E peek() 21. void push(E e) 22. E pop() 23. boolean remove(Object o) 24. boolean contains(Object o) 25. public int size() 26. Iterator\u0026lt;E\u0026gt; iterator() 27. Iterator\u0026lt;E\u0026gt; descendingIterator() 支持在两端插入和删除元素的线性集合。名称deque是“double ended queue”的缩写，通常发音为“ deck”。大多数Deque实现对它们可能包含的元素数量没有固定的限制，但是此接口支持容量受限的双端队列以及没有固定大小限制的双端队列。\n该接口定义了访问双端队列两端元素的方法。提供了用于插入，删除和检查元素的方法。这些方法均以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值（null或false，具体取决于操作）。后一种形式的插入操作是专为容量受限的Deque实现而设计的；在大多数实现中，插入操作不会失败。\n下表总结了上述十二种方法：\n抛出异常（头元素） 返回特殊值（头元素） 抛出异常（末尾元素） 返回特殊值（末尾元素） 插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e) 删除 removeFirst() pollFirst() removeLast() pollLast() 检索 getFirst() peekFirst() getLast() peekLast() 此接口扩展了Queue接口。当将双端队列当作队列使用时，将导致FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。如下表所示，从Queue接口继承的方法与Deque方法完全等效：\nQueue方法 等效的Deque方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 双端队列也可以用作LIFO（后进先出）堆栈。此接口应优先于旧式Stack类使用。当双端队列用作堆栈时，元素从双端队列的开头被压入以及弹出。堆栈方法完全等同于Deque方法，如下表所示：\nStack方法 等效的Deque方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() 注意，当双端队列用作队列或堆栈时，peek方法同样有效。无论哪种情况，元素都是从双端队列的开头开始绘制的。\n该接口提供了两种删除内部元素的方法：removeFirstOccurrence和removeLastOccurrence。\n与List接口不同，此接口不支持对元素的索引访问。\n虽然并非严格要求Deque实现禁止插入空元素，但强烈建议这样做。强烈建议所有使用允许null元素的Deque实现的用户不要插入null。之所以如此，是因为各种方法都将null用作特殊的返回值，以指示双端队列为空。\nDeque实现通常不定义基于元素的equals和hashCode方法，而是从类Object继承基于身份的版本。\n该接口也是Java集合框架的成员。\n1. void addFirst(E e) 如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此双端队列的前面，如果当前没有可用空间，则抛出IllegalStateException。使用有容量限制的双端队列时，通常最好使用方法offerFirst。\n2. void addLast(E e) 如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此双端队列的后面，如果当前没有可用空间，则抛出IllegalStateException。使用有容量限制的双端队列时，通常最好使用方法offerLast。\n此方法等效于add。\n3. boolean offerFirst(E e) 将指定的元素插入此双端队列的前面，除非该操作违反容量限制。使用容量受限的双端队列时，此方法通常比addFirst方法更可取，后者只能通过引发异常才能不插入元素。\n4. boolean offerLast(E e) 将指定的元素插入此双端队列的后面，除非该操作违反容量限制。使用容量受限的双端队列时，此方法通常比addLast方法更可取，后者只能通过引发异常才能不插入元素。\n5. E removeFirst() 检索并删除此双端队列的第一个元素。此方法与pollFirst的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n6. E removeLast() 检索并删除此双端队列的最后一个元素。此方法与pollLast的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n7. E pollFirst() 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null。\n8. E pollLast() 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null。\n9. E getFirst() 检索但不删除此双端队列的第一个元素。\n该方法与peekFirst的不同之处仅在于当双端队列为空时本方法将抛出异常。\n10. E getLast() 检索但不删除此双端队列的最后一个元素。\n该方法与peekLast的不同之处仅在于当双端队列为空时本方法将抛出异常。\n11. E peekFirst() 检索但不删除此双端队列的第一个元素，或者如果当前双端队列为空的话，则返回null。\n12. E peekLast() 检索但不删除此双端队列的最后一个元素，或者如果当前双端队列为空的话，则返回null。\n13. boolean removeFirstOccurrence(Object o) 从此双端队列中删除指定元素的第一次出现。如果双端队列不包含元素，则它保持不变。更准确地讲，删除第一个满足(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。\n如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用该方法而更改），则返回true。\n14. boolean removeLastOccurrence(Object o) 从此双端队列中删除指定元素的最后一次出现。如果双端队列不包含元素，则它保持不变。更准确地讲，删除最后一个满足(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。\n如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用该方法而更改），则返回true。\n15. boolean add(E e) 如果可能的话立即将指定的元素插入此双端队列所表示的队列中（换句话说，插入到此双端队列的末尾），而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出一个IllegalStateException。使用容量受限的双端队列时，通常最好使用offer。\n该方法等效于addLast。\n16. boolean offer(E e) 如果可能的话立即将指定的元素插入此双端队列所表示的队列中（换句话说，插入到此双端队列的末尾），而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则返回false。使用容量受限的双端队列时，该方法通常好于使用add，因为add方法在触发容量上限后是抛出异常。\n该方法等效于offerLast。\n17. E remove() 检索并删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n该方法等效于removeFirst()。\n18. E poll() 检索并删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素），如果此双端队列为空，则返回null。\n该方法等效于pollFirst()。\n19. E element() 检索但不删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n该方法等效于getFirst()。\n20. E peek() 检索但不删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素），如果此双端队列为空，则返回null。\n该方法等效于peekFirst()。\n21. void push(E e) 如果不违反容量限制则立即将元素压入此双端队列表示的堆栈（换句话说，此双端队列的开头），如果当前没有可用空间，则抛出IllegalStateException。\n该方法等效于addFirst。\n22. E pop() 从此双端队列所表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。\n该方法等效于removeFirst()。\n23. boolean remove(Object o) 从此双端队列删除指定元素的第一次出现。如果双端队列不包含此元素，则它保持不变。更正式地讲，删除第一个可以使得(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用而更改），则返回true。\n该方法等效于removeFirstOccurrence(Object)。\n24. boolean contains(Object o) 如果此双端队列包含指定的元素，则返回true。更正式地讲，当且仅当此双端队列至少包含一个元素e可以满足(o==null ? e==null : o.equals(e))时返回true。\n25. public int size() 返回此双端队列中的元素数。\n26. Iterator\u0026lt;E\u0026gt; iterator() 以适当的顺序返回此双端队列中的元素的迭代器。元素将按照从前（头）到后（尾）的顺序返回。\n27. Iterator\u0026lt;E\u0026gt; descendingIterator() 以相反的顺序返回此双端队列中的元素的迭代器。元素将按从最后（尾）到第一个（头）的顺序返回。\n","description":"1. void addFirst(E e) 2. void addLast(E e) 3. boolean offerFirst(E e) 4. boolean offerLast(E e) 5. E removeFirst() 6. E removeLast() 7. E pollFirst() 8. E pollLast() 9. E getFirst() 10. E getLast() 11. E peekFirst() 12. E peekLast() 13. boolean removeFirstOccurrence(Object o) 14. boolean removeLastOccurrence(Object o) 15. boolean add(E e) 16. boolean offer(E e) 17. E remove() 18. E poll() 19. E element() 20. E peek() 21. void push(E e) 22."},{"id":22,"href":"/jdk8-src-note/java/util/ArrayList/","title":"ArrayList","parent":"util","content":" 1. private static final long serialVersionUID = 8683452581122892189L; 2. private static final int DEFAULT_CAPACITY = 10; 3. private static final Object[] EMPTY_ELEMENTDATA = {}; 4. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 5. transient Object[] elementData; 6. private int size; 7. public ArrayList(int initialCapacity) 8. public ArrayList() 9. public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) 10. public void trimToSize() 11. public void ensureCapacity(int minCapacity) 12. private static int calculateCapacity(Object[] elementData, int minCapacity) 13. private void ensureCapacityInternal(int minCapacity) 14. private void ensureExplicitCapacity(int minCapacity) 15. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 16. private void grow(int minCapacity) 17. private static int hugeCapacity(int minCapacity) 18. public int size() 19. public boolean isEmpty() 20. public boolean contains(Object o) 21. public int indexOf(Object o) 22. public int lastIndexOf(Object o) 23. public Object clone() 24. public Object[] toArray() 25. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 26. E elementData(int index) 27. public E get(int index) 28. public E set(int index, E element) 29. public boolean add(E e) 30. public void add(int index, E element) 31. public E remove(int index) 32. public boolean remove(Object o) 33. private void fastRemove(int index) 34. public void clear() 35. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 36. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 37. protected void removeRange(int fromIndex, int toIndex) 38. private void rangeCheck(int index) 39. private void rangeCheckForAdd(int index) 40. private String outOfBoundsMsg(int index) 41. public boolean removeAll(Collection c) 42. public boolean retainAll(Collection c) 43. private boolean batchRemove(Collection c, boolean complement) 44. private void writeObject(java.io.ObjectOutputStream s) 45. private void readObject(java.io.ObjectInputStream s) 46. public ListIterator\u0026lt;E\u0026gt; listIterator(int index) 47. public ListIterator\u0026lt;E\u0026gt; listIterator() 48. public Iterator\u0026lt;E\u0026gt; iterator() 49. private class Itr implements Iterator\u0026lt;E\u0026gt; 49.1 int cursor; 49.2 int lastRet = -1; 49.3 int expectedModCount = modCount; 49.4 Itr() 49.5 public boolean hasNext() 49.6 public E next() 49.7 public void remove() 49.8 public void forEachRemaining(Consumer consumer) 49.9 final void checkForComodification() 50. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; 50.1 ListItr(int index) 50.2 public boolean hasPrevious() 50.3 public int nextIndex() 50.4 public int previousIndex() 50.5 public E previous() 50.6 public void set(E e) 50.7 public void add(E e) 51. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 52. static void subListRangeCheck(int fromIndex, int toIndex, int size) 53. private class SubList extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess 53.1 private final AbstractList\u0026lt;E\u0026gt; parent; 53.2 private final int parentOffset; 53.3 private final int offset; 53.4 int size; 53.5 SubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex) 53.6 public E set(int index, E e) 53.7 public E get(int index) 53.8 public int size() 53.9 public void add(int index, E e) 53.10 public E remove(int index) 53.11 protected void removeRange(int fromIndex, int toIndex) 53.12 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 53.13 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 53.14 public Iterator\u0026lt;E\u0026gt; iterator() 53.15 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 53.16 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 53.17 private void rangeCheck(int index) 53.18 private void rangeCheckForAdd(int index) 53.19 private String outOfBoundsMsg(int index) 53.20 private void checkForComodification() 53.21 public Spliterator\u0026lt;E\u0026gt; spliterator() 54. public void forEach(Consumer\u0026lt;? super E\u0026gt; action) 55. public Spliterator\u0026lt;E\u0026gt; spliterator() 56. static final class ArrayListSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt; 56.1 private final ArrayList\u0026lt;E\u0026gt; list; 56.2 private int index; 56.3 private int fence; 56.4 private int expectedModCount; 56.5 ArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount) 56.6 private int getFence() 56.7 public ArrayListSpliterator\u0026lt;E\u0026gt; trySplit() 56.8 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 56.9 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 56.10 public long estimateSize() 56.11 public int characteristics() 57. public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 58. public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 59. public void sort(Comparator\u0026lt;? super E\u0026gt; c) List接口的可变数组实现，实现了所有可选的列表操作，并允许存放所有元素，包括null。除了实现List接口之外，ArrayList类还提供一些方法来操作用于内部存储列表数组的大小。该类和Vector类大体类似，除了本类是非同步的。\nsize、isEmpty、get、set、iterator和listIterator操作均在恒定时间内运行。add操作执行需要均摊恒定时间，也即新增n个元素需要的时间为O(n)。所有其他操作都在线性时间内运行（粗略地说）。该实现与LinkedList实现相比，常量因子较低。\n每个ArrayList实例都有一个容量。容量是用于在列表中存储元素的数组的大小。它总是至少与列表大小一样大。将元素添加到ArrayList，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定扩充策略的详细信息。\n在添加大量元素之前，应用程序可以使用ensureCapacity操作先增加ArrayList实例的容量。这可以减少增量重新分配的数量。\n需要注意，本实现是非同步的，如果多个线程同时访问ArrayList实例，并且至少一个线程修改了列表结构，则它必须通过外部实现同步。（结构上的修改是指添加或删除一个或多个元素，或显式调整后备数组大小的任何操作；仅设置元素的值不是结构上的修改。）通常，是通过在自然封装列表的某个对象上进行同步来完成此操作。\n如果不存在这样的对象，则应使用Collections#synchronizedList方法“包装”列表。最好在创建列表时完成此操作，以防止意外不同步的访问列表：\nList list = Collections.synchronizedList(new ArrayList(...)); 此类的iterator()和listIterator(int)方法返回的迭代器采用的是“快速失败”机制：如果列表在迭代器创建后的任意时间、以任意方式进行了结构上的改动，除了通过迭代器自己的ListIterator#remove()或ListIterator#add(Object)方法外，迭代器都将抛出ConcurrentModificationException异常。因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间面临任意、不确定行为的风险。\n请注意，迭代器的“快速失败”行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。“快速失败”的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序以确保其正确性是错误的：迭代器的“快速失败”行为应仅用于检测bug。\n该类是Java集合框架的成员类。\n1. private static final long serialVersionUID = 8683452581122892189L; 序列化版本唯一ID。\n2. private static final int DEFAULT_CAPACITY = 10; 当前列表的默认初始容量。\n3. private static final Object[] EMPTY_ELEMENTDATA = {}; 用于空实例的共享空数组实例。\n4. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 共享的空数组实例，用于默认大小的空实例。将它与EMPTY_ELEMENTDATA区别开来，是为了了解添加第一个元素时要扩充多少。\n5. transient Object[] elementData; 数组缓冲区，ArrayList的元素便存储在其中。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何满足elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList的容量都将扩展为DEFAULT_CAPACITY。\n该属性的访问修饰符非私有，以简化嵌套类访问。\n6. private int size; ArrayList的大小（包含的元素数量）。\n7. public ArrayList(int initialCapacity) 构造一个具有指定初始容量的空列表。\n源码如下：\npublic ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 指定容量大于0，初始化一个指定容量的数组赋值给elementData this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 指定容量等于0，elementData直接取空数组 this.elementData = EMPTY_ELEMENTDATA; } else { // 指定容量小于0，抛出异常 throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } 8. public ArrayList() 构造一个初始容量为10的空列表。\n源码如下：\npublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 9. public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) 构造一个包含给定的集合中所有元素的列表，元素插入本列表时按照集合的迭代器返回元素的顺序。\n源码如下：\npublic ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // 先将指定集合转换为对象数组 Object[] a = c.toArray(); // 将数组长度赋值给列表的size，然后判断size是否为0 if ((size = a.length) != 0) { // 如果指定的集合不为空，然后判断该指定集合是否是ArrayList if (c.getClass() == ArrayList.class) { // 指定集合是ArrayList，直接把数组a赋值给当前集合的elementData数组 elementData = a; } else { // 指定集合不是ArrayList，需要将数组a复制给elementData数组 elementData = Arrays.copyOf(a, size, Object[].class); } } else { // 指定的集合为空，给elementData字段赋值一个空数组 // replace with empty array. elementData = EMPTY_ELEMENTDATA; } } 至于为什么不能把指定的集合c转为数组a之后，把这个数组a直接赋值给当前的ArrayList的elementData呢？\n这是由于此处存在Java的一个bug（6260652），也就是c.toArray可能返回的不是Object[]类型。如下测试用例所示：\n@Test public void testArrayListWithCollection() { // list1，类型是Arrays中自已实现的ArrayList，其内部用于存储列表元素的数组类型为：E[]，E为泛型 List\u0026lt;Integer\u0026gt; list1 = Arrays.asList(1, 2, 3); System.out.println(list1.toArray().getClass()); // list2，类型是java.util.ArrayList，即使声明这是一个Integer列表，但其用于存储列表元素的数组类型仍为：Object[] List\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); list2.add(1); System.out.println(list2.toArray().getClass()); // 使用参数为一个集合的构造器构造一个java.util.ArrayList实例，即使该集合的toArray()方法返回的并非Object[]类型，则该构造器也会对其进行转换 List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(list1); System.out.println(list3.toArray().getClass()); } 输出：\nclass [Ljava.lang.Integer; class [Ljava.lang.Object; class [Ljava.lang.Object; 10. public void trimToSize() 将该ArrayList实例的容量调整为列表当前的大小。应用程序可以使用此操作来最大程度地减少ArrayList实例的存储。\n源码如下：\npublic void trimToSize() { // 修改次数加1 modCount++; // 只有当前列表的元素个数小于数组长度时才执行此操作 if (size \u0026lt; elementData.length) { // 列表的元素个数为0，则置elementData数组为空数组 // 否则，执行数组复制，将数组中有元素的部分复制出来赋值给elementData数组 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } 11. public void ensureCapacity(int minCapacity) 确保本列表的容量至少可以容纳参数minCapacity指定的元素个数，如有必要的话会增加此ArrayList实例的容量。\n源码如下：\npublic void ensureCapacity(int minCapacity) { // 先计算一个最小扩充值 // 如果当前列表的elementData数组不是默认容量的空数组，则最小扩充值取0 // 否则最小扩充值默认容量，也即10 int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It\u0026#39;s already // supposed to be at default size. : DEFAULT_CAPACITY; // 如果指定的最小容量大于最小扩充值，则调用ensureExplicitCapacity方法进行精确扩容 if (minCapacity \u0026gt; minExpand) { ensureExplicitCapacity(minCapacity); } } 12. private static int calculateCapacity(Object[] elementData, int minCapacity) 计算最小容量值。\n源码如下：\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) { // 如果指定的元素数组是默认容量空数组，则返回默认容量空数组和指定最小容量这二者的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } // 如果指定的元素数组已非默认容量空数组，此时直接返回最小容量 return minCapacity; } 13. private void ensureCapacityInternal(int minCapacity) 内部使用的（私有的）容量确保方法。\n源码如下：\nprivate void ensureCapacityInternal(int minCapacity) { // 先调用计算容量方法获得最小容量值，再调用ensureExplicitCapacity明确扩容 ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } 14. private void ensureExplicitCapacity(int minCapacity) 明确的扩容方法，判断若指定的最小容量大于当前元素数组的容量，则对数组进行扩容。\n源码如下：\nprivate void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code // 指定的最小容量大于元素数组的长度才进行扩容 if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } 15. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 可分配的数组的最大大小。一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超出虚拟机限制。\n16. private void grow(int minCapacity) 增加容量以确保它至少可以容纳由最小容量参数指定的元素数量。\n源码如下：\nprivate void grow(int minCapacity) { // overflow-conscious code // 取出原容量 int oldCapacity = elementData.length; // 先计算一个新容量，基本上是扩容1.5倍（其实0.5并不准确，因为右移一位计算时没有小数，小数位全舍弃） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); // 扩容“1.5”倍后，判断是否能满足最小容量需求 if (newCapacity - minCapacity \u0026lt; 0) // 仍无法满足最小容量需求，则此时新容量直接取参数中指定的最小容量 newCapacity = minCapacity; // 判断新容量是否大于最大数组容量 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) // 新容量大于最大数组容量，此时调用hugeCapacity来获取新容量 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 对元素数组执行复制，复制后的数组容量为上面计算出的容量 elementData = Arrays.copyOf(elementData, newCapacity); } 17. private static int hugeCapacity(int minCapacity) 获取最大容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 如参数指定的最小容量 大于 最大数组容量，则新容量取Integer的最大值 // 否则取最大数组容量 return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 之前说MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，因为有的虚拟机中实现的数组可能会有头字，进而导致数组的最大容量无法达到Integer.MAX_VALUE，那如果按照本方法中的扩容策略，容量最大还是可以取到Integer.MAX_VALUE的，那岂不还是会出现未知的风险？\n所以，ArrayList的最大容量并非Integer.MAX_VALUE - 8，而是Integer.MAX_VALUE。\n18. public int size() 返回当前列表中元素的个数，即私有属性size。\n源码如下：\npublic int size() { return size; } 19. public boolean isEmpty() 判断当前ArrayList实例的元素数量（即size）是否为0。\n源码如下：\npublic boolean isEmpty() { return size == 0; } 20. public boolean contains(Object o) 判断当前列表是否包含参数中指定的元素。\n如果当前列表包含指定的元素，则返回true。更正式地说，当且仅当当前列表至少包含一个元素e可满足(o==null ? e==null : o.equals(e))时返回true。 源码如下：\npublic boolean contains(Object o) { // 先获取指定元素的索引，然后判断索引是否大于等于0，不大于等于0说明没找到 return indexOf(o) \u0026gt;= 0; } 21. public int indexOf(Object o) 返回参数中给定的元素在本列表中第一次出现的索引位置。如果给定的元素在本列表不存在，则返回-1。更准确的说，返回可满足(o==null ? get(i)==null : o.equals(get(i)))的最小索引i，如果该索引不存在的话，返回-1。\n源码如下：\npublic int indexOf(Object o) { // 根据指定元素是否为null采用不同的方式处理 // 均是从头开始遍历列表，命中了则返回当前索引 if (o == null) { for (int i = 0; i \u0026lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i \u0026lt; size; i++) if (o.equals(elementData[i])) return i; } // 未找到指定元素的索引，返回-1 return -1; } 22. public int lastIndexOf(Object o) 本方法与indexOf类似，不同之处在于，本方法是从后向前遍历，找到符合条件的最大索引。\n返回参数中给定的元素在本列表中最后一次出现的索引位置。如果给定的元素在本列表不存在，则返回-1。更准确的说，返回可满足(o==null ? get(i)==null : o.equals(get(i)))的最大索引i，如果该索引不存在的话，返回-1。\n源码如下：\npublic int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i \u0026gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i \u0026gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 23. public Object clone() 获取一个当前ArrayList实例的浅复制实例，即ArrayList实例是新的，但是其中的元素没有被复制，仍是原来的元素。\n源码如下：\npublic Object clone() { try { // 直接调用Object类的clone方法进行克隆 ArrayList\u0026lt;?\u0026gt; v = (ArrayList\u0026lt;?\u0026gt;) super.clone(); // 由于Object类的clone方法是浅复制，也即克隆出的新列表虽有新的内存地址，但新列表持有的对象数组仍是老List的对象数组，此时将数组再复制一份复制给新列表 v.elementData = Arrays.copyOf(elementData, size); // 将新列表的修改次数归0 v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn\u0026#39;t happen, since we are Cloneable throw new InternalError(e); } } 24. public Object[] toArray() 返回一个以正确的顺序（从第一个元素到最后一个元素）包含当前列表中所有元素的数组。 返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，此方法必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n源码如下：\npublic Object[] toArray() { return Arrays.copyOf(elementData, size); } 25. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；所返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。 如果列表适合指定的数组并有剩余空间（即数组中的元素多于列表），则紧接集合结束后的数组中的元素设置为null。（如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n源码如下：\npublic \u0026lt;T\u0026gt; T[] toArray(T[] a) { if (a.length \u0026lt; size) // 如果指定的数组a容量不足，则会将对象数组复制到新数组中，新数组的类型就是指定的数组a的类型 // Make a new array of a\u0026#39;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // a的容量足够，将对象数组复制到其中 System.arraycopy(elementData, 0, a, 0, size); // 如果对象数组a的长度大于当前列表元素个数，则最后一个元素后面的位置置为null if (a.length \u0026gt; size) a[size] = null; return a; } 26. E elementData(int index) 获取指定索引位置的元素。\n源码如下：\nE elementData(int index) { // 取出元素后会将其强转为当前列表持有元素的类型，因为对象数组elementData中存的都是Object对象 return (E) elementData[index]; } 27. public E get(int index) 返回此列表中指定位置的元素。\n源码如下：\npublic E get(int index) { // 首先对索引位置进行范围检查 rangeCheck(index); // 调用elementData方法取出指定位置的数据 return elementData(index); } 28. public E set(int index, E element) 用指定的元素element替换此列表中指定位置index的元素。\n源码如下：\npublic E set(int index, E element) { // 首先对索引进行范围检查 rangeCheck(index); // 调用elementData方法取出指定位置当前的元素 E oldValue = elementData(index); // 替换元素数组中指定位置的元素为参数中指定的元素 elementData[index] = element; // 返回旧值 return oldValue; } 29. public boolean add(E e) 将指定的元素追加到此列表的末尾，然后返回true。\n源码如下：\npublic boolean add(E e) { // 确保容量足够 ensureCapacityInternal(size + 1); // Increments modCount!! // 设置索引位置为size的元素为参数中指定的元素，然后再将size加1 elementData[size++] = e; return true; } 30. public void add(int index, E element) 将指定的元素element插入此列表中的指定位置index。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加1）。\n源码如下：\npublic void add(int index, E element) { // 首先对指定的索引index执行检查，看其是否符合新增的条件（大于0小于等于size） rangeCheckForAdd(index); // 确保容量足够 ensureCapacityInternal(size + 1); // Increments modCount!! // 将指定索引index之后的元素全部右移一位，即各索引加1 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将指定索引位置index处的元素替换为参数中指定的元素element elementData[index] = element; // 将列表元素个数加1 size++; } 31. public E remove(int index) 删除此列表中指定位置的元素。将所有后续元素向左移动（将其索引减1）。\n源码如下：\npublic E remove(int index) { // 对索引进行范围检查 rangeCheck(index); modCount++; // 取出指定索引位置当前的元素 E oldValue = elementData(index); // 计算出要移动的元素个数 int numMoved = size - index - 1; // 如果需移动的元素个数大于0，则将对象数组从index+1位置及之后的元素复制到index位置及之后 if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 先将size减1，然后将最后一个元素置为null，因为该位置的元素已被复制到它的前一位了 elementData[--size] = null; // clear to let GC do its work // 返回旧值 return oldValue; } 32. public boolean remove(Object o) 如果存在指定元素，则从该列表中删除第一次出现的该元素。如果列表不包含该元素，则该列表将不会改变。更准确地说，是删除满足(o==null ? get(i)==null : o.equals(get(i)))（如果存在这样的元素）的最小索引i对应的元素。如果此列表包含指定的元素，则返回true（或者等效地，如果由于本方法被调用而导致此列表有更改，则返回true）。\n源码如下：\npublic boolean remove(Object o) { // 根据指定的元素o是否为空走不同的逻辑 if (o == null) { // 遍历对象数组，逐个判断每个元素是否与指定元素相等，相等则调用fastRemove进行删除 for (int index = 0; index \u0026lt; size; index++) if (elementData[index] == null) { fastRemove(index); // 删除了数据，返回true return true; } } else { for (int index = 0; index \u0026lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } // 没有删除数据，返回false return false; } 33. private void fastRemove(int index) 私有的删除方法，跳过边界检查并且不返回移除的值。\n源码如下：\nprivate void fastRemove(int index) { modCount++; // 与根据索引删除元素的方法中类似，先计算出要移动索引的元素个数 int numMoved = size - index - 1; // 如果需要移动索引，则同样把index+1及后面的元素复制到从index及之后的位置 if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将size减1，然后将最后一个元素置空 elementData[--size] = null; // clear to let GC do its work } 34. public void clear() 从此列表中删除所有元素。该方法被调用后，该列表将为空。\n源码如下：\npublic void clear() { modCount++; // clear to let GC do its work // 遍历对象数组，将每个位置上的元素置为null for (int i = 0; i \u0026lt; size; i++) elementData[i] = null; // 将size置为0 size = 0; } 35. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 按照参数中指定集合的Iterator返回的顺序，将指定集合中的所有元素追加到此列表的末尾。 如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。（这意味着如果指定的集合就是本列表自身，并且本列表是非空的，则此调用的行为是不确定的。）\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 将指定集合转为数组 Object[] a = c.toArray(); int numNew = a.length; // 元素插入前的常规操作：确认容量足够 ensureCapacityInternal(size + numNew); // Increments modCount // 将指定集合转化成的数组a复制到本列表的对象数组中 System.arraycopy(a, 0, elementData, size, numNew); // 增加size size += numNew; // 若此方法实际插入了元素，则返回true，否则返回false return numNew != 0; } 36. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 从指定位置index开始，将指定集合c中的所有元素插入此列表。将当前位于该位置的元素（如果有的话）和任何后续元素向右移动（对它们的索引加一）。 新元素将按照指定集合的迭代器返回的顺序出现在列表中。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 检查指定索引是否合法（大于0小于等于size） rangeCheckForAdd(index); // addAll的常规操作，将指定集合转为数组，然后确保容量足够 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 先判断是否要移动索引，如果插入位置不是列表末尾的话，就需要移动 // 此举是为了腾出空来放置指定集合内的元素 int numMoved = size - index; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将指定集合转化成的数组a复制到本列表的对象数组中刚腾出来的位置 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } 37. protected void removeRange(int fromIndex, int toIndex) 删除当前列表中所有索引位置在fromIndex（包含）和toIndex（不包含）之间的元素。后面的元素都向左异动（减小其索引）。\n调用此方法会缩短列表(toIndex - fromIndex)个元素。如果toIndex==fromIndex，该操作将不会对列表造成影响。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { modCount++; // 计算要移动的元素个数，toIndex及之后位置的元素都需要移动 int numMoved = size - toIndex; // 将toIndex及之后的元素复制到fromIndex及之后的位置 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work // 拿到列表的新大小 int newSize = size - (toIndex-fromIndex); // 将索引位置在新大小之后的元素均置为null for (int i = newSize; i \u0026lt; size; i++) { elementData[i] = null; } size = newSize; } 38. private void rangeCheck(int index) 检查给定的索引是否在范围内。如果不是，则抛出适当的运行时异常。此方法不检查索引是否为负数：它始终在数组访问之前立即使用，如果索引为负数，则抛出 ArrayIndexOutOfBoundsException。\n源码如下：\nprivate void rangeCheck(int index) { if (index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 39. private void rangeCheckForAdd(int index) add和addAll使用的rangeCheck版本。\n源码如下：\nprivate void rangeCheckForAdd(int index) { // 该校验允许index等于size，因为在插入元素时，可以往size这个索引位置插入 if (index \u0026gt; size || index \u0026lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 40. private String outOfBoundsMsg(int index) 构造一个IndexOutOfBoundsException详细消息。在错误处理代码的许多可能重构中，这种“概述”在服务器和客户端VM上表现最佳。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size; } 41. public boolean removeAll(Collection c) 从此列表中移除指定集合中包含的所有元素。\n源码如下：\npublic boolean removeAll(Collection\u0026lt;?\u0026gt; c) { // 指定集合c不可为空 Objects.requireNonNull(c); // 调用batchRemove方法删除元素 return batchRemove(c, false); } 42. public boolean retainAll(Collection c) 仅保留此列表中指定集合中包含的元素。换句话说，从该列表中删除所有未包含在指定集合中的元素。\n源码如下：\npublic boolean retainAll(Collection\u0026lt;?\u0026gt; c) { // 指定集合c必须非空 Objects.requireNonNull(c); // 调用batchRemove方法，此处与removeAll方法内不同，此处传的第二个参数为true return batchRemove(c, true); } 43. private boolean batchRemove(Collection c, boolean complement) 批量删除的方法，参数complement为补集的意思。也就是，当complement为true时，批量删除掉的是补集（即当前列表在指定集合c中的补集），否则批量删除掉的就是集合c。\n源码如下：\nprivate boolean batchRemove(Collection\u0026lt;?\u0026gt; c, boolean complement) { final Object[] elementData = this.elementData; // r：遍历当前集合时遍历到的索引位置；w：“新”对象数组的size int r = 0, w = 0; boolean modified = false; try { // 遍历当前集合 for (; r \u0026lt; size; r++) // 先求出指定的集合c中是否包含当前迭代到的元素，再根据是否是删除补集来判断出是否要保留当前元素 if (c.contains(elementData[r]) == complement) // 将当前元素从新排入对象数组 elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // 此处，如果r和size不相等，说明在遍历当前集合的过程中抛出了异常，未能遍历完 if (r != size) { // 此时将遍历停止的位置及之后的元素拼接到对象数组的w位置之后 System.arraycopy(elementData, r, elementData, w, size - r); // “新”对象数组的size加上后面那些没遍历到的元素个数，这就是调用完此方法后当前列表的元素个数了 w += size - r; } // 如果“新”对象数组的元素个数与当前列表的元素个数不相等，说明有元素被删除了 if (w != size) { // clear to let GC do its work // 遍历对象数组从“新”数组大小之后的元素，对其逐个置为null for (int i = w; i \u0026lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; } 上述所提到的“新”对象数组，其实数组还是当前列表的对象数组，只不过该方法在删除元素时采用的不是“删除”操作，而是采用的“保留”操作，未被保留的元素相当于被删除了。如果方法判定该元素需保留，则会将它放到对象数组的合适位置，该合适位置是从0开始往后排的，这些位置存放的都是要被保留的元素，这也就是所谓的“新”对象数组。\n44. private void writeObject(java.io.ObjectOutputStream s) 将ArrayList实例的状态保存到流中（即序列化它）。该列表的对象数组的长度以及其存放的元素（会以正确的顺序）都会被序列化。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff // 写出元素数量和任何隐藏的内容 int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() // 写出大小作为与 clone() 的行为兼容性的容量 s.writeInt(size); // Write out all elements in the proper order. // 以合适的顺序写出所有的元素 for (int i=0; i\u0026lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 45. private void readObject(java.io.ObjectInputStream s) 从流中重新构造ArrayList实例（即反序列化它）。\n源码如下：\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff // 读取数量和任意隐藏的内容 s.defaultReadObject(); // Read in capacity // 读取容量 s.readInt(); // ignored // 如果容量大于0才读取元素 if (size \u0026gt; 0) { // be like clone(), allocate array based upon size not capacity // 就像 clone()，根据大小而不是容量分配数组 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. // 以合适的顺序读取所有元素 for (int i=0; i\u0026lt;size; i++) { a[i] = s.readObject(); } } } 46. public ListIterator\u0026lt;E\u0026gt; listIterator(int index) 从列表中的指定位置开始，返回此列表列表迭代器（元素以适当的顺序返回）。指定的索引表示初始调用ListIterator.next将返回的第一个元素。初次调用ListIterator#previous将返回具有指定索引减一的元素。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 对指定索引index进行校验 if (index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;Index: \u0026#34;+index); // 返回一个新ListItr实例 return new ListItr(index); } 如下为一些单元测试：\n@Test public void testListIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); // 指定索引获取的迭代器，调用next方法会获得该索引位置的元素 System.out.println(list.listIterator(2).previous()); System.out.println(list.listIterator(2).next()); // 不指定索引，等同于指定的索引为0，也即从头开始 System.out.println(list.listIterator().hasPrevious()); System.out.println(list.listIterator().next()); } 输出：\n2 3 false 1 47. public ListIterator\u0026lt;E\u0026gt; listIterator() 返回此列表中的元素的列表迭代器（按适当顺序）。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator() { return new ListItr(0); } 48. public Iterator\u0026lt;E\u0026gt; iterator() 返回一个以正确的顺序包含此列表中元素的迭代器。 源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } 49. private class Itr implements Iterator\u0026lt;E\u0026gt; 优化版本的AbstractList.Itr，实现了Iterator接口。\n49.1 int cursor; cursor意为游标，其用于标识当前迭代器已经执行到哪个元素位置了。所以，它代表的是下一个要返回的元素的index。\n49.2 int lastRet = -1; 该属性代表的是上一个返回的元素的index。当迭代器还没开始遍历的时候，其为-1。\n49.3 int expectedModCount = modCount; 期望操作数，用于并发修改检查。\n49.4 Itr() 无参构造器。\nItr() {} 49.5 public boolean hasNext() 用于判断当前迭代器是否还有其他元素。\n源码如下：\npublic boolean hasNext() { return cursor != size; } 49.6 public E next() 用于获取迭代器的下一个元素。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { checkForComodification(); // 记录下来当前游标位置 int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 游标后移一位 cursor = i + 1; // 将之前记录下的游标位置i赋值给最近一次返回的索引，然后取出该位置的元素并返回 return (E) elementData[lastRet = i]; } 49.7 public void remove() 删除当前元素。\n源码如下：\npublic void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用ArrayList的remove方法删除元素 ArrayList.this.remove(lastRet); // 将上次返回的元素索引赋值给游标 cursor = lastRet; // 将最近返回的元素索引置为-1 lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 49.8 public void forEachRemaining(Consumer consumer) 对迭代器尚未遍历到的元素执行给定的操作。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; // 记录下当前游标位置 int i = cursor; // 如果当前游标位置大于等于列表元素个数，说明已无未遍历到的元素了，直接返回即可 if (i \u0026gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 从当前游标位置一直到列表末尾，对每个元素执行给定的操作 while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic // 在迭代结束时更新一次游标和lastRet，以减少堆写入流量 cursor = i; lastRet = i - 1; checkForComodification(); } 49.9 final void checkForComodification() 判断是否存在并发修改操作，若存在则抛出并发修改异常。\n源码如下：\nfinal void checkForComodification() { // 修改次数与期望修改次数不等，说明存在并发修改异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 50. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; 优化版本的AbstractList.ListItr，继承了Itr类并实现了ListIterator接口。\n50.1 ListItr(int index) 列表迭代器的构造方法，源码如下：\nListItr(int index) { super(); // 设置游标位置为指定索引 cursor = index; } 50.2 public boolean hasPrevious() 判断当前迭代器是否还有上一个元素，判断依据是当前游标cursor是否不等于0，不等于0，说明还有上一个元素，为0说明已到列表的开始位置，没有上一个元素了。\n源码如下：\npublic boolean hasPrevious() { return cursor != 0; } 50.3 public int nextIndex() 返回下一个元素的索引，其实就是返回当前游标cursor。\n源码如下：\npublic int nextIndex() { return cursor; } 50.4 public int previousIndex() 返回上一个元素的索引，其实就是返回当前游标cursor - 1。\n源码如下：\npublic int previousIndex() { return cursor - 1; } 50.5 public E previous() 返回上一个元素（非上一个返回的元素）。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E previous() { // 进行并发修改检查 checkForComodification(); // 取出上一个元素的索引位置 int i = cursor - 1; // 对得到的索引位置进行范围检查 if (i \u0026lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 将当前游标左移一位 cursor = i; // 将最后返回的索引置为之前算出的索引，然后返回该索引位置的元素 return (E) elementData[lastRet = i]; } 50.6 public void set(E e) 将迭代器最后返回的元素替换为指定的元素e。\n源码如下：\npublic void set(E e) { // lastRet小于0说明没有最近返回的元素或者最近返回的元素已被删除 if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.set(lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 50.7 public void add(E e) 在当前游标位置插入指定的元素e。\n源码如下：\npublic void add(E e) { checkForComodification(); try { int i = cursor; // 在游标位置插入元素e ArrayList.this.add(i, e); // 游标右移一位 cursor = i + 1; // 最近返回的索引置为-1，这个需要特别注意，此处并非置为新插入元素的索引位置 lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 51. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 返回当前列表在指定的fromIndex（包含）和toIndex（不包含）之间部分的视图。（如果fromIndex和toIndex相等，则返回的列表为空）返回的列表基于本列表，因此返回列表中的非结构性更改将反映会影响本列表，反之亦然。返回的列表支持列表的所有可选操作。 这种方法消除了显式范围操作（数组中常见的那种操作）的需要。任何期望获得列表的操作都可以用范围操作来代替，通过传递子列表视图而不是整个列表来实现。例如，下面的习惯用法从列表中删除一个元素范围：\nlist.subList(from, to).clear(); indexOf(Object)和lastIndexOf(Object)可以构造类似的习惯用法，并且Collections类中的所有算法都可以应用于子列表。 如果后备列表（即此列表）以除通过返回列表以外的任何其他方式进行结构化修改，则此方法返回的列表的操作将变得不确定。 （结构修改是指更改此列表的大小的结构修改，或以其他方式扰乱此列表的方式，使得正在进行的迭代可能会产生错误的结果。）\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } 示例：\n@Test public void testSubList() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); List\u0026lt;Integer\u0026gt; subList = list.subList(1, 3); System.out.println(list); System.out.println(subList); System.out.println(subList.getClass()); } 输出：\n[1, 2, 3, 4, 5] [2, 3] class java.util.ArrayList$SubList 52. static void subListRangeCheck(int fromIndex, int toIndex, int size) 对子列表的范围进行检查。\n源码如下：\nstatic void subListRangeCheck(int fromIndex, int toIndex, int size) { if (fromIndex \u0026lt; 0) throw new IndexOutOfBoundsException(\u0026#34;fromIndex = \u0026#34; + fromIndex); if (toIndex \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;toIndex = \u0026#34; + toIndex); if (fromIndex \u0026gt; toIndex) throw new IllegalArgumentException(\u0026#34;fromIndex(\u0026#34; + fromIndex + \u0026#34;) \u0026gt; toIndex(\u0026#34; + toIndex + \u0026#34;)\u0026#34;); } 53. private class SubList extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess “子”列表类，更准确地说，其实它是当前ArrayList的一个视图。\n它提供AbstractList可以提供的一切操作，但是它底层并非是像ArrayList一样通过elementData对象数组来存储数据，而是持有它父列表的引用，并且维护一个相对于其父列表的索引偏移量parentOffset，以及一个相对于其最顶层列表（非SubList类的实例，而是ArrayList类的实例）的偏移量offset。\n假设子列表中的某元素在子列表中的索引为subIndex，则该元素在父列表中的索引为：subIndex + parentOffset，在其最顶层的ArrayList中的索引为：subIndex + offset。\n53.1 private final AbstractList\u0026lt;E\u0026gt; parent; 当前子列表的父列表。\n53.2 private final int parentOffset; 当前子列表的父列表在其父列表中的偏移量。\n53.3 private final int offset; 当前子列表在其最顶层的ArrayList列表中的偏移量。\n假设存在ArrayList的实例A：[\u0026quot;零\u0026quot;, \u0026quot;一\u0026quot;, \u0026quot;二\u0026quot;, \u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;, \u0026quot;五\u0026quot;]，\n存在A的子列表SubList的实例S1：[\u0026quot;二\u0026quot;, \u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;]，”二“这个元素在该S1中的索引为0，在其父列表A中的索引为2，此时S1的parentOffset为2，同时S1的offset也为2。\n再假设S1也存在子列表SubList的实例S2：[\u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;]，”四“这个元素在S2中的索引为1，在其父列表S1中的索引为2，在其最顶层的ArrayList列表A中的索引为4，此时S2的parentOffset为1（2 - 1），offset为3（4 - 1）。\n53.4 int size; 当前子列表的大小。\n53.5 SubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex) SubList类唯一的构造函数。\n源码如下：\nSubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex) { // 执行各种初始化 this.parent = parent; // 将fromIndex置为当前子列表相对于其父列表的偏移量 this.parentOffset = fromIndex; // 将当前子列表相对于其最顶级列表的偏移量加上当前子列表相对于其父列表的偏移量 this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; } 53.6 public E set(int index, E e) 设置当前子列表指定索引位置的元素为指定的元素e。\n源码如下：\npublic E set(int index, E e) { // 首先对指定索引index进行检查 rangeCheck(index); // 检查是否存在并发修改 checkForComodification(); // 首先计算出当前子列表中的index位置转换为其父列表的index（即当前指定索引加上偏移量） // 调用父类的elementData方法取出对应位置的元素 E oldValue = ArrayList.this.elementData(offset + index); // 将父类对应位置的元素替换为指定的元素e ArrayList.this.elementData[offset + index] = e; // 返回旧元素 return oldValue; } 53.7 public E get(int index) 获取指定索引位置的元素。\n源码如下：\npublic E get(int index) { // 首先进行范围检查 rangeCheck(index); // 进行并发修改检查 checkForComodification(); // 通过指定索引index和偏移量计算出目标元素在父列表中的位置，然后从父列表中将其取出并返回 return ArrayList.this.elementData(offset + index); } 53.8 public int size() 获取当前子列表的大小。\n源码如下：\npublic int size() { // 并发修改检查 checkForComodification(); // 返回当前子列表大小 return this.size; } 53.9 public void add(int index, E e) 向指定索引位置插入指定元素。\n源码如下：\npublic void add(int index, E e) { // 校验指定索引是否满足新增的要求 rangeCheckForAdd(index); // 并发修改校验 checkForComodification(); // 此处是调用的父类的add方法，而非最顶层的ArrayList的add方法 // 所以计算索引时，要使用parentOffset，而非offset parent.add(parentOffset + index, e); this.modCount = parent.modCount; // 列表大小加1 this.size++; } 53.10 public E remove(int index) 删除指定索引位置的元素，并将该元素返回。\n源码如下：\npublic E remove(int index) { rangeCheck(index); checkForComodification(); // 与add一样，删除也是调用父类的方法，所以计算索引时要使用parentOffset E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; } 53.11 protected void removeRange(int fromIndex, int toIndex) 删除索引在指定返回范围fromIndex（包含）和toIndex（不包含）之间的元素。\nprotected void removeRange(int fromIndex, int toIndex) { checkForComodification(); // 也是调用父类的范围删除方法来执行删除，所以使用parentOffset计算索引 parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; } 53.12 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定集合内的元素添加到当前子列表的末尾。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 调用addAll方法，指定插入位置的索引为当前列表的size大小处，也即紧接着列表的末尾后面 return addAll(this.size, c); } 53.13 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 将指定集合内的元素添加到当前子列表的指定索引处。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { rangeCheckForAdd(index); int cSize = c.size(); // 指定的列表没有元素，直接返回false if (cSize==0) return false; checkForComodification(); // 调用父类的插入方法 parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; } 53.14 public Iterator\u0026lt;E\u0026gt; iterator() 获取迭代器。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 调用AbstractList中的listIterator()方法获取迭代器 return listIterator(); } 53.15 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 获取从指定位置开始的迭代器。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { checkForComodification(); // 此处借用了插入元素时的索引校验方法，即允许指定的索引为列表的size rangeCheckForAdd(index); final int offset = this.offset; // 此处返回一个ListIterator接口的匿名内部类的实例 return new ListIterator\u0026lt;E\u0026gt;() { // 游标等于指定索引 int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; // 判断是否还有下一个元素 public boolean hasNext() { // 判断当前游标是否等于当前子列表的大小 return cursor != SubList.this.size; } // 获取下一个元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 计算元素在顶层的ArrayList列表内的索引，若大于等于数组长度，则报错 if (offset + i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 游标右移一位 cursor = i + 1; // 将原游标位置赋值给最近返回的元素索引 // 计算出要取出的元素在其顶层的ArrayList中的索引位置 // 通过顶层列表的对象数组elementData获取对应索引位置的元素 return (E) elementData[offset + (lastRet = i)]; } // 判断前面是否还有元素 public boolean hasPrevious() { // 判断当前游标是否为0 return cursor != 0; } // 获取前面一个元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E previous() { checkForComodification(); // 计算出前一个元素在当前子列表中的索引位置 int i = cursor - 1; if (i \u0026lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 计算出前一个元素在顶层的ArrayList中的索引位置，并校验 if (offset + i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 这一步相当于是游标前移一位 cursor = i; // 将最近返回的索引位置置为前一个元素，并返回该元素 return (E) elementData[offset + (lastRet = i)]; } // 对剩下未遍历到的元素执行给定的操作 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; consumer) { Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; // 游标已在子列表末尾或之后，则说明已无未迭代到的元素，直接返回 if (i \u0026gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; // 计算出当前游标在顶层ArrayList中的索引位置，并校验 if (offset + i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 从游标位置开始往后遍历，直到当前子列表的末尾，对每个元素执行给定的操作 while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { consumer.accept((E) elementData[offset + (i++)]); } // update once at end of iteration to reduce heap write traffic // 最近返回索引和当前游标均一次性更新至子列表末尾 lastRet = cursor = i; checkForComodification(); } // 获取下一个元素索引 public int nextIndex() { // 返回当前游标 return cursor; } // 获取上一个元素索引 public int previousIndex() { // 返回当前游标之前的位置 return cursor - 1; } // 删除迭代器当前迭代到的元素 public void remove() { // 最近返回元素小于0，将抛出异常 if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用子列表的remove方法删除对应元素 SubList.this.remove(lastRet); // 将游标置于最近返回的元素索引位置，相当于左移一位 cursor = lastRet; // 将最近返回的索引位置置为-1 lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 替换最近返回的索引位置的元素为指定的元素 public void set(E e) { // 最近返回的索引位置不可小于0，否则可能是迭代器还未获取过元素，或者已经进行了元素的增加（add）或删除（remove） if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 计算出元素在顶层ArrayList中的索引位置，用ArrayList的set方法替换元素 ArrayList.this.set(offset + lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 在当前游标位置插入指定元素 public void add(E e) { checkForComodification(); try { int i = cursor; // 调用子列表的add方法，在当前游标位置插入指定元素 SubList.this.add(i, e); // 将游标右移一位 cursor = i + 1; // 将最近返回的索引置为-1 lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 检查是否存在并发修改 final void checkForComodification() { // 如果子列表的期望修改次数不等于ArrayList修改次数，说明存在并发修改 if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); } }; } 53.16 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 获取当前SubList实例的子列表。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); // 看，此处传入的offset为当前子列表的offset，而非ArrayList的subList方法中传入的0 return new SubList(this, offset, fromIndex, toIndex); } 53.17 private void rangeCheck(int index) 对指定索引进行合法性检查。\n源码如下：\nprivate void rangeCheck(int index) { // 指定的索引必须大于0且小于size，否则将造成数据越界 if (index \u0026lt; 0 || index \u0026gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 53.18 private void rangeCheckForAdd(int index) 在列表插入元素时，对插入位置进行校验。\n源码如下：\nprivate void rangeCheckForAdd(int index) { // 相较于rangeCheck，本校验方法允许指定索引等于size，因为可以往size位置插入元素 if (index \u0026lt; 0 || index \u0026gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 53.19 private String outOfBoundsMsg(int index) 获取数组越界异常的提示信息。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+this.size; } 53.20 private void checkForComodification() 检查列表是否存在并发修改。\n源码如下：\nprivate void checkForComodification() { // 判断ArrayList的修改次数与当前子列表的修改次数是否一致，否则抛出并发修改异常 if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); } 53.21 public Spliterator\u0026lt;E\u0026gt; spliterator() 获取当前子列表的拆分器。\n源码如下：\npublic Spliterator\u0026lt;E\u0026gt; spliterator() { checkForComodification(); // 注意，此处传入的是ArrayList，而非当前子列表 return new ArrayListSpliterator\u0026lt;E\u0026gt;(ArrayList.this, offset, offset + this.size, this.modCount); } 54. public void forEach(Consumer\u0026lt;? super E\u0026gt; action) 遍历当前列表，对每个元素执行给定的操作，直到每个元素都被迭代到或者中间出了异常。\n源码如下：\n@Override public void forEach(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前列表的对象数组，待会就遍历它 final E[] elementData = (E[]) this.elementData; final int size = this.size; // 遍历时每次循环都校验是否存在并发修改，存在则直接结束遍历 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { action.accept(elementData[i]); } // 若存在并发修改，直接抛出异常 if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 55. public Spliterator\u0026lt;E\u0026gt; spliterator() 在此列表中的元素上创建一个“后期绑定”和“快速失败”的Spliterator。Spliterator报告Spliterator#SIZED、Spliterator#SUBSIZED和Spliterator#ORDERED。覆盖本实现应该记录其他特征值的描述。\n源码如下：\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { return new ArrayListSpliterator\u0026lt;\u0026gt;(this, 0, -1, 0); } 56. static final class ArrayListSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt; 基于索引一分为二、延迟初始化的Spliterator。\n如果ArrayList是不可变的或结构上不可变的（没有添加，删除等），我们可以使用Arrays.spliterator实现它们的分隔器。相反，我们在不牺牲太多性能的情况下，在遍历过程中检测到尽可能多的干扰。我们主要依靠modCounts，这不能保证检测到并发冲突，并且有时对线程内干扰过于保守，但是可以检测到足够的问题，值得在实践中使用。为了实现这一点：\n我们延迟初始化fence和expectedModCount，直到需要提交给正在检查状态的最新点，从而提高精度。 （这不适用于SubList，因为SubList会创建带有当前非惰性值的Spliterator）。 我们仅在 forEach（对性能最敏感的方法）结束时执行一次 ConcurrentModificationException 检查。当使用forEach（而不是迭代器）时，我们通常只能在动作之后检测干扰，而不是之前。进一步的 CME 触发检查适用于所有其他可能不符合预期的情况，例如 null 或给定 size() 的太小的 elementData 数组，这可能仅由于干扰而发生。这允许 forEach 的内部循环在没有任何进一步检查的情况下运行，并简化了 lambda 解析。虽然这确实需要一些检查，但请注意，在 list.stream().forEach(a) 的常见情况下，除了 forEach 本身之外，不会在任何地方进行检查或其他计算。其他不太常用的方法无法利用这些精简中的大部分。 56.1 private final ArrayList\u0026lt;E\u0026gt; list; 该拆分器所属的list。\n56.2 private int index; 当前索引，在前进（advance）或拆分（split）时修改。\n56.3 private int fence; 直到使用前都是-1，然后直到最后一个索引。\n56.4 private int expectedModCount; 期望修改次数，设置fence时初始化。\n56.5 ArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount) 创建覆盖给定范围的新拆分器。\n源码如下：\nArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount) { // 参数中的list可以为空，除非要遍历它 this.list = list; // OK if null unless traversed // 属性值初始化 this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; } 56.6 private int getFence() 第一次使用时，初始化围栏fence大小。\n源码如下：\nprivate int getFence() { // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList\u0026lt;E\u0026gt; lst; // 将fence大于等于0，直接返回该值 if ((hi = fence) \u0026lt; 0) { // 如果list为空，则fence初始化为0，并最终返回0 if ((lst = list) == null) hi = fence = 0; else { // 如果list不为空 // 初始化拆分器的期望修改次数 expectedModCount = lst.modCount; // 将fence初始化为列表的大小 hi = fence = lst.size; } } return hi; } 56.7 public ArrayListSpliterator\u0026lt;E\u0026gt; trySplit() 执行拆分。\n源码如下：\npublic ArrayListSpliterator\u0026lt;E\u0026gt; trySplit() { // hi = getFence()，这一步是获取围栏位置 // lo = index，这一步是获取当前索引 // mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1，这一步很关键，求取当前迭代到的位置直到围栏位置的中间索引位置，将用于拆分出新拆分器 int hi = getFence(), lo = index, mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1; // 除非太小，否则将范围分成两半 return (lo \u0026gt;= mid) ? null : // divide range in half unless too small // 拆分出去的新拆分器，是从当前迭代到的位置至上面求出的中间位置 // 此处还有一个不明显但很关键的操作：index = mid，这一步是将当前老拆分器的迭代位置置为上面求出的中间位置 // 这样老拆分器就一分为二了，新拆分器负责前半部分，老拆分器负责后半部分 new ArrayListSpliterator\u0026lt;E\u0026gt;(list, lo, index = mid, expectedModCount); } 例如：\n存在一个ArrayList，其size为35，然后其调用spliterator()获取到一个拆分器，此时该拆分器的fence为-1，index为0。\n若此时对该拆分器执行拆分（trySplit()）操作： 首先调用getFence()获取围栏大小，此方法中会对fence做初始化，最终拿到的fence是35，在加上当前索引为0，则计算出的中间值为17（(35 + 0) \u0026gt;\u0026gt;\u0026gt; 1 = 17）。 当前索引为0，小于中间值，此时可以进行拆分，此时方法返回的新拆分器实例的属性分别为：index为0，fence为17。同时，原拆分器的index更新为17。 此时就相当于一个持有35个元素的拆分器，拆分出去了一个持有17个元素的拆分器，自己还剩18个元素。（所谓“持有”，其实这两个拆分器都是持有该拆分器所属的list，但通过围栏字段fence区分出每个拆分器所负责的那一部分）\n如图所示：\n56.8 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 对当前拆分器迭代到的元素执行给定的操作action。\n源码如下：\npublic boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { if (action == null) throw new NullPointerException(); // 获取围栏位置以及当前索引 int hi = getFence(), i = index; // 如果当前索引大于等于围栏位置，说明所有元素均已遍历完，此时没有元素执行给定的操作 if (i \u0026lt; hi) { // 将索引右移一位 index = i + 1; // 取出右移前索引位置的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E)list.elementData[i]; // 对取出的元素执行给定的操作 action.accept(e); // 校验是否存在并发修改 if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } 56.9 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对当前拆分器剩余未迭代到的元素执行给定的操作action。所谓剩余是指：从当前索引位置到围栏位置之间的元素。\n源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { int i, hi, mc; // hoist accesses and checks from loop ArrayList\u0026lt;E\u0026gt; lst; Object[] a; if (action == null) throw new NullPointerException(); // 列表必须不能为空，否则抛出并发修改异常 if ((lst = list) != null \u0026amp;\u0026amp; (a = lst.elementData) != null) { // 如果围栏位置小于0，可能是刚基于列表创建的拆分器 if ((hi = fence) \u0026lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; // 如果当前索引位置大于等于0 且 围栏位置小于等于列表中对象数组的长度，则迭代数组 // 此处的隐秘操作：index = hi，这一步将拆分器的当前索引推至围栏位置了 if ((i = index) \u0026gt;= 0 \u0026amp;\u0026amp; (index = hi) \u0026lt;= a.length) { for (; i \u0026lt; hi; ++i) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) a[i]; action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); } 56.10 public long estimateSize() 获取当前拆分器还未进行操作的元素数量。\n源码如下：\npublic long estimateSize() { // 所有获取围栏位置，然后减去当前索引 return (long) (getFence() - index); } 56.11 public int characteristics() 该方法是返回当前拆分器的特征值，就ArrayListSpliterator而言，其特征值有：Spliterator.ORDERED、Spliterator.SIZED、Spliterator.SUBSIZED。\n源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } 57. public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 参数为一个断言，该方法即对当前列表的每个元素执行该断言的test方法，命中的则在当前列表中删除，最后返回的是是否删除了本列表的元素。\n源码如下：\n@Override public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified // 找出要删除哪些元素，在此阶段从断言中抛出的任何异常都不会使集合改变 int removeCount = 0; // 声明一个BitSet，用于存储要删除元素的索引 final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; // 从头开始遍历列表，先找出符合删除条件的元素索引 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前迭代到的元素 final E element = (E) elementData[i]; // 对取出的元素执行给定的测试 if (filter.test(element)) { // 若满足条件，将该索引记录到removeSet，并将删除数量加1 removeSet.set(i); removeCount++; } } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } // shift surviving elements left over the spaces left by removed elements // 将剩下的元素移动到已删除元素留下的空间上 final boolean anyToRemove = removeCount \u0026gt; 0; // 上面找到了要删除的元素才执行下面的操作 if (anyToRemove) { // 计算出新的列表大小 final int newSize = size - removeCount; // 遍历列表，直到新的列表大小位置处 for (int i=0, j=0; (i \u0026lt; size) \u0026amp;\u0026amp; (j \u0026lt; newSize); i++, j++) { // 找到下一个未删除的元素索引 i = removeSet.nextClearBit(i); // 将该索引位置的元素复制到j位置 elementData[j] = elementData[i]; } // 将新列表尾部的元素都置为null（这些元素都已被复制到前面，覆盖了前面被删掉的元素） for (int k=newSize; k \u0026lt; size; k++) { elementData[k] = null; // Let gc do its work } // 将新列表的大小赋值给当前列表大小 this.size = newSize; // 执行并发修改检查 if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } return anyToRemove; } 如下为示例：\n@Test public void testRemoveIf() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.removeIf(l -\u0026gt; l \u0026gt;1 \u0026amp;\u0026amp; l \u0026lt; 4); System.out.println(list); } 输出：\n[1, 4, 5] 58. public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 对列表中每个元素执行参数中指定的操作，并使用此操作获得的值代替当前位置上的元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; // 遍历当前列表 for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { // 对每个元素执行给定的操作，使用计算出的结果替代当前元素 elementData[i] = operator.apply((E) elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 如下所示：\n@Test public void testReplaceAll() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.replaceAll(i -\u0026gt; i * 5); System.out.println(list); } 输出：\n[5, 10, 15, 20, 25] 59. public void sort(Comparator\u0026lt;? super E\u0026gt; c) 基于参数中指定的比较器，对当前列表进行排序。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void sort(Comparator\u0026lt;? super E\u0026gt; c) { final int expectedModCount = modCount; // 使用Arrays的sort方法对当前列表的元素数组执行排序 Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 如下所示：\n@Test public void testSort() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.sort(Comparator.comparingInt(i -\u0026gt; -i)); System.out.println(list); } 输出：\n[5, 4, 3, 2, 1] ","description":"1. private static final long serialVersionUID = 8683452581122892189L; 2. private static final int DEFAULT_CAPACITY = 10; 3. private static final Object[] EMPTY_ELEMENTDATA = {}; 4. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 5. transient Object[] elementData; 6. private int size; 7. public ArrayList(int initialCapacity) 8. public ArrayList() 9. public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) 10. public void trimToSize() 11. public void ensureCapacity(int minCapacity) 12. private static int calculateCapacity(Object[] elementData, int minCapacity) 13."},{"id":23,"href":"/jdk8-src-note/java/util/AbstractSequentialList/","title":"AbstractSequentialList","parent":"util","content":" 1. protected AbstractSequentialList() 2. public E get(int index) 3. public E set(int index, E element) 4. public void add(int index, E element) 5. public E remove(int index) 6. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 7. public Iterator\u0026lt;E\u0026gt; iterator() 8. public abstract ListIterator\u0026lt;E\u0026gt; listIterator(int index); 此类提供List接口的基本实现，以减少实现支持“顺序访问”数据存储（例如链表）的该接口所需的工作。对于随机访问数据（例如数组），应优先使用AbstractList类。\n该类与AbstractList类相反，因为它在列表的列表迭代器的顶部实现了“随机访问”方法（get(int index)，set(int index, E element)，add(int index, E element)，remove(int index)），而不是相反。\n要实现一个列表，编程者仅需要扩展此类并为listIterator和size方法提供实现。对于不可修改的列表，编程者只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。\n对于可修改的列表，编程者应该另外实现列表迭代器的set方法。对于可变大小的列表，程序员应该另外实现列表迭代器的remove和add方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）和参数为Collection的构造函数。\n该接口是Java集合框架的成员接口。\n1. protected AbstractSequentialList() 唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n2. public E get(int index) 返回此列表中指定位置的元素。\n此实现首先获取一个指向索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.next获取元素并返回它。\n3. public E set(int index, E element) 用指定的元素替换此列表中指定位置的元素（可选操作）。\n此实现首先获取一个指向索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.next获取当前元素，并将其使用ListIterator.set替换。\n请注意，如果列表迭代器未实现set操作，则此实现将抛出UnsupportedOperationException。\n4. public void add(int index, E element) 将指定的元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。\n此实现首先获取一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.add 插入指定的元素。\n请注意，如果列表迭代器未实现add操作，则此实现将抛出UnsupportedOperationException。\n5. public E remove(int index) 删除此列表中指定位置的元素（可选操作）。将所有后续元素向左移动（将其索引减一）。返回从列表中删除的元素。\n此实现首先获取一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.remove删除该元素。\n请注意，如果列表迭代器未实现remove操作，则此实现将抛出UnsupportedOperationException。\n6. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 将指定集合中的所有元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在此列表中。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n此实现在指定集合上获得一个迭代器，并在此列表上获得一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，遍历指定的集合，使用ListIterator.next（跳过已插入的元素）之后接着使用ListIterator.add，将从迭代器获得的元素一次插入到此列表中。\n请注意，如果listIterator方法返回的列表迭代器未实现add操作，则此实现将引发UnsupportedOperationException。\n7. public Iterator\u0026lt;E\u0026gt; iterator() 返回此列表中元素的迭代器（按适当顺序）。\n此实现仅返回列表上的列表迭代器。\n8. public abstract ListIterator\u0026lt;E\u0026gt; listIterator(int index); 返回此列表中的元素的列表迭代器（按适当顺序）。\n","description":"1. protected AbstractSequentialList() 2. public E get(int index) 3. public E set(int index, E element) 4. public void add(int index, E element) 5. public E remove(int index) 6. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 7. public Iterator\u0026lt;E\u0026gt; iterator() 8. public abstract ListIterator\u0026lt;E\u0026gt; listIterator(int index); 此类提供List接口的基本实现，以减少实现支持“顺序访问”数据存储（例如链表）的该接口所需的工作。对于随机访问数据（例如数组），应优先使用AbstractList类。\n该类与AbstractList类相反，因为它在列表的列表迭代器的顶部实现了“随机访问”方法（get(int index)，set(int index, E element)，add(int index, E element)，remove(int index)），而不是相反。\n要实现一个列表，编程者仅需要扩展此类并为listIterator和size方法提供实现。对于不可修改的列表，编程者只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。\n对于可修改的列表，编程者应该另外实现列表迭代器的set方法。对于可变大小的列表，程序员应该另外实现列表迭代器的remove和add方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）和参数为Collection的构造函数。\n该接口是Java集合框架的成员接口。\n1. protected AbstractSequentialList() 唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n2. public E get(int index) 返回此列表中指定位置的元素。"},{"id":24,"href":"/jdk8-src-note/java/util/Map/","title":"Map","parent":"util","content":" 1. int size(); 2. boolean isEmpty(); 3. boolean containsKey(Object key); 4. boolean containsValue(Object value); 5. V get(Object key); 6. V put(K key, V value); 7. V remove(Object key); 8. void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m); 9. void clear(); 10. Set\u0026lt;K\u0026gt; keySet(); 11. Collection\u0026lt;V\u0026gt; values(); 12. Set\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet(); 13. interface Entry\u0026lt;K,V\u0026gt; 13.1 K getKey(); 13.2 V getValue(); 13.3 V setValue(V value); 13.4 boolean equals(Object o); 13.5 int hashCode(); 13.6 public static \u0026lt;K extends Comparable\u0026lt;? super K\u0026gt;, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026raquo; comparingByKey() 13.7 public static \u0026lt;K, V extends Comparable\u0026lt;? super V\u0026raquo; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026raquo; comparingByValue() 13.8 public static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; comparingByKey(Comparator\u0026lt;? super K\u0026gt; cmp) 13.9 public static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; comparingByValue(Comparator\u0026lt;? super V\u0026gt; cmp) 14. boolean equals(Object o); 15. int hashCode(); 16. default V getOrDefault(Object key, V defaultValue) 17. default void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 18. default void replaceAll(BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; function) 19. default V putIfAbsent(K key, V value) 20. default boolean remove(Object key, Object value) 21. default boolean replace(K key, V oldValue, V newValue) 22. default V replace(K key, V value) 23. default V computeIfAbsent(K key, Function\u0026lt;? super K, ? extends V\u0026gt; mappingFunction 24. default V computeIfPresent(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 25. default V compute(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 26. default V merge(K key, V value, BiFunction\u0026lt;? super V, ? super V, ? extends V\u0026gt; remappingFunction) Map是将键映射到值的对象。它不能包含重复的键；每个键最多可以映射到一个值。\n这个接口取代了Dictionary类，Dictionary是一个完全抽象的类而不是一个接口。\nMap接口提供三种集合视图，允许将map的内容视为键的集合、值的集合或键值映射的集合。map的顺序被定义为map集合视图上的迭代器返回其元素的顺序。一些Map实现，比如TreeMap类，对它们的顺序做出了具体的保证；其他的，比如HashMap类便没有这种保证。\n注意：如果将可变对象用作map的键，则必须非常小心。如果对象的值以影响equals比较的方式更改，而该对象又是映射中的键，则此时map的行为是不确定的。此禁令的一个特殊情况是不允许map将自身作为键。虽然允许map将自身包含为值，但建议格外小心：equals和hashCode方法未在此类map上明确定义。\n所有通用Map实现类都应该提供两个“标准”构造函数：一个创建空map的void（无参）构造函数，以及一个类型为 Map的单个参数的构造函数，它将创建一个新map并具有与其参数中指定map相同的键值映射。实际上，后一个构造函数允许用户复制任何map，生成所需类的等效map。没有办法强制执行此建议（因为接口不能包含构造函数），但 JDK 中的所有通用map实现都符合此规范。\n此接口中包含的“破坏性”方法，即操作它们时修改map的方法，如果此map不支持该操作，则指定为抛出UnsupportedOperationException。在这种情况下，如果调用对map没有影响，则这些方法可能（但不是必需）抛出UnsupportedOperationException。例如，在不可修改的map上调用putAll(Map)方法，如果要“叠加”的map为空的话则可能（但不是必须）抛出异常。\n一些Map实现对它们可能包含的键和值有限制。例如，有些实现禁止空的键和值，有些实现对其键的类型有限制。尝试插入不合格的键或值会引发未经检查的异常，通常是NullPointerException或ClassCastException。尝试查询不合格的键或值可能会引发异常，或者它可能只是返回false；一些实现会表现出前一种行为，而另一些会表现出后者。更一般地，尝试对不合格的键或值执行操作，其完成不会导致不合格的元素插入到map中，可能会引发异常，也可能会成功，具体取决于实现的选择。在此接口的规范中，此类异常被标记为“可选”。\n集合框架接口中的许多方法都是根据equals方法定义的。例如，containsKey(Object key)方法的规范说：“当且仅当此map包含键k使得(key==null ? k==null : key.equals(k))返回true。”本规范不应被解释为意味着使用非空参数key调用Map.containsKey将导致为任何键k调用key.equals(k)。实现类可以自由地进行优化，从而避免equals调用，例如，通过首先比较两个键的哈希码。Object的hashCode()规范保证哈希码不相等的两个对象不能相等。）更一般地说，各种集合框架接口的实现可以在实现者认为合适的任何地方自由地利用底层Object方法的指定行为。\n执行map某些递归遍历的操作可能会失败，但map直接或间接包含自身的自引用实例除外。这包括clone()、equals()、hashCode()和toString()方法。实现可以选择性地处理自引用场景，但是大多数当前的实现都没有这样做。\n该接口是Java集合框架的成员。\n1. int size(); 返回此map中键值映射的数量。如果map包含多于Integer.MAX_VALUE个元素，则返回Integer.MAX_VALUE。\n2. boolean isEmpty(); 如果此map不包含键值映射，则返回true。\n3. boolean containsKey(Object key); 如果此map包含指定键的映射，则返回true。更正式地说，当且仅当此map包含键k的映射使得(key==null ? k==null : key.equals(k))则返回true。 （最多可以有一个这样的映射。）\n4. boolean containsValue(Object value); 如果此映射能将一个或多个键映射到指定的值，则返回true。更正式地说，当且仅当此映射包含至少一个映射的值v使得(value==null ? v==null : value.equals(v))。对于Map接口的大多数实现，此操作可能需要与map大小成线性关系的时间。\n5. V get(Object key); 返回指定的键所映射的值，如果此map不包含该键的映射，则返回null。\n更正式地说，如果此映射包含从键k到值v的映射，使得(key==null ? k==null : key.equals(k))，则方法返回v，否则返回null。 （最多可以有一个这样的映射。）\n如果此map允许空值，则null的返回值并不一定表示该map不包含该键的映射，也有可能map将键显式映射到null。containsKey操作可用于区分这两种情况。\n6. V put(K key, V value); 在此map中将指定值与指定键相关联（可选操作）。如果map先前已包含键的映射，则旧值将替换为指定值。 （判断一个map m包含键k的映射，需满足的前提条件是：当且仅当m.containsKey(k)将返回true。）\n7. V remove(Object key); 此map中如果存在指定键的映射，则将其删除（可选操作）。更正式地说，如果此map包含从键k到值v的映射，使得(key==null ? k==null : key.equals(k))，则该映射将被删除。 （map最多可以包含一个这样的映射。）\n返回此map先前与键关联的值，如果map不包含键的映射，则返回null。\n如果此map允许空值，则返回值null并不一定表示该map不包含该键的映射，也有可能映射显式地将键映射到null（也就是存在某个key对应的value为null）。\n一旦调用该方法获得返回值，map将不再包含指定键的映射。\n8. void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m); 将所有映射从指定map复制到当前map（可选操作）。这个调用的效果相当于在当前map上调用put(k, v)将指定map中的每个从键k到值v的映射都添加到当前map中。如果在操作进行时修改了指定的map，则此操作的行为将变得不确定。\n9. void clear(); 从此map中删除所有映射（可选操作）。此调用返回后，map将为空。\n10. Set\u0026lt;K\u0026gt; keySet(); 返回此map中包含的键的Set视图。该集合基于当前map，因此对map的更改会反映在该集合中，反之亦然。如果在对集合进行迭代时修改了map（通过迭代器自己的remove操作除外），则迭代的结果是不确定的。该集合支持元素移除，即通过Iterator.remove、Set.remove、removeAll、retainAll和clear操作从map中移除相应的映射。它不支持add或addAll操作。\n11. Collection\u0026lt;V\u0026gt; values(); 返回此map中包含的值的Collection视图。集合基于当前map，因此对map的更改会反映在集合中，反之亦然。如果在对集合进行迭代时修改了map（通过迭代器自己的remove操作除外），则迭代的结果是不确定的。该集合支持元素移除，即通过Iterator.remove、Collection.remove、removeAll、retainAll和clear操作从map中移除相应的映射。它不支持add或addAll操作。\n12. Set\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet(); 返回此map中包含映射的Set视图。该集合由map支持，因此对map的更改会反映在该集合中，反之亦然。如果在对集合进行迭代时修改了map（通过迭代器自己的remove操作或通过迭代器返回的映射条目上的setValue操作除外），则迭代的结果是不确定的。该集合支持元素移除，即通过Iterator.remove、Set.remove、removeAll、retainAll和clear操作从map中移除相应的映射。它不支持add或addAll操作。\n13. interface Entry\u0026lt;K,V\u0026gt; 一个map条目（键值对）。Map.entrySet方法返回map的集合视图，其元素属于此类。获取映射条目引用的唯一方法来自此集合视图的迭代器。这些Map.Entry对象仅在迭代期间是有效的；更正式地说，如果在迭代器返回条目后修改了后备map，则map条目的行为是未定义的，除非是通过对映射条目的setValue操作。\n13.1 K getKey(); 返回当前条目对应的键。\n13.2 V getValue(); 返回当前条目对应的值。如果映射已从后备map中被删除（通过迭代器的remove操作），则此调用的结果是未定义的。\n13.3 V setValue(V value); 用指定的值替换此条目当前对应的值（可选操作）。 （会写入map。）如果映射已经从map中删除（通过迭代器的remove操作），则此调用的行为未定义。\n13.4 boolean equals(Object o); 比较指定的对象是否与当前条目相等。如果给定对象也是map的条目并且这两个条目表示相同的映射，则返回true。\n更准确的说，两个条目如果满足如下条件则认为他们代表相同的映射：\n(e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) \u0026amp;\u0026amp; (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) 这确保equals方法在Map.Entry接口的不同实现中正常工作。\n13.5 int hashCode(); 返回此map条目的哈希代码值。map条目e的哈希码定义为：\n(e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) 这确保e1.equals(e2)就意味着对于任意两个条目e1和e2都有e1.hashCode()==e2.hashCode()，这是遵循了Object.hashCode的通用规范的要求。\n13.6 public static \u0026lt;K extends Comparable\u0026lt;? super K\u0026gt;, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026raquo; comparingByKey() 返回一个比较器，它按键的自然顺序比较Map.Entry。\n返回的比较器是可序列化的，并在比较键为null的条目时抛出NullPointerException。\n源码如下：\npublic static \u0026lt;K extends Comparable\u0026lt;? super K\u0026gt;, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; comparingByKey() { return (Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; \u0026amp; Serializable) (c1, c2) -\u0026gt; c1.getKey().compareTo(c2.getKey()); } 13.7 public static \u0026lt;K, V extends Comparable\u0026lt;? super V\u0026raquo; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026raquo; comparingByValue() 返回一个比较器，它按值的自然顺序比较Map.Entry。\n返回的比较器是可序列化的，并在比较值为null的条目时抛出NullPointerException。\n源码如下：\npublic static \u0026lt;K, V extends Comparable\u0026lt;? super V\u0026gt;\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; comparingByValue() { return (Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; \u0026amp; Serializable) (c1, c2) -\u0026gt; c1.getValue().compareTo(c2.getValue()); } 13.8 public static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; comparingByKey(Comparator\u0026lt;? super K\u0026gt; cmp) 返回一个比较器，该比较器使用给定的Comparator按键比较Map.Entry。\n如果指定的比较器是可序列化的，则返回的比较器也是可序列化的。\n源码如下：\npublic static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; comparingByKey(Comparator\u0026lt;? super K\u0026gt; cmp) { Objects.requireNonNull(cmp); return (Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; \u0026amp; Serializable) (c1, c2) -\u0026gt; cmp.compare(c1.getKey(), c2.getKey()); } 13.9 public static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; comparingByValue(Comparator\u0026lt;? super V\u0026gt; cmp) 返回一个比较器，该比较器使用给定的Comparator按键比较Map.Entry。\n如果指定的比较器是可序列化的，则返回的比较器也是可序列化的。\n源码如下：\npublic static \u0026lt;K, V\u0026gt; Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; comparingByValue(Comparator\u0026lt;? super V\u0026gt; cmp) { Objects.requireNonNull(cmp); return (Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; \u0026amp; Serializable) (c1, c2) -\u0026gt; cmp.compare(c1.getValue(), c2.getValue()); } 14. boolean equals(Object o); 比较指定对象是否与当前map相等。如果给定的对象也是一个map并且这两个map表示相同的映射，则返回true。更正式地说，如果两个mapm1、m2满足m1.entrySet().equals(m2.entrySet())，则m1和m2表示相同的映射。这确保equals方法在Map接口的不同实现中正常工作。\n15. int hashCode(); 返回此map的哈希码值。map的哈希码定义为map的entrySet()视图中每个条目的哈希码之和。这确保对于任何两个map m1和m2来说m1.equals(m2)意味着m1.hashCode()==m2.hashCode()，这也是Object的hashCode通用规范要求。\n16. default V getOrDefault(Object key, V defaultValue) 返回指定键所映射到的值，如果此map不包含该键的映射，则返回defaultValue。\n默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\n源码如下：\ndefault V getOrDefault(Object key, V defaultValue) { V v; // 此处先调用get方法取出指定key对应的value，如果value不为空则直接返回该value // 如果value为空，则调用containsKey判断当前map是否包含键key，这是为了避免 // 当前map存在指定的键key，但该键对应的value为空的情况。 // 当value不为空时就没有调用containsKey进行判断的必要了，此处很巧妙。 return (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue; } 17. default void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 对此map中的每个条目执行给定的操作，直到处理完所有条目或该操作引发异常。除非实现类另有规定，否则将按照条目集合迭代的顺序执行操作（如果指定了迭代顺序）。该操作抛出的异常将转发给调用者。\n默认实现相当于对此map：\nfor (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) action.accept(entry.getKey(), entry.getValue()); 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\n源码如下：\ndefault void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) { Objects.requireNonNull(action); // 先调用entrySet()方法获取当前map的Set视图，然后遍历该Set for (Map.Entry\u0026lt;K, V\u0026gt; entry : entrySet()) { K k; V v; try { k = entry.getKey(); v = entry.getValue(); } catch(IllegalStateException ise) { // 此处需要try catch起来是因为该默认实现不保证同步，所以存在并发修改的可能 // 有可能在使用getKey()等方法时此条目已不存在 // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); } // 执行给定操作 action.accept(k, v); } } 18. default void replaceAll(BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; function) 将每个条目的值替换为对该条目调用给定函数获得的结果，直到处理完所有条目或该函数抛出异常。函数抛出的异常将被转发给调用者。\n默认实现相当于对此map：\nfor (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) entry.setValue(function.apply(entry.getKey(), entry.getValue())); 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\ndefault void replaceAll(BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; function) { Objects.requireNonNull(function); // 先调用entrySet()获取当前map的Set视图，然后遍历该Set for (Map.Entry\u0026lt;K, V\u0026gt; entry : entrySet()) { K k; V v; try { k = entry.getKey(); v = entry.getValue(); } catch(IllegalStateException ise) { // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); } // 从函数抛出的ise不是cme。 // ise thrown from function is not a cme. // 对当前条目的key和value执行给定的操作，得到一个值 v = function.apply(k, v); // 将该值赋值给当前条码的value try { entry.setValue(v); } catch(IllegalStateException ise) { // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); } } } 19. default V putIfAbsent(K key, V value) 如果指定的键尚未与值关联（或映射到了null），则将其与给定值进行关联并返回null，否则返回当前值。\n默认实现相当于对此map：\nV v = map.get(key); if (v == null) v = map.put(key, value); return v; 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\n源码如下：\ndefault V putIfAbsent(K key, V value) { // 调用get方法获取指定key的值 V v = get(key); // 如果该值为null，则调用put方法将指定的value与该key进行关联 // 此处未用containsKey进行判断，所以，即使当前map已包含指定key（但对应的value为空），此处也会为其设置新值 if (v == null) { v = put(key, value); } // 返回原值或指定的value return v; } 20. default boolean remove(Object key, Object value) 仅当当前map到指定值时，才删除指定键的条目。\n默认实现相当于对此map：\nif (map.containsKey(key) \u0026amp;\u0026amp; Objects.equals(map.get(key), value)) { map.remove(key); return true; } else return false; 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\n源码如下：\ndefault boolean remove(Object key, Object value) { // 取出指定key的值 Object curValue = get(key); // 判断取出的值是否与参数指定的值相等，若不相等则不能删除，此时返回true // 若相等，则看取出的值是否为空，如果为空的话则需要判断当前map是否包含指定的key，若不包含，则也不能删除 if (!Objects.equals(curValue, value) || (curValue == null \u0026amp;\u0026amp; !containsKey(key))) { return false; } // 执行删除，返回true remove(key); return true; } 21. default boolean replace(K key, V oldValue, V newValue) 仅当指定的键映射到指定值时才替换指定键的值。\n默认实现相当于对此map：\nif (map.containsKey(key) \u0026amp;\u0026amp; Objects.equals(map.get(key), value)) { map.put(key, newValue); return true; } else return false; 如果oldValue为 null，则默认实现不会为不支持null值的map抛出NullPointerException，除非newValue也为null。\n默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\n源码如下：\ndefault boolean replace(K key, V oldValue, V newValue) { // 取出指定key对应的值 Object curValue = get(key); // 如果取出的值与参数指定的旧值不同，则不能做替换，此时返回false // 若相同，还有可能是二者都为null，若是都为null，则判断当前map是否包含指定的键，若不包含，也不能替换，此时返回false if (!Objects.equals(curValue, oldValue) || (curValue == null \u0026amp;\u0026amp; !containsKey(key))) { return false; } put(key, newValue); return true; } 22. default V replace(K key, V value) 仅当指定键映射到某个值（值也可以是null，但是当前map必须要包含该key）时才替换指定键的条目。\n默认实现相当于对此map：\nif (map.containsKey(key)) { return map.put(key, value); } else return null; 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。\ndefault V replace(K key, V value) { V curValue; // 先取出指定key对应的值 // 再判断该值是否为空，不为空，则可以替换值，然后返回替换后的值 // 如果取出的值是null，则判断当前map是否包含该key，若包含该key，也可以予以替换 if (((curValue = get(key)) != null) || containsKey(key)) { curValue = put(key, value); } return curValue; } 23. default V computeIfAbsent(K key, Function\u0026lt;? super K, ? extends V\u0026gt; mappingFunction 如果指定的键尚未与值关联（或映射到null），则尝试使用给定的映射函数计算其值并将其放入此map，除非计算的结果为null。\n如果函数返回null，则不会记录任何映射。如果函数本身抛出（未经检查的）异常，则重新抛出异常，并且不记录任何映射。最常见的用法是构造一个新对象作为初始映射值或内存结果，如下所示：\nmap.computeIfAbsent(key, k -\u0026gt; new Value(f(k))); 或者实现一个多值映射，Map\u0026lt;K,Collection\u0026lt;V\u0026gt;\u0026gt;，支持每个键多个值：\nmap.computeIfAbsent(key, k -\u0026gt; new HashSet\u0026lt;V\u0026gt;()).add(v); 默认实现相当于对此map执行以下步骤，然后返回当前值或null（如果当前不存在）：\nif (map.get(key) == null) { V newValue = mappingFunction.apply(key); if (newValue != null) map.put(key, newValue); } 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。特别是，子接口java.util.concurrent.ConcurrentMap的所有实现都必须记录该函数是否仅在该值不存在时以原子方式应用一次。\n源码如下：\ndefault V computeIfAbsent(K key, Function\u0026lt;? super K, ? extends V\u0026gt; mappingFunction) { Objects.requireNonNull(mappingFunction); V v; // 只有取出的值为空，才执行给定的函数 if ((v = get(key)) == null) { V newValue; // 只有指定的函数执行的结果不为空才将其放入map if ((newValue = mappingFunction.apply(key)) != null) { put(key, newValue); return newValue; } } return v; } 24. default V computeIfPresent(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 如果指定键的值存在且非空，则尝试计算出一个值，并把这个值映射到该键上。\n如果函数返回null，则删除该映射。如果函数本身抛出（未经检查的）异常，则当前方法将重新抛出异常，并且当前映射保持不变。\n默认实现相当于对此map执行以下步骤，然后返回当前值或null（如果不存在）：\nif (map.get(key) != null) { V oldValue = map.get(key); V newValue = remappingFunction.apply(key, oldValue); if (newValue != null) map.put(key, newValue); else map.remove(key); } 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。特别是，子接口java.util.concurrent.ConcurrentMap的所有实现都必须记录该函数是否仅在该值不存在时以原子方式应用一次。\n源码如下：\ndefault V computeIfPresent(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) { Objects.requireNonNull(remappingFunction); V oldValue; // 先取出指定键对应的值，若该值不为空则对其执行给定的函数 if ((oldValue = get(key)) != null) { // 基于指定的key和该key原先的值计算出一个新值 V newValue = remappingFunction.apply(key, oldValue); // 判断新值是否为空 if (newValue != null) { // 若不为空，则将其映射到当前key，然后返回该新值 put(key, newValue); return newValue; } else { // 若为空，则将该key从当前map中删除，然后返回null remove(key); return null; } } else { return null; } } 25. default V compute(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 尝试计算指定键及其当前映射值（如果没有当前映射，则为null）的映射。例如，要创建或拼接String的msg到值映射：\n// 通常merge()方法用于此场景会更简单。 map.compute(key, (k, v) -\u0026gt; (v == null) ? msg : v.concat(msg)) 如果函数返回null，则删除映射（如果最初不存在，则保持不存在）。如果函数本身抛出（未经检查的）异常，则当前方法会重新抛出异常，并且当前映射保持不变。\n默认实现等同于对当前map执行以下步骤的操作，然后返回当前值或者null（如果不存在）：\nV oldValue = map.get(key); V newValue = remappingFunction.apply(key, oldValue); if (oldValue != null ) { if (newValue != null) map.put(key, newValue); else map.remove(key); } else { if (newValue != null) map.put(key, newValue); else return null; } 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。特别是，子接口java.util.concurrent.ConcurrentMap的所有实现都必须记录该函数是否仅在该值不存在时以原子方式应用一次。\n源码如下：\ndefault V compute(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) { Objects.requireNonNull(remappingFunction); // 先取出当前key对应的旧值 V oldValue = get(key); // 对当前key和对应的旧值执行给定重映射函数，得到一个新值 V newValue = remappingFunction.apply(key, oldValue); // 判断新值是否为空 if (newValue == null) { // 新值为空，则判断旧值或者当前map中是否存在当前key // delete mapping if (oldValue != null || containsKey(key)) { // 重映射函数计算出的新值为空，并且当前map包含当前key，此时删除该key // something to remove remove(key); return null; } else { // 当前map不包含当前key，则什么都不用做 // nothing to do. Leave things as they were. return null; } } else { // 计算出的新值不为空，则新增或者替换调原有映射 // add or replace old mapping put(key, newValue); // 返回新值 return newValue; } } 26. default V merge(K key, V value, BiFunction\u0026lt;? super V, ? super V, ? extends V\u0026gt; remappingFunction) 如果指定的键未关联到一个值，或者关联到null，则把该键关联到给定的非空值。否则，用指定的重映射函数计算出的结果来替换该键关联到的值，如果计算出的结果为null则删除该键。当将一个键的多个映射值组合到一起时，可以使用此方法。\n例如，创建或拼接一个String类型的msg到值映射：\nmap.merge(key, msg, String::concat) 如果函数返回null，则当前映射会被删除。如果函数本身抛出了（不受检查）异常，则当前方法会将异常重新抛出，并且当前异常保持不变。\n该默认实现等同于对该map执行如下步骤的操作，然后返回当前值或者null（如果不存在）：\nV oldValue = map.get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if (newValue == null) map.remove(key); else map.put(key, newValue); 默认实现不保证此方法的同步或原子性。任何提供原子性保证的实现都必须重写此方法并记录其并发属性。特别是，子接口java.util.concurrent.ConcurrentMap的所有实现都必须记录该函数是否仅在该值不存在时以原子方式应用一次。\n源码如下：\ndefault V merge(K key, V value, BiFunction\u0026lt;? super V, ? super V, ? extends V\u0026gt; remappingFunction) { // 执行非空校验 Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); // 先获取到指定键关联到的旧值 V oldValue = get(key); // 如果旧值为空，则新值就取参数列表中指定的值value // 否则，使用旧值和参数中给定的值value执行参数中指定的重映射函数 计算出新值 V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) { // 新值为空，则删除指定的键 remove(key); } else { // 新值不为空，则将该新值映射到指定的键上 put(key, newValue); } // 返回新值 return newValue; } ","description":"1. int size(); 2. boolean isEmpty(); 3. boolean containsKey(Object key); 4. boolean containsValue(Object value); 5. V get(Object key); 6. V put(K key, V value); 7. V remove(Object key); 8. void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m); 9. void clear(); 10. Set\u0026lt;K\u0026gt; keySet(); 11. Collection\u0026lt;V\u0026gt; values(); 12. Set\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet(); 13. interface Entry\u0026lt;K,V\u0026gt; 13.1 K getKey(); 13.2 V getValue(); 13.3 V setValue(V value); 13.4 boolean equals(Object o); 13.5 int hashCode(); 13."},{"id":25,"href":"/jdk8-src-note/java/io/","title":"io","parent":"java","content":" Closeable ","description":" Closeable "},{"id":26,"href":"/jdk8-src-note/java/util/RandomAccess/","title":"RandomAccess","parent":"util","content":" List 接口的实现类所使用的标记接口，标识出它们支持快速（通常为恒定时间）随机访问。该接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问或顺序访问列表时提供良好的性能。\n当用于操纵随机访问列表（例如ArrayList）的最佳算法应用于顺序访问列表（例如LinkedList）时，会产生二次行为。鼓励通用的列表算法在应用一种算法（如果将其应用于顺序访问列表时会产生较差的性能）之前，检查给定列表是否为此接口的实例（通过instanceof判断），并在必要时更改其行为以确保可接受的性能。\n公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现会提供渐近线性的访问时间（如果它们变得很大），但实际上却是恒定的访问时间。这样的List实现通常应实现此接口。根据经验，对于类的典型实例，在以下场景下当循环1快于循环2时List实现应实现此接口：\n循环1：\nfor (int i=0, n=list.size(); i \u0026lt; n; i++) list.get(i); 循环2：\nfor (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 该接口也是Java集合框架成员。\n","description":"List 接口的实现类所使用的标记接口，标识出它们支持快速（通常为恒定时间）随机访问。该接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问或顺序访问列表时提供良好的性能。\n当用于操纵随机访问列表（例如ArrayList）的最佳算法应用于顺序访问列表（例如LinkedList）时，会产生二次行为。鼓励通用的列表算法在应用一种算法（如果将其应用于顺序访问列表时会产生较差的性能）之前，检查给定列表是否为此接口的实例（通过instanceof判断），并在必要时更改其行为以确保可接受的性能。\n公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现会提供渐近线性的访问时间（如果它们变得很大），但实际上却是恒定的访问时间。这样的List实现通常应实现此接口。根据经验，对于类的典型实例，在以下场景下当循环1快于循环2时List实现应实现此接口：\n循环1：\nfor (int i=0, n=list.size(); i \u0026lt; n; i++) list.get(i); 循环2：\nfor (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 该接口也是Java集合框架成员。"},{"id":27,"href":"/jdk8-src-note/java/util/AbstractList/","title":"AbstractList","parent":"util","content":" 1. protected AbstractList() 2. public boolean add(E e) 3. abstract public E get(int index); 4. public E set(int index, E element) 5. public void add(int index, E element) 6. public E remove(int index) 7. public int indexOf(Object o) 8. public int lastIndexOf(Object o) 9. public void clear() 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 11. public Iterator\u0026lt;E\u0026gt; iterator() 12. public ListIterator\u0026lt;E\u0026gt; listIterator() 13. public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 14. private class Itr implements Iterator\u0026lt;E\u0026gt; 14.1 int cursor = 0; 14.2 int lastRet = -1; 14.3 int expectedModCount = modCount; 14.4 public boolean hasNext() 14.5 public E next() 14.6 public void remove() 14.7 final void checkForComodification() 15. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; 15.1 ListItr(int index) 15.2 public boolean hasPrevious() 15.3 public E previous() 15.4 public int nextIndex() 15.5 public int previousIndex() 15.6 public void set(E e) 15.7 public void add(E e) 16. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 17. public boolean equals(Object o) 18. public int hashCode() 19. protected void removeRange(int fromIndex, int toIndex) 20. protected transient int modCount = 0; 21. private void rangeCheckForAdd(int index) 22. private String outOfBoundsMsg(int index) 同一文件中的其他类 1. class SubList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; 1.1 private final AbstractList\u0026lt;E\u0026gt; l; 1.2 private final int offset; 1.3 private int size; 1.4 SubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 1.5 public E set(int index, E element) 1.6 public E get(int index) 1.7 public int size() 1.8 public void add(int index, E element) 1.9 public E remove(int index) 1.10 protected void removeRange(int fromIndex, int toIndex) 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 1.13 public Iterator\u0026lt;E\u0026gt; iterator() 1.14 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 1.15 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 1.16 private void rangeCheck(int index) 1.17 private void rangeCheckForAdd(int index) 1.18 private String outOfBoundsMsg(int index) 1.19 private void checkForComodification() 2. class RandomAccessSubList\u0026lt;E\u0026gt; extends SubList\u0026lt;E\u0026gt; implements RandomAccess 2.1 RandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 2.2 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 此类提供List接口的基本实现，以最大程度地减少实现支持“随机访问”数据存储（例如数组）所需的工作。对于顺序访问数据（例如链表），应优先使用AbstractSequentialList类。\n要实现不可修改的列表，编程者仅需扩展此类并为get和List的size方法提供实现。\n要实现可修改的列表，编程者必须另外重写set方法（否则将抛出UnsupportedOperationException）。如果列表是可变大小的，则程序员必须另外重写add和remove方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）的构造函数。\n与其他抽象集合的实现不同，编程者不必提供迭代器实现。迭代器和列表迭代器由此类在“随机访问”方法之上实现：\nget、set、add、remove。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合允许更有效的实现，则可以覆盖这些方法中的每一个。\n该类是Java集合框架的成员。\n1. protected AbstractList() 唯一构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractList() { } 2. public boolean add(E e) 将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制哪些元素可以添加到此列表。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n该方法的实现调用了add(int index, E element)方法，add(int index, E element)的默认实现是抛出UnsupportedOperationException，所以如果不重写它，那么调用当前方法也会抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { add(size(), e); return true; } 3. abstract public E get(int index); 获取列表在指定索引位置的元素。\n4. public E set(int index, E element) 在指定的索引位置设置指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E set(int index, E element) { throw new UnsupportedOperationException(); } 5. public void add(int index, E element) 在指定的索引位置添加指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic void add(int index, E element) { throw new UnsupportedOperationException(); } 6. public E remove(int index) 删除指定索引位置的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E remove(int index) { throw new UnsupportedOperationException(); } 7. public int indexOf(Object o) 此实现首先获取一个列表迭代器（通过listIterator()）。然后，在列表上进行迭代，直到找到指定的元素或到达列表的末尾。\n此方法，在通过listIterator()方法获取到列表迭代器后，逐个遍历元素：\n如果参数中给定的元素为null则判断next获得的元素是否为null，若是，则返回previousIndex。\n如果参数中给定的元素不为null，则通过equals方法判断next获取的元素是否和参数中给定的元素相同，若相同则返回则返回previousIndex。\n如果未能找到，则返回-1。\n源码如下：\npublic int indexOf(Object o) { // 此处获取的是列表迭代器 ListIterator\u0026lt;E\u0026gt; it = listIterator(); if (o==null) { while (it.hasNext()) // 此处已调用过next方法，所以一旦命中，需要返回的是previousIndex() if (it.next()==null) return it.previousIndex(); } else { while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); } return -1; } 8. public int lastIndexOf(Object o) 此实现首先获取一个指向列表末尾的列表迭代器（使用listIterator(size())）。然后，向后迭代列表，直到找到指定的元素，或者到达列表的开头。\n寻找元素的方法和indexOf方法一致，区别在于，本方法是从后往前找，也就是找的是指定的元素在列表中最后一次出现的位置，没找到则返回-1。\n源码如下：\npublic int lastIndexOf(Object o) { // 获取一个从列表末尾开始的迭代器 ListIterator\u0026lt;E\u0026gt; it = listIterator(size()); if (o==null) { while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); } else { while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); } return -1; } 9. public void clear() 从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n该实现将调用removeRange(0, size())。\n请注意，如果未重写remove(int index)或removeRange(int fromIndex, int toIndex)，本方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { removeRange(0, size()); } 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 此实现在参数中指定的集合上获得一个迭代器并对其进行迭代，使用add(int, E)将从迭代器获得的元素插入到此列表的适当位置，一次插入一个。\n为了提高效率，许多实现将覆盖此方法。\n请注意，除非重写add(int, Object)和add(int, E)，否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断指定的索引是否符合插入位置的范围限制 rangeCheckForAdd(index); boolean modified = false; // 调用遍历指定的集合c，将迭代到的每个元素放入当前集合 for (E e : c) { add(index++, e); modified = true; } return modified; } 11. public Iterator\u0026lt;E\u0026gt; iterator() 以正确的顺序返回在此列表元素上的迭代器。\n此实现依赖于来源列表的size()，get(int)和remove(int)方法来返回迭代器接口的简单实现。\n请注意，除非重写列表的remove(int)方法，否则此方法返回的迭代器将在调用其remove方法时抛出UnsupportedOperationException。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 返回一个Itr实例 return new Itr(); } 12. public ListIterator\u0026lt;E\u0026gt; listIterator() 本方法将调用listIterator(final int index)方法，只不过传入的index为0。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator() { return listIterator(0); } 13. public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 此实现返回ListIterator接口的直接实现，该接口继承了iterator()方法所返回的Iterator接口。ListIterator实现依赖于来源列表的get(int)，set(int, E)，add(int, E)和remove(int)方法。\n请注意，此实现返回的列表迭代器在调用其remove，set和add方法时抛出UnsupportedOperationException，除非列表的remove(int)，set(int, E)和add(int, E)方法已被重写。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 判断index的大小是否符合范围限制 rangeCheckForAdd(index); // 返回一个从index位置开始的ListItr实例 return new ListItr(index); } 14. private class Itr implements Iterator\u0026lt;E\u0026gt; 14.1 int cursor = 0; 迭代器在遍历列表时，游标所在位置。也即后续调用next所返回元素的索引。\n14.2 int lastRet = -1; 最近一次调用next或previous返回的元素的索引。如果通过调用remove删除了此元素，则重置为-1。\n14.3 int expectedModCount = modCount; 迭代器认为来源列表应该具有的modCount值。如果违反了此期望，则说明迭代器已检测到并发修改。\n14.4 public boolean hasNext() 判断是否还有其他元素，如果调用next还能获取到元素，则该方法应返回true。\n源码如下：\npublic boolean hasNext() { // 判断当前游标cursor是否与列表的元素数量相等 return cursor != size(); } 14.5 public E next() 获取下一个元素。\n源码如下：\npublic E next() { // 检查是否存在并发修改 checkForComodification(); try { // 将当前游标位置赋值给变量i int i = cursor; // 取出当前游标位置的元素，作为next E next = get(i); // 设置最近返回的元素索引为i lastRet = i; // 游标后移一位，即在当前值基础上加1 cursor = i + 1; // 返回之前取出的游标位置的元素 return next; } catch (IndexOutOfBoundsException e) { // 遇到数组下标越界异常，先检查是否存在并发修改，如不存在，则抛出无此元素异常 checkForComodification(); throw new NoSuchElementException(); } } 14.6 public void remove() 删除当前元素。\n源码如下：\npublic void remove() { // 如果lastRet小于0，则抛出IllegalStateException // 这说明要么迭代器初始化好之后还没有调用过next或previous、要么当前元素已被删除了 if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用列表的remove方法删除lastRet索引位置的元素 AbstractList.this.remove(lastRet); // 如果lastRet小于游标，则需将游标位置前移1位 if (lastRet \u0026lt; cursor) cursor--; // 将lastRet置为-1 lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { // 捕获到IndexOutOfBoundsException则说明存在并发修改，抛出ConcurrentModificationException throw new ConcurrentModificationException(); } } 14.7 final void checkForComodification() 该方法旨在检查是否存在并发修改，判断方法即判断expectedModCount是否等于modCount，不等于则说明存在并发修改，则抛出ConcurrentModificationException。\n源码如下：\nfinal void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 15. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt; 15.1 ListItr(int index) 构造一个列表迭代器，使用给定的参数index作为当前列表迭代器的游标位置。\n源码如下：\nListItr(int index) { cursor = index; } 15.2 public boolean hasPrevious() 判断当前迭代器前面是否还有元素，判断方法是：当前的游标位置cursor是否为0，为0则说明前面已经没有元素了，此时返回false，否则返回true。\n源码如下：\npublic boolean hasPrevious() { return cursor != 0; } 15.3 public E previous() 获取上一个元素，获取方法为：\n使用当前游标位置减1，算出上一个元素的位置，然后取出该位置的元素，同时设置lastRet和游标位置cursor为该位置，然后返回该元素。\n源码如下：\npublic E previous() { checkForComodification(); try { // 将当前游标的前一位赋值给变量i int i = cursor - 1; // 获取i位置的元素作为返回值 E previous = get(i); // 将最近返回的索引位置和游标位置均置为i lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 15.4 public int nextIndex() 获取下一个元素的索引，获取方法是：直接返回当前游标位置cursor。\n源码如下：\npublic int nextIndex() { return cursor; } 15.5 public int previousIndex() 获取上一个元素的索引，获取方法是：返回当前游标位置cursor-1。\n源码如下：\npublic int previousIndex() { return cursor-1; } 15.6 public void set(E e) 设置当前位置（lastRet位置）的元素为参数中给定的元素，也即替换最后一次调用next或previous方法得到的元素。\n首先，判断lastRet是否小于0，小于0说明其还未调用过next或previous或者调用过remove方法已将当前位置的元素删掉或使用add方法添加了元素，如果小于0，则抛出IllegalStateException。然后检查是否存在并发修改，调用AbstractList的set方法进行赋值。\n源码如下：\npublic void set(E e) { // lastRet小于0说明其还未调用过next或previous // 或者调用过remove方法已将当前位置的元素删掉 // 或者使用add方法添加了元素 if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 使用列表的set方法进行元素的替换 AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 15.7 public void add(E e) 首先检查是否存在并发修改，然后在调用AbstractList的add方法在当前游标位置添加给定的元素。然后，将lastRet置为-1，同时将当前游标位置cursor加1。\n源码如下：\npublic void add(E e) { checkForComodification(); try { // 将当前游标的值赋给变量i int i = cursor; // 调用列表的add方法将指定的元素e插入到列表的i位置处 AbstractList.this.add(i, e); // 设定最近返回的索引位置为-1 lastRet = -1; // 设定当前游标位置加1 cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 16. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 此实现返回一个AbstractList的子类的列表。子类在私有字段中存储来源列表中子列表的偏移量、子列表的大小（可以在其生存期内更改）以及来源列表的预期modCount值。子类有两种变体，其中一种实现RandomAccess。如果此列表实现RandomAccess，则返回的列表将是实现RandomAccess的子类的实例。\n子类的set(int, E)，get(int)，add(int, E)，remove(int)，addAll(int, Collection)和removeRange(int, int)方法都在对索引进行边界检查并调整了偏移量之后，委派给了抽象列表上的相应方法。 addAll(Collection c)方法仅返回addAll(size, c)。\nlistIterator(int)方法在来源列表的列表迭代器上返回“包装对象”，该列表迭代器是使用来源列表上的相应方法创建的。iterator方法仅返回listIterator()，而size方法仅返回子类的size字段。\n所有方法首先检查来源列表的实际modCount是否等于其期望值，如果不是，则抛出ConcurrentModificationException。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { // 判断当前列表是否是RandomAccess的实例 // 若是，则返回一个RandomAccessSubList实例，否则返回SubList实例 return (this instanceof RandomAccess ? new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex) : new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex)); } 17. public boolean equals(Object o) 比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时，才返回true。 （如果(e1==null ? e2==null : e1.equals(e2))，则两个元素e1和e2是相等。）换句话说，如果两个列表包含相同顺序的相同元素，则定义为相等。\n此实现首先检查指定的对象是否是此列表。如果是，则返回true，如果不是，则检查指定对象是否为列表。如果不是列表，则返回false，如果是列表，则遍历两个列表，比较对应的元素对。如果有任何比较返回false，则此方法返回false。如果一个迭代器在另一个迭代器之前用尽了元素，则返回false（因为列表的长度不相等），否则，当迭代完成时，它将返回true。\n源码如下：\npublic boolean equals(Object o) { // 指定对象等于当前列表则直接返回true if (o == this) return true; // 指定对象不是List接口的实例则直接返回false if (!(o instanceof List)) return false; ListIterator\u0026lt;E\u0026gt; e1 = listIterator(); ListIterator\u0026lt;?\u0026gt; e2 = ((List\u0026lt;?\u0026gt;) o).listIterator(); // 同时遍历两个列表 while (e1.hasNext() \u0026amp;\u0026amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); // 如果发现存在一个元素不匹配，则返回false if (!(o1==null ? o2==null : o1.equals(o2))) return false; } // 如果上面结束遍历，但仍有一个集合还有未迭代到的元素，则返回false return !(e1.hasNext() || e2.hasNext()); } 18. public int hashCode() 返回该列表的hash值。\n此实现完全使用List中hashCode方法的文档中定义列表哈希函数的代码。\n源码如下：\npublic int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; } 19. protected void removeRange(int fromIndex, int toIndex) 从此列表中删除所有索引在fromIndex和toIndex（不含）之间的所有元素。将所有后续元素向左移动（减少其索引）。此调用通过删除toIndex-fromIndex元素来缩短列表。 （如果toIndex == fromIndex，则此操作无效。）\n此列表及其子列表上的clear操作调用此方法。重写此方法以利用列表实现的内部功能可以大大地改善此列表及其子列表上的clear操作的性能。\n此实现获取位于fromIndex之前位置的列表迭代器，并反复调用ListIterator.next，然后依次调用ListIterator.remove，直到删除了整个范围的元素。 注意：如果ListIterator.remove需要线性时间，则此实现需要平方时间。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { // 获取从fromIndex位置的列表迭代器 ListIterator\u0026lt;E\u0026gt; it = listIterator(fromIndex); // 使用toIndex - fromIndex计算出要删除元素的个数，然后遍历，逐个删除元素 for (int i=0, n=toIndex-fromIndex; i\u0026lt;n; i++) { it.next(); it.remove(); } } 20. protected transient int modCount = 0; 此列表已被结构上修改的次数。结构上修改是指更改列表大小或以其他方式干扰列表的方式，即正在进行的迭代可能会产生错误的结果。\n此字段被iterator和listIterator方法返回的迭代器和列表迭代器的实现所使用。如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException以响应next，remove，previous，set或add操作。面对迭代期间的并发修改，提供了“快速失败”机制，而不是不确定的行为。\n子类对此字段的使用是可选的。如果子类希望提供“快速失败”的迭代器（和列表迭代器），则只需在其add和remove方法（以及它覆盖的所有其他会对列表进行结构修改的方法）。一次调用add或remove应只对此字段加1，否则迭代器（和列表迭代器）将误抛出ConcurrentModificationExceptions。如果实现不希望提供“快速失败”的迭代器，则可以忽略此字段。\n21. private void rangeCheckForAdd(int index) 添加元素到列表之前对要添加元素的位置进行校验，校验方式为：参数中指定的index是否小于0或者大于size()，若是则抛出IndexOutOfBoundsException。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size()) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 22. private String outOfBoundsMsg(int index) 获取一个数组越界的提示信息。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size(); } 同一文件中的其他类 1. class SubList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; AbstractList可以截取自身的一截，以SubList的形式返回，SubList也支持增删改查，它持有它的父列表，并提供增删查改操作，所以增删改也会影响到其父列表。\n它更像是其父列表的代理人，对该子列表的任何增删改，它都是通过其父列表的增删改来实现的。\n1.1 private final AbstractList\u0026lt;E\u0026gt; l; 当前SubList实例的父列表（也即当前实例基于的那个列表）。\n1.2 private final int offset; 基于父列表的索引偏移量，用于定位当前列表的位置。\n1.3 private int size; 当前列表的大小。\n1.4 SubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 构造方法，构造一个SubList实例。\n源码如下：\nSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { // 先进行校验 if (fromIndex \u0026lt; 0) throw new IndexOutOfBoundsException(\u0026#34;fromIndex = \u0026#34; + fromIndex); if (toIndex \u0026gt; list.size()) throw new IndexOutOfBoundsException(\u0026#34;toIndex = \u0026#34; + toIndex); if (fromIndex \u0026gt; toIndex) throw new IllegalArgumentException(\u0026#34;fromIndex(\u0026#34; + fromIndex + \u0026#34;) \u0026gt; toIndex(\u0026#34; + toIndex + \u0026#34;)\u0026#34;); // 再执行各个属性的初始化 l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; } 1.5 public E set(int index, E element) 替换指定索引位置的元素。\n源码如下：\npublic E set(int index, E element) { // 指定索引的合法性检查 rangeCheck(index); // 检查是否存在并发修改 checkForComodification(); // 调用负列表的set方法进行元素的替换，父列表对应的索引位置为：当前指定的索引 + 偏移量 return l.set(index+offset, element); } 1.6 public E get(int index) 获取指定索引位置的元素。\n源码如下：\npublic E get(int index) { // 与set方法相同的套路，索引范围检查、并发检查、通过父列表获取指定位置的元素 rangeCheck(index); checkForComodification(); return l.get(index+offset); } 1.7 public int size() 获取当前列表的大小。\n源码如下：\npublic int size() { // 先调用checkForComodification进行并发修改检查，再返回size checkForComodification(); return size; } 1.8 public void add(int index, E element) 在指定的索引位置插入指定元素。\n源码如下：\npublic void add(int index, E element) { rangeCheckForAdd(index); checkForComodification(); // 使用父列表的add方法添加元素 l.add(index+offset, element); // 同步修改次数 this.modCount = l.modCount; size++; } 1.9 public E remove(int index) 删除指定索引位置的元素。\n源码如下：\npublic E remove(int index) { rangeCheck(index); checkForComodification(); // 使用父列表的remove方法删除指定元素 E result = l.remove(index+offset); this.modCount = l.modCount; size--; return result; } 1.10 protected void removeRange(int fromIndex, int toIndex) 删除指定索引范围内的元素。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { checkForComodification(); // 使用父列表的removeRange方法删除元素 l.removeRange(fromIndex+offset, toIndex+offset); this.modCount = l.modCount; size -= (toIndex-fromIndex); } 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定集合内的元素添加到当前列表的末尾。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 当前列表的末尾并非一定是父列表的末尾，所以此处调用自己的addAll方法将元素插入到本列表末尾（即索引位置为size处） return addAll(size, c); } 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 将指定集合内的元素添加到当前列表的指定位置。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 对指定的索引位置index的合法性做检查 rangeCheckForAdd(index); // 指定集合的大小为0，则直接返回false int cSize = c.size(); if (cSize==0) return false; // 并发修改检查 checkForComodification(); // 调用父类的addAll方法添加指定集合的元素 l.addAll(offset+index, c); this.modCount = l.modCount; size += cSize; return true; } 1.13 public Iterator\u0026lt;E\u0026gt; iterator() 获取一个迭代器，调用父列表的listIterator。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 调用父列表的listIterator()方法 return listIterator(); } 1.14 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 获取一个从指定索引位置开始的列表迭代器。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 进行并发修改检查 checkForComodification(); // 指定索引的合法性检查 rangeCheckForAdd(index); // 返回一个实现ListIterator的匿名内部类，首先其持有的也是父类的列表迭代器 // 只是进行操作的时候会加上偏移量 return new ListIterator\u0026lt;E\u0026gt;() { private final ListIterator\u0026lt;E\u0026gt; i = l.listIterator(index+offset); public boolean hasNext() { return nextIndex() \u0026lt; size; } public E next() { if (hasNext()) return i.next(); else throw new NoSuchElementException(); } public boolean hasPrevious() { return previousIndex() \u0026gt;= 0; } public E previous() { if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); } public int nextIndex() { return i.nextIndex() - offset; } public int previousIndex() { return i.previousIndex() - offset; } public void remove() { i.remove(); SubList.this.modCount = l.modCount; size--; } public void set(E e) { i.set(e); } public void add(E e) { i.add(e); SubList.this.modCount = l.modCount; size++; } }; } 1.15 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 返回一个当前类的实例，新实例基于当前子列表。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } 1.16 private void rangeCheck(int index) 范围检查，检查指定的索引是否会造成数组下标越界。\n源码如下：\nprivate void rangeCheck(int index) { if (index \u0026lt; 0 || index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.17 private void rangeCheckForAdd(int index) 新插入元素前对元素插入位置的校验，与rangeCheck类似，不同的是：rangeCheck校验的是index是否小于0或大于等于size，而rangeCheckForAdd校验的是index是否小于0或大于size，因为新增的时候可以在index为size的位置插入元素（也即在列表的末尾插入元素）。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.18 private String outOfBoundsMsg(int index) 整理索引越界时的提示信息，\u0026quot;Index: \u0026quot;+index+\u0026quot;, Size: \u0026quot;+size。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size; } 1.19 private void checkForComodification() 判断是否存在并发修改，判断依据是，当前列表的更新量modCount和其父列表的更新量modCount是否一致，不一致则抛出ConcurrentModificationException。\n源码如下：\nprivate void checkForComodification() { if (this.modCount != l.modCount) throw new ConcurrentModificationException(); } 2. class RandomAccessSubList\u0026lt;E\u0026gt; extends SubList\u0026lt;E\u0026gt; implements RandomAccess 该类是一个随机访问的子列表。\n2.1 RandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 构造方法，调用父类SubList的构造方法。\n源码如下：\nRandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { super(list, fromIndex, toIndex); } 2.2 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 返回一个基于当前列表的新RandomAccessSubList实例。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } ","description":"1. protected AbstractList() 2. public boolean add(E e) 3. abstract public E get(int index); 4. public E set(int index, E element) 5. public void add(int index, E element) 6. public E remove(int index) 7. public int indexOf(Object o) 8. public int lastIndexOf(Object o) 9. public void clear() 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 11. public Iterator\u0026lt;E\u0026gt; iterator() 12. public ListIterator\u0026lt;E\u0026gt; listIterator() 13. public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 14."},{"id":28,"href":"/jdk8-src-note/java/util/List/","title":"List","parent":"util","content":" 1. int size(); 2. boolean isEmpty(); 3. boolean contains(Object o); 4. Iterator\u0026lt;E\u0026gt; iterator(); 5. Object[] toArray(); 6. \u0026lt;T\u0026gt; T[] toArray(T[] a); 7. boolean add(E e); 8. boolean remove(Object o); 9. boolean containsAll(Collection c); 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); 11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); 12. boolean removeAll(Collection c); 13. boolean retainAll(Collection c); 14. default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c) 16. void clear(); 17. boolean equals(Object o); 18. int hashCode(); 19. E get(int index); 20. E set(int index, E element); 21. void add(int index, E element); 22. E remove(int index); 23. int indexOf(Object o); 24. int lastIndexOf(Object o); 25. ListIterator\u0026lt;E\u0026gt; listIterator(); 26. ListIterator\u0026lt;E\u0026gt; listIterator(int index); 27. List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex); 28. default Spliterator\u0026lt;E\u0026gt; spliterator() 有序集合（也称为sequence）。该接口的用户可以精确控制列表中每个元素的插入位置。用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素。\n与集合不同，列表通常允许重复的元素。更正式地说，列表通常允许成对的元素e1和e2，它们满足e1.equals(e2)，并且如果允许空值，它们通常允许多个空元素。有人希望通过在用户尝试插入重复元素时抛出运行时异常来实现禁止重复的列表，这也并非不可行，但我们希望这种用法很少见。\nList接口在已熟知的Collection 接口的规定之外有一些额外的规定，在iterator，add，remove，equals和hashCode方法上。为了方便起见，还包括其他继承方法的声明。\nList接口提供了四种使用位置（索引）访问列表元素的方法。列表（如Java数组）是从零开始的。请注意，对于某些实现（例如，LinkedList类），这些操作可能在时间上与索引值成比例地执行。因此，如果调用者不知道实现，则遍历列表中的元素通常比对其进行索引更可取。\nList接口提供了一个特殊的迭代器，称为ListIterator，除Iterator接口的常规操作外，它还允许元素插入和替换以及双向访问。它还提供了一种获取列表迭代器的方法，该列表迭代器从列表中的指定位置开始。\nList接口提供了两种搜索指定对象的方法。从性能的角度来看，应谨慎使用这些方法。在许多实现中，它们将执行昂贵的线性搜索。\nList接口提供了两种方法，可以有效地在列表中的任意点插入和删除多个元素。\n注意：虽然允许列表包含自己作为元素，但建议格外小心：equals和hashCode方法在这样的列表上不再有很好的定义。\n一些列表实现对它们可能包含的元素有限制。例如，某些实现禁止使用null元素，而某些实现对其元素类型进行限制。尝试添加不合格的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询不合格元素的存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些将表现出后者。更一般地，尝试对不合格元素进行操作，该操作的完成不会导致将不合格元素插入列表中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n该接口是Java集合框架的成员。\n1. int size(); 返回此列表中的元素数。如果此列表包含多于 Integer.MAX_VALUE 个元素，则返回Integer.MAX_VALUE 。\n2. boolean isEmpty(); 当前列表不包含元素时返回 true 。\n3. boolean contains(Object o); 如果当前列表包含指定的元素则返回 true 。\n更准确的说，当且仅当列表中至少存在一个元素满足 (o == null ? e == null : o.equals(e) 时返回 true 。\n如果指定的元素类型不匹配，则可以抛出 ClassCastException ，但这是可选操作，也可以不抛出异常。\n如果指定的元素是空，且当前列表不允许空元素，则可以抛出 NullPointerException ，这也是可选操作。\n4. Iterator\u0026lt;E\u0026gt; iterator(); 以正确的顺序返回在此列表中的元素上的迭代器。\n5. Object[] toArray(); 以正确的顺序（从第一个元素到最后一个元素）返回一个包含此列表中所有元素的数组。\n返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，即使此列表由数组支持，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n6. \u0026lt;T\u0026gt; T[] toArray(T[] a); 返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。\n如果列表适合指定的数组并有剩余空间（即数组中的元素多于列表），则数组中紧接列表末尾的元素将设置为null。 （如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n7. boolean add(E e); 将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制可以添加到此列表的元素。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n8. boolean remove(Object o); 如果存在指定元素，则从列表中删除该元素的第一个匹配项（可选操作）。如果此列表不包含该元素，则它保持不变。更准确的说，删除满足(o==null ? get(i)==null : o.equals(get(i))) 条件的最小索引i的元素（如果存在这样的元素）。如果此列表包含指定的元素（或者等效地，如果此列表由于调用而更改），则返回true。\n9. boolean containsAll(Collection c); 如果此列表包含指定集合的所有元素，则返回true。\n按照指定集合的迭代器返回的顺序（可选操作），将指定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); 按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); 将指定集合中的所有元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在此列表中。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n12. boolean removeAll(Collection c); 从此列表中删除指定集合中包含的所有其元素（可选操作）。\n13. boolean retainAll(Collection c); 仅保留此列表中包含的指定集合中的元素（可选操作）。换句话说，从该列表中删除所有未包含在指定集合中的元素。\n14. default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 用指定运算符应用于该元素的结果替换此列表中的每个元素。操作时抛出的错误或运行时异常将中继给调用方。\n对于此list，默认实现等效于：\nfinal ListIterator\u0026lt;E\u0026gt; li = list.listIterator(); while (li.hasNext()) { li.set(operator.apply(li.next())); } 如果列表的列表迭代器不支持set操作，则替换第一个元素时将引发UnsupportedOperationException。\n源码如下：\ndefault void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final ListIterator\u0026lt;E\u0026gt; li = this.listIterator(); // 使用迭代器遍历当前集合 while (li.hasNext()) { // 对遍历到的每个元素执行指定的操作，将得到的返回值替换当前元素 li.set(operator.apply(li.next())); } } 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c) 根据指定的Comparator 所指定的顺序对该列表进行排序。\n此列表中的所有元素必须相互可比，即使用指定的比较器（c.compare(e1, e2)）不得为任何元素例如列表中的e1、e2抛出ClassCastException。\n如果指定的比较器为null，则此列表中的所有元素都必须实现Comparable接口，并且应使用元素的Comparable自然排序。\n该列表必须是可修改的，但无需可调整大小。\n默认实现获取一个包含此列表中所有元素的数组，然后对该数组进行排序，并在此列表上进行迭代，从数组中的相应位置重置每个元素。（这避免了由于尝试对链表进行排序而导致的$n^2$ log(n)的性能开销。）\n此实现是一种稳定的，自适应的，可迭代的合并排序，当对输入数组进行部分排序时，所需的比较少于n lg(n)，而在对输入数组进行随机排序时，它提供了传统合并排序的性能。如果输入数组几乎已排序，则该实现需要大约n个比较。临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n/2对象引用，不一而足。\n该实现在其输入数组中利用了升序和降序的同等优势，并且可以在同一输入数组的不同部分中利用了升序和降序的优势。它非常适合合并两个或多个排序后的数组：简单地将数组连接起来并对排序后的数组进行排序。\n该实现改编自Tim Peters针对Python的列表排序TimSort。它使用了Peter McIlroy的“乐观排序和信息理论复杂性”技术，该技术在1993年1月举行的第四届ACM-SIAM离散算法年会上发表，第467-474页。\n源码如下：\ndefault void sort(Comparator\u0026lt;? super E\u0026gt; c) { // 将当前列表转换为数组a Object[] a = this.toArray(); // 使用指定的比较器c对数组a进行排序 Arrays.sort(a, (Comparator) c); ListIterator\u0026lt;E\u0026gt; i = this.listIterator(); // 遍历数组a，将每个元素放入当前集合 for (Object e : a) { i.next(); i.set((E) e); } } 16. void clear(); 从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n17. boolean equals(Object o); 比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时（如果(e1==null ? e2==null : e1.equals(e2))），才返回true。\n换句话说，如果两个列表包含相同顺序的相同元素，则将两个列表定义为相等。此定义确保equals方法可在List接口的不同实现中正常工作。\n18. int hashCode(); 返回此列表的哈希码值。列表的哈希码定义为以下计算的结果：\nint hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); 这样可以确保list1.equals(list2)意味着对于任意两个列表list1和list2均有list1.hashCode()==list2.hashCode()，这是Object中hashCode的基本要求。\n19. E get(int index); 返回列表中指定位置的元素。\n20. E set(int index, E element); 替换列表中指定位置的元素为指定的元素（可选操作），然后将返回被替换掉的元素。\n21. void add(int index, E element); 将指定的元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。\n22. E remove(int index); 删除此列表中指定位置的元素（可选操作）。将所有后续元素向左移动（将其索引减一）。然后返回从列表中删除的元素。\n23. int indexOf(Object o); 返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最小索引i或-1（如果没有这样的索引）。\n24. int lastIndexOf(Object o); 返回指定元素在此列表中最后一次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最大索引i或-1（如果没有这样的索引）。\n25. ListIterator\u0026lt;E\u0026gt; listIterator(); 返回此列表中的元素的列表迭代器（按适当顺序）。\n26. ListIterator\u0026lt;E\u0026gt; listIterator(int index); 返回在此列表从指定位置开始的列表迭代器（以适当的顺序）。指定的索引就是初始调用next将返回的第一个元素。初次调用previous将返回指定索引减一的元素。\n27. List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex); 返回此列表在指定的fromIndex（含）和toIndex（不含）之间的视图。 （如果fromIndex和toIndex相等，则返回列表为空。）返回的列表由此列表支持，因此该列表中反映了返回列表中的非结构性更改 ，反之亦然。返回的列表支持此列表支持的所有可选列表操作。\n此方法消除了对显式范围操作（数组通常存在的那种范围）的需要。通过subList视图而不是整个列表，可以对列表进行期望的任何范围操作。例如，以下常见用法从列表中删除了一系列元素：\nlist.subList(from, to).clear(); 可以为indexOf和lastIndexOf构建类似的习惯用法，并且Collections类中的所有语法都可以应用于子列表。\n如果后备列表（即此列表）以除通过返回列表以外的任何其他方式进行结构修改，则此方法返回的列表的语义将变得不确定。（结构修改是指更改此列表大小或以其他方式干扰列表的方式，正在进行的迭代可能会产生不正确的结果。）\n28. default Spliterator\u0026lt;E\u0026gt; spliterator() 创建一个包含此列表所有元素的 Spliterator 。\nSpliterator报告SIZED和ORDERED。实现类应记录其他特征值的报告。\n默认实现从列表的Iterator创建一个延迟绑定的拆分器。该拆分器继承了列表迭代器“快速失败”的属性。\n创建的Spliterator还报告SUBSIZED。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, Spliterator.ORDERED); } ","description":"1. int size(); 2. boolean isEmpty(); 3. boolean contains(Object o); 4. Iterator\u0026lt;E\u0026gt; iterator(); 5. Object[] toArray(); 6. \u0026lt;T\u0026gt; T[] toArray(T[] a); 7. boolean add(E e); 8. boolean remove(Object o); 9. boolean containsAll(Collection c); 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); 11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); 12. boolean removeAll(Collection c); 13. boolean retainAll(Collection c); 14. default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c) 16. void clear(); 17."},{"id":29,"href":"/jdk8-src-note/java/util/ListIterator/","title":"ListIterator","parent":"util","content":" 1. boolean hasNext(); 2. E next(); 3. boolean hasPrevious(); 4. E previous(); 5. int nextIndex(); 6. int previousIndex(); 7. void remove(); 8. void set(E e); 9. void add(E e); 列表的迭代器，允许编程者在任一方向上遍历列表，在迭代过程中修改列表，并获取迭代器在列表中的当前位置。ListIterator不持有当前元素，它的游标位置始终位于previous()返回的元素与next()返回的元素之间。 长度为n列表的迭代器具有n+1个可能的光标位置，如下面的插入符号（^）所示：\nElement(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 注意remove()和set(E e)方法不是根据光标位置定义的。它们被定义为对调用next()或previous()返回的最后一个元素进行操作。 该接口也是Java集合框架的成员接口。它继承于Iterator。\n注：下文中提到的“前”和“后”定义为：\n前：索引增大的方向 后：索引减小的方向 1. boolean hasNext(); 当按照前进的方向遍历一个数组时，如果当前列表迭代器还有其他元素时返回true。（换句话说，如果next()方法能返回一个元素而非抛出一个异常，则返回true）\n2. E next(); 返回列表中的下一个元素并向前移动光标位置。 可以重复调用此方法以遍历列表，也可以将其与previous()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有下一个元素时抛出NoSuchElementException。\n3. boolean hasPrevious(); 当反向遍历列表时，如果列表迭代器还有其他元素，则返回true。（换句话说，当调用previous()时能返回一个元素而非抛出异常时，返回true）\n4. E previous(); 返回列表中的前一个元素，并将光标位置向后移动。可以重复调用此方法以向后遍历列表，也可以将其与next()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有上一个元素时抛出NoSuchElementException。\n5. int nextIndex(); 返回下一个元素的索引，也即后续对next()的调用返回的元素。 （如果列表迭代器位于列表的末尾，则返回列表大小。）\n6. int previousIndex(); 返回上一个元素的索引，也即后续对previous()调用返回的元素。（如果列表迭代器位于列表的开头，则返回-1）\n7. void remove(); 从列表中删除next()或previous()返回的最后一个元素（可选操作）。每次调用next()或previous()时，只能进行一次此调用。仅当在上次调用next()或previous()之后没有调用add()时，才可以进行删除。 当没有调用next()或者previous()就调用remove()方法时或者在最后一次调用next()或previous()后已经调用过add()或remove()，则抛出IllegalStateException。\n8. void set(E e); 将next()或previous()返回的最后一个元素替换为指定的元素（可选操作）。仅在上次调用next()或previous()之后没有调用remove()或add()的情况下才能进行此调用。 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。 当没有调用next()或者previous()就调用set()方法时或者在最后一次调用next()或previous()后调用过add()或remove()，则抛出IllegalStateException。\n9. void add(E e); 将指定的元素插入列表（可选操作）。该元素将立即插入next()返回的元素之前（如果有的话）、previous()返回的元素之后（如果有的话）。 （如果列表不包含任何元素，则新元素将成为列表上的唯一元素。）新元素将插入到游标之前：对next()的后续调用将不受影响，对previous()的后续调用将返回新元素。 （此调用使得调用nextIndex()或previousIndex()返回的值加一。） 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。\n","description":"1. boolean hasNext(); 2. E next(); 3. boolean hasPrevious(); 4. E previous(); 5. int nextIndex(); 6. int previousIndex(); 7. void remove(); 8. void set(E e); 9. void add(E e); 列表的迭代器，允许编程者在任一方向上遍历列表，在迭代过程中修改列表，并获取迭代器在列表中的当前位置。ListIterator不持有当前元素，它的游标位置始终位于previous()返回的元素与next()返回的元素之间。 长度为n列表的迭代器具有n+1个可能的光标位置，如下面的插入符号（^）所示：\nElement(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 注意remove()和set(E e)方法不是根据光标位置定义的。它们被定义为对调用next()或previous()返回的最后一个元素进行操作。 该接口也是Java集合框架的成员接口。它继承于Iterator。\n注：下文中提到的“前”和“后”定义为：\n前：索引增大的方向 后：索引减小的方向 1. boolean hasNext(); 当按照前进的方向遍历一个数组时，如果当前列表迭代器还有其他元素时返回true。（换句话说，如果next()方法能返回一个元素而非抛出一个异常，则返回true）\n2. E next(); 返回列表中的下一个元素并向前移动光标位置。 可以重复调用此方法以遍历列表，也可以将其与previous()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有下一个元素时抛出NoSuchElementException。\n3. boolean hasPrevious(); 当反向遍历列表时，如果列表迭代器还有其他元素，则返回true。（换句话说，当调用previous()时能返回一个元素而非抛出异常时，返回true）\n4. E previous(); 返回列表中的前一个元素，并将光标位置向后移动。可以重复调用此方法以向后遍历列表，也可以将其与next()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有上一个元素时抛出NoSuchElementException。"},{"id":30,"href":"/jdk8-src-note/java/util/Iterator/","title":"Iterator","parent":"util","content":" 1. boolean hasNext() 2. E next() 3. default void remove() 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 集合上的迭代器。Iterator在Java集合框架中取代Enumeration。迭代器与枚举有两个不同之处：\n迭代器允许调用者在迭代期间以明确的语义从基础集合中删除元素。 方法名已得到改进。 该接口也是Java集合框架的成员。\n1. boolean hasNext() 如果当前迭代器包含更多元素，则返回true。（换句话说，如果调用next方法将返回一个元素而不是抛出异常，则返回true。）\n2. E next() 返回当前迭代器的下一个元素，如果不存在，则抛出NoSuchElementException。\n3. default void remove() 从基础集合中移除此迭代器返回的最后一个元素（可选操作）。每次调用next方法后只能调用此方法一次。如果在进行迭代时以任何方式修改基础集合，而不是调用此方法，则此时当前迭代器的行为将变得不确定。 可以看到该方法定义中有default关键字，其有一个默认实现，但是此默认执行仅抛出了一个UnsupportedOperationException，并无其他操作。 如果next方法还没有被调用，或者remove方法在最后一次调用next方法之后已经被调用过，则抛出IllegalStateException。\n源码如下：\ndefault void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对剩下的元素执行参数中指定的操作，直到所有元素（即剩下的所有元素）都被处理或者有异常抛出。如果指定了迭代的顺序，操作将按照迭代的顺序执行。 由action引发的异常会被转发给调用者。\n源码如下：\ndefault void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } 测试用例：\n@Test public void testIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); iterator.next(); iterator.next(); iterator.forEachRemaining(System.out::println); } 输出：\n3 4 5 ","description":"1. boolean hasNext() 2. E next() 3. default void remove() 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 集合上的迭代器。Iterator在Java集合框架中取代Enumeration。迭代器与枚举有两个不同之处：\n迭代器允许调用者在迭代期间以明确的语义从基础集合中删除元素。 方法名已得到改进。 该接口也是Java集合框架的成员。\n1. boolean hasNext() 如果当前迭代器包含更多元素，则返回true。（换句话说，如果调用next方法将返回一个元素而不是抛出异常，则返回true。）\n2. E next() 返回当前迭代器的下一个元素，如果不存在，则抛出NoSuchElementException。\n3. default void remove() 从基础集合中移除此迭代器返回的最后一个元素（可选操作）。每次调用next方法后只能调用此方法一次。如果在进行迭代时以任何方式修改基础集合，而不是调用此方法，则此时当前迭代器的行为将变得不确定。 可以看到该方法定义中有default关键字，其有一个默认实现，但是此默认执行仅抛出了一个UnsupportedOperationException，并无其他操作。 如果next方法还没有被调用，或者remove方法在最后一次调用next方法之后已经被调用过，则抛出IllegalStateException。\n源码如下：\ndefault void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 对剩下的元素执行参数中指定的操作，直到所有元素（即剩下的所有元素）都被处理或者有异常抛出。如果指定了迭代的顺序，操作将按照迭代的顺序执行。 由action引发的异常会被转发给调用者。\n源码如下：\ndefault void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } 测试用例：\n@Test public void testIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list."},{"id":31,"href":"/jdk8-src-note/java/util/AbstractCollection/","title":"AbstractCollection","parent":"util","content":" 1. protected AbstractCollection() 2. public abstract Iterator\u0026lt;E\u0026gt; iterator(); 3. public abstract int size(); 4. public boolean isEmpty() 5. public boolean contains(Object o) 6. public Object[] toArray() 7. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 9. private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator it) 10. private static int hugeCapacity(int minCapacity) 11. public boolean add(E e) 12. public boolean remove(Object o) 13. public boolean containsAll(Collection c) 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 15. public boolean removeAll(Collection c) 16. public boolean retainAll(Collection c) 17. public void clear() 18. public String toString() 此类提供了Collection接口的基本实现，以最大程度地减少实现此接口所需的工作。\n要实现一个不可修改的集合，编程者只需扩展此类并为iterator和size方法提供实现。 （iterator方法返回的迭代器必须实现hasNext和next。）\n要实现一个可修改的集合，编程者必须另外重写此类的add方法（否则将抛出UnsupportedOperationException），并且iterator方法返回的迭代器必须另外实现其remove方法。\n按Collection照接口规范中的建议，程序员通常应提供void（无参数）的Collection构造函数。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合有更有效的实现，则可以重写这些方法中的每一个。\n该类是Java集合框架中的一员。\n1. protected AbstractCollection() 唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractCollection() { } 2. public abstract Iterator\u0026lt;E\u0026gt; iterator(); 抽象方法，返回此集合中所包含元素的迭代器。\n3. public abstract int size(); 抽象方法，返回此集合所包含的元素数量。\n4. public boolean isEmpty() 判断当前集合是否为空，底层是通过调用size()获取当前集合的元素数量，然后判断元素数量是否为0。\n源码如下：\npublic boolean isEmpty() { return size() == 0; } 5. public boolean contains(Object o) 此实现对集合中的元素进行迭代，依次检查每个元素是否与参数中给定的元素相等。\n使用该集合的迭代器遍历当前集合，如果参数中给定的参数o为null，则判断当前集合中是否存在为null的元素。如果参数中给定的参数不为null，则通过equals判断当前集合中是否存在和给定元素o相等的元素。\n源码如下：\npublic boolean contains(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false; } 6. public Object[] toArray() 此实现返回一个数组，该数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组连续存在，从索引0开始。返回数组的长度等于迭代器返回的元素数（即使此集合的大小在迭代过程中发生了变化，如果该集合允许在迭代过程中进行并发修改，就可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\npublic Object[] toArray() { // Estimate size of array; be prepared to see more or fewer elements // 声明一个数组，大小为当前集合的大小（实际元素可能会多也可能会少） Object[] r = new Object[size()]; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，截止索引为当前集合的元素个数减1 for (int i = 0; i \u0026lt; r.length; i++) { // 如果未遍历完却发现迭代器已迭代至末尾了，说明元素比期望的要少，此时也不报错，而是复制一个数组返回 if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); } // 如果遍历完成，但迭代器仍未至末尾，此时调用finishToArray方法重新分配数组并完成剩余元素的填充 return it.hasNext() ? finishToArray(r, it) : r; } 7. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 此实现返回一个数组，此数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组中连续存在，从索引0开始。如果迭代器返回的元素数量太多而无法容纳到指定的数组中，那么元素也会以新分配数组的形式返回，其长度等于迭代器返回的元素数量，即使此集合的大小发生变化（如果在迭代过程中集合允许并发修改，则可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T[] toArray(T[] a) { // Estimate size of array; be prepared to see more or fewer elements int size = size(); // 声明一个数组r，若指定数组a的容量大于等于集合的元素个数，说明数组a可以容纳当前集合的所有元素，此时r取指定的数组a // 否则，说明指定的数组a不足以容纳当前列表的所有元素，此时重新分配一个容量为当前集合元素个数的数组，并赋值给r T[] r = a.length \u0026gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历集合 for (int i = 0; i \u0026lt; r.length; i++) { // 未遍历结束，但迭代器已至末尾，说明集合的元素在toArray过程中变少了 if (! it.hasNext()) { // fewer elements than expected if (a == r) { // 如果数组r就是指定的数组a，则此处第i个元素置为null r[i] = null; // null-terminate } else if (a.length \u0026lt; i) { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a // 如果数组a的长度小于此处i，则复制一个数组返回 return Arrays.copyOf(r, i); } else { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a，且a的长度大于等于i，此时进行数组复制，把r复制给a System.arraycopy(r, 0, a, 0, i); if (a.length \u0026gt; i) { // 如果a的长度大于i，则i位置的元素置为null a[i] = null; } } // 返回数组a return a; } r[i] = (T)it.next(); } // more elements than expected // 如果遍历完成，发现仍未至迭代器的末尾，则调用finishToArray重新分配数组并完成剩余元素的填充 return it.hasNext() ? finishToArray(r, it) : r; } 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 可分配的最大数组大小。一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出虚拟机限制。\n9. private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator it) 当迭代器返回的元素比预期的多时，在toArray中重新分配正在使用的数组，并完成从迭代器中填充它的操作。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it) { int i = r.length; while (it.hasNext()) { int cap = r.length; // 当指定数组的大小等于当前需要存放元素的数组索引时，进行扩容 if (i == cap) { int newCap = cap + (cap \u0026gt;\u0026gt; 1) + 1; // overflow-conscious code if (newCap - MAX_ARRAY_SIZE \u0026gt; 0) newCap = hugeCapacity(cap + 1); r = Arrays.copyOf(r, newCap); } // 在数组的i索引位置放置当前遍历到的元素，然后i加1 r[i++] = (T)it.next(); } // trim if overallocated // 如果重新分配后数组长度过长，则进行数组复制以实现trim效果 return (i == r.length) ? r : Arrays.copyOf(r, i); } 10. private static int hugeCapacity(int minCapacity) 获取数组的最大容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { // 负数是不可以的，直接抛出异常 if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError (\u0026#34;Required array size too large\u0026#34;); // 如果最小容量需求大于集合所允许的最大数组容量，则此时取当前虚拟机所支持的Integer最大值 // 否则就取集合所允许的最大数组容量 return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 11. public boolean add(E e) 该方法的默认实现为抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { throw new UnsupportedOperationException(); } 12. public boolean remove(Object o) 此实现遍历集合以查找指定的元素。如果找到该元素，则使用迭代器的remove方法从集合中删除该元素。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合包含指定的对象，则此实现将引发UnsupportedOperationException。\n源码如下：\npublic boolean remove(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); // 当指定元素为null时，遍历集合，对每个元素执行 “== null”的判断 // 否则，使用equals方法判断，找到对应对象后，使用迭代器的remove方法删除 // 从此实现上看，仅删除第一个命中的元素，删除后即返回true if (o==null) { while (it.hasNext()) { if (it.next()==null) { it.remove(); return true; } } } else { while (it.hasNext()) { if (o.equals(it.next())) { it.remove(); return true; } } } return false; } 13. public boolean containsAll(Collection c) 此实现将遍历给定的集合，依次检查每个元素以查看其是否包含在此集合中。如果所有元素都包含，则返回true，否则返回false。\n源码如下：\npublic boolean containsAll(Collection\u0026lt;?\u0026gt; c) { // 遍历指定集合c，然后调用contains方法判断每一个迭代到的元素是否存在于当前集合中 // 发现有一个不包含则直接返回false for (Object e : c) if (!contains(e)) return false; return true; } 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 此实现遍历给定的集合，并将迭代器返回的每个对象依次添加到此集合。\n请注意，除非重写add（假定指定的集合为非空），否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { boolean modified = false; // 遍历指定的集合c for (E e : c) // 调用add方法添加元素到当前集合 if (add(e)) modified = true; return modified; } 15. public boolean removeAll(Collection c) 此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合的一个或多个元素，则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean removeAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;?\u0026gt; it = iterator(); // 遍历当前集合 while (it.hasNext()) { // 使用指定集合的contains方法判断是否包含当前迭代到的元素 if (c.contains(it.next())) { // 如果包含，使用迭代器的remove方法删除 it.remove(); modified = true; } } return modified; } 16. public boolean retainAll(Collection c) 此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果没有包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合中一个或多个不存在的元素，则此实现将抛出UnsupportedOperationException。\n总体来说，该方法执行后，当前集合中仅剩余当前集合和指定集合中均存在的元素。\n源码如下：\npublic boolean retainAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合 while (it.hasNext()) { // 如果指定集合中不包含当前迭代到的元素，则将其删除 if (!c.contains(it.next())) { it.remove(); modified = true; } } return modified; } 17. public void clear() 此实现遍历当前集合，并使用Iterator.remove操作删除每个元素。大多数实现可能会选择重写此方法以提高效率。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合非空，则此方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，使用迭代器删除每个元素 while (it.hasNext()) { it.next(); it.remove(); } } 18. public String toString() 返回此集合的字符串表示形式。字符串表示形式包括一个集合元素的列表，这些元素按其迭代器返回的顺序排列，并括在方括号（[]）中。相邻元素由字符,（逗号和空格）分隔。元素通过String的valueOf(Object obj)方法转换为字符串。\n源码如下：\npublic String toString() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 如果当前集合为空，则返回[] if (! it.hasNext()) return \u0026#34;[]\u0026#34;; // 使用StringBuilder进行拼接 StringBuilder sb = new StringBuilder(); sb.append(\u0026#39;[\u0026#39;); for (;;) { E e = it.next(); // 如果当前元素就是当前集合，则此时使用“(this Collection)”来展示 sb.append(e == this ? \u0026#34;(this Collection)\u0026#34; : e); if (! it.hasNext()) return sb.append(\u0026#39;]\u0026#39;).toString(); sb.append(\u0026#39;,\u0026#39;).append(\u0026#39; \u0026#39;); } } ","description":"1. protected AbstractCollection() 2. public abstract Iterator\u0026lt;E\u0026gt; iterator(); 3. public abstract int size(); 4. public boolean isEmpty() 5. public boolean contains(Object o) 6. public Object[] toArray() 7. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 9. private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator it) 10. private static int hugeCapacity(int minCapacity) 11. public boolean add(E e) 12. public boolean remove(Object o) 13. public boolean containsAll(Collection c) 14."},{"id":32,"href":"/jdk8-src-note/java/util/Collection/","title":"Collection","parent":"util","content":" 1. int size() 2. boolean isEmpty() 3. boolean contains(Object o) 4. Iterator\u0026lt;E\u0026gt; iterator() 5. Object[] toArray() 6. \u0026lt;T\u0026gt; T[] toArray(T[] a) 7. boolean add(E e) 8. boolean remove(Object o) 9. boolean containsAll(Collection c) 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 11. boolean removeAll(Collection c) 12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 13. boolean retainAll(Collection c) 14. void clear() 15. boolean equals(Object o) 16. int hashCode() 17. default Spliterator\u0026lt;E\u0026gt; spliterator() 18. default Stream\u0026lt;E\u0026gt; stream() 19. default Stream\u0026lt;E\u0026gt; parallelStream() Collection接口是集合层次结构中的根接口。集合表示一组对象，每个对象称为元素。有些集合允许重复元素，有些则不允许。有些集合是有序的，有些是无序的。\nJDK没有提供该接口的任何直接实现：它提供了更具体的子接口的实现，如Set和List。此接口通常用于传递集合并在需要最大通用性的地方操作它们。\nBags或multiset（可能包含重复元素的无序集合）应该直接实现这个接口。\n所有通用的Collection实现类（通常通过其某个子接口间接实现Collection）应提供两个“标准”的构造函数：void（无参数）构造函数（该构造函数创建一个空集合），以及一个具有单个类型为Collection的参数的构造函数，该构造函数将创建一个新集合，新集合的元素与参数中指定的Collection的元素相同。实际上，后一个构造函数允许用户复制任何集合，从而生成所需类型的等效集合。但是无法强制执行此约定（因为接口不能包含构造函数），但是Java平台库中的所有通用Collection实现都遵循此约定。\n该接口中包含一些具有“破坏性”的方法，也就是这些方法在被调用时操作集合，但该集合并不支持该操作，此时这些方法将抛出UnsupportedOperationException。在这种情况下，如果调用对集合没有影响，则这些方法可能（但不是必需）抛出UnsupportedOperationException。例如，对不可修改的集合调用addAll方法可能会（但并不一定）引发异常（如果要添加的集合为空的话）。\n一些集合实现对它们可能包含的元素有所限制。例如，某些实现禁止空元素，而有些实现对其元素类型有限制。尝试添加不匹配的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询集合中不匹配的元素是否存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些实现将表现出后者。更普遍的是，尝试对不匹配的元素进行操作，该操作的完成不会将不合格元素插入集合中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n同步策略是由每个集合自己决定的。在没有强有力保证的实现中，调用另一个线程正在改变的集合上的任何方法都可能导致未知的行为；这包括直接调用，将集合传递给可能执行调用的方法，以及使用现有的迭代器检查集合。\n集合框架接口中的许多方法都是根据Object的equals方法定义的。例如，contains方法的规范中说：“当且仅当此集合包含至少一个元素e满足(o==null ? e==null : o.equals(e))时，返回true”。此规范不应解释为暗示使用非空参数o调用Collection.contains时将导致对任何元素e都会调用o.equals(e)。各实现可以自由地进行优化，从而避免equals调用，例如，首先比较两个元素的哈希码。（Object的hashCode()规范保证哈希码不相等的两个对象不能相等。）更普遍的说，只要实现者认为合适，各种集合框架接口的实现都可以自由利用基础Object方法的指定行为。\n一些对集合执行递归遍历的操作可能会失败，但对于集合直接或间接包含其自身的自引用实例除外，包括clone()、equals()、hashCode()、toString()方法。实现类可以选择性地处理自引用场景，但是大多数当前的实现都没有这样做。\n该接口是Java集合框架的成员接口。\n默认的方法实现（继承的或其他）不应用任何同步协议。如果一个集合实现有一个特定的同步协议，那么它必须覆盖默认实现来应用该协议。\n1. int size() 返回当前集合内元素的数量。如果数量超过Integer.MAX_VALUE则返回Integer.MAX_VALUE。\n2. boolean isEmpty() 如果当前集合内没有元素，则返回true。\n3. boolean contains(Object o) 当集合包含指定的元素时返回true。更准确的说，当且仅当集合中至少存在一个元素e能够满足(o==null ? e==null : o.equals(e))时返回true。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素o为空，则抛出NullPointerException。\n4. Iterator\u0026lt;E\u0026gt; iterator() 返回此集合中元素的迭代器。没有关于元素返回顺序的保证（除非此集合是某个提供保证的类的实例）。\n5. Object[] toArray() 返回一个包含此集合中所有元素的数组。如果此集合保证其迭代器返回其元素的顺序，则此方法必须按相同的顺序返回元素。\n返回的数组将是“安全的”，因为此集合不维护对其的引用。 （换句话说，即使此集合是基于数组的，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的api和基于集合的api之间的桥梁。\n6. \u0026lt;T\u0026gt; T[] toArray(T[] a) 返回一个数组，该数组包含此集合中的所有元素。返回数组的运行时类型是指定数组的运行时类型。如果集合符合指定的数组，则在其中返回集合。否则，将使用指定数组的运行时类型和此集合的大小分配新数组。\n如果指定的数组能够容纳集合的所有元素并有剩余空间（即数组中的容量大于集合），则紧接集合结束后的数组中的元素设置为null。（如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n如果此集合保证其迭代器返回元素的顺序，则此方法必须按相同的顺序返回元素。\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的集合。以下代码可用于将集合转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n如果指定数组的运行时类型不是此集合中每个元素的运行时类型的超类型，则抛出ArrayStoreException。\n如果参数中指定的数组a为null，则抛出NullPointerException。\n7. boolean add(E e) 确保此集合包含指定的元素（可选操作）。如果此集合由于调用该方法而更改，则返回true。 （如果此集合不允许重复并且已经包含指定的元素，则返回false。）\n支持此操作的集合可能会对可以添加到此集合的元素加以限制。特别是，某些集合将拒绝添加null元素，而其他集合将对可能添加的元素类型施加限制。集合类应在其文档中明确指定对可以添加哪些元素的限制。\n如果某个集合由于除了已经包含该元素以外的其他原因拒绝添加特定元素，则它必须抛出异常（而不是返回false）。这保留了在此调用返回后集合始终包含指定元素的不变性。\n如果当前集合不支持add操作，则抛出UnsupportedOperationException。\n如果指定元素的类阻止将其添加到此集合中，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n如果元素的某些属性阻止将其添加到此集合中，则抛出IllegalArgumentException。\n如果由于插入限制当前无法添加该元素，则抛出IllegalStateException。\n8. boolean remove(Object o) 如果指定的元素在此集合中存在，则从此集合中删除它（可选操作）。\n更正式地讲，如果存在当前集合中存在一个或多个元素e可以满足(o==null ? e==null : o.equals(e))，则删除该元素e（注：此处源码中明确指出是满足条件的元素全部删除，还是删除其中的一个，它只是说：removes an element e such that ···）。如果此集合包含指定的元素（或者等效地，如果此集合由于调用而更改），则返回true。\n如果当前集合不支持remove操作，则抛出UnsupportedOperationException。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n9. boolean containsAll(Collection c) 如果此集合包含指定集合中的所有元素，则返回true。\n如果指定集合中一个或多个元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的集合包含一个或多个null元素，并且此集合不允许null元素，则抛出NullPointerException。\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定集合中的所有元素添加到此集合中（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （这意味着如果指定的集合就是本集合，并且本集合是非空的，则此次调用的行为是不确定的。）\n11. boolean removeAll(Collection c) 删除也包含在指定集合中的所有此集合的元素（可选操作）。在此调用返回之后，此集合将不包含与指定集合相同的元素。\n12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 1.8版本的JDK中新出的方法。删除此集合中满足给定断言的所有元素。在迭代过程中或断言中引发的错误或运行时异常将中继给调用方。\n默认实现使用其iterator遍历集合的所有元素。使用Iterator的remove()方法删除每个匹配的元素。如果集合的迭代器不支持删除，则将在第一个匹配元素上抛出UnsupportedOperationException。\n源码如下：\ndefault boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); while (each.hasNext()) { // 对每个元素执行给定的断言，命中则删除该元素 if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } 13. boolean retainAll(Collection c) 只保留此集合中包含在指定集合中的元素（可选操作）。换句话说，从该集合中删除指定集合中不包含的所有元素。\n14. void clear() 从此集合中删除所有元素（可选操作）。此方法返回后，集合将为空。\n15. boolean equals(Object o) 将指定对象与此集合进行比较以判断是否相等。\n尽管Collection接口没有为Object.equals的常规规定添加任何规定，但是“直接”实现Collection接口的程序员（换句话说，创建Collection但不是Set或List的类）如果选择覆盖Object.equals的话则必须要当心。其实没有必要这样做，最简单的方法是依靠Object的实现，但是实现者可能希望实现“值比较”来代替默认的“引用比较”。（List和Set接口要求进行值比较。）\nObject.equals方法的通用规范规定，equals必须是对称的（换句话说，当且仅当b.equals(a)时a.equals(b)）。 List.equals和Set.equals的约定规定，List仅等于其他List，并且Set仅等于其他Set。因此，如果一个集合类它实现的既不是List也不是Set接口，那么当这个集合与List或Set比较时，它自定义的equals方法必须返回false。（按照这个逻辑，不可能编写一个类能够同时正确地实现List和Set接口的类。）\n16. int hashCode() 返回当前集合的hash code值。尽管Collection接口没有在Object.hashCode方法的常规约定之外添加任何规定，但编程者应注意，任何覆盖Object.equals方法的类还必须重写Object.hashCode方法，以便满足Object.hashCode方法的常规约定。特别是，c1.equals(c2)意味着c1.hashCode()==c2.hashCode()。\n17. default Spliterator\u0026lt;E\u0026gt; spliterator() 在此集合中的元素上创建一个Spliterator。\n实现中应该说明拆分器报告的特征值。如果拆分器报告Spliterator.SIZED并且该集合不包含任何元素，则就不需要报告这些特征值。\n子类应该覆盖默认的实现，以返回一个更高效的拆分器。为了保持stream()和parallelStream()方法的预期惰性行为，拆分器应该具有IMMUTABLE或CONCURRENT的特征，或者是后期绑定。\n如果这些都不可行，则覆盖的类应描述拆分器记录的绑定和结构干扰策略，并应覆盖stream()和parallelStream()方法，以使用拆分器的Supplier创建流，如：\nStream\u0026lt;E\u0026gt; s = StreamSupport.stream(() -\u0026gt; spliterator(), spliteratorCharacteristics) 这些要求确保stream()和parallelStream()方法生成的流将反映在终端流操作启动时集合的内容。\n默认实现通过集合的Iterator创建一个延迟绑定的拆分器。该拆分器继承了集合迭代器快速失败的特性。\n创建的Spliterator报告Spliterator.SIZED。\n创建的Spliterator另外还报告了Spliterator.SUBSIZED。\n如果拆分器没有覆盖任何元素，那么除了SIZED和SUBSIZED之外的其他特征值的报告，不会帮助客户端控制、专门化或简化计算。然而，这确实允许对空集合共享不可变的空拆分器实例（参见Spliterators.emptySpliterator()），并允许客户端确定这样的拆分器是否不包含元素。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, 0); } 18. default Stream\u0026lt;E\u0026gt; stream() 返回以该集合为源的顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现通过集合的Spliterator创建顺序的Stream。\n源码如下：\ndefault Stream\u0026lt;E\u0026gt; stream() { return StreamSupport.stream(spliterator(), false); } 19. default Stream\u0026lt;E\u0026gt; parallelStream() 返回以此集合为源的可能并行的Stream。此方法也允许返回顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现从集合的Spliterator创建并行的Stream。\ndefault Stream\u0026lt;E\u0026gt; parallelStream() { return StreamSupport.stream(spliterator(), true); } ","description":"1. int size() 2. boolean isEmpty() 3. boolean contains(Object o) 4. Iterator\u0026lt;E\u0026gt; iterator() 5. Object[] toArray() 6. \u0026lt;T\u0026gt; T[] toArray(T[] a) 7. boolean add(E e) 8. boolean remove(Object o) 9. boolean containsAll(Collection c) 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 11. boolean removeAll(Collection c) 12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 13. boolean retainAll(Collection c) 14. void clear() 15. boolean equals(Object o) 16. int hashCode() 17. default Spliterator\u0026lt;E\u0026gt; spliterator() 18. default Stream\u0026lt;E\u0026gt; stream() 19."},{"id":33,"href":"/jdk8-src-note/java/util/","title":"util","parent":"java","content":" AbstractCollection AbstractList AbstractMap AbstractSequentialList ArrayList Collection Deque Iterator LinkedList List ListIterator Map Queue RandomAccess Vector ","description":" AbstractCollection AbstractList AbstractMap AbstractSequentialList ArrayList Collection Deque Iterator LinkedList List ListIterator Map Queue RandomAccess Vector "},{"id":34,"href":"/jdk8-src-note/java/","title":"java","parent":"JDK8源码阅读笔记","content":" io Closeable lang AutoCloseable reflect Member nio Buffer BufferOverflowException BufferUnderflowException ByteBuffer ByteOrder InvalidMarkException ReadOnlyBufferException util AbstractCollection AbstractList AbstractMap AbstractSequentialList ArrayList Collection Deque Iterator LinkedList List ListIterator Map Queue RandomAccess Vector ","description":" io Closeable lang AutoCloseable reflect Member nio Buffer BufferOverflowException BufferUnderflowException ByteBuffer ByteOrder InvalidMarkException ReadOnlyBufferException util AbstractCollection AbstractList AbstractMap AbstractSequentialList ArrayList Collection Deque Iterator LinkedList List ListIterator Map Queue RandomAccess Vector "},{"id":35,"href":"/jdk8-src-note/java/lang/","title":"lang","parent":"java","content":" AutoCloseable reflect Member ","description":" AutoCloseable reflect Member "},{"id":36,"href":"/jdk8-src-note/categories/","title":"Categories","parent":"JDK8源码阅读笔记","content":"","description":""},{"id":37,"href":"/jdk8-src-note/tags/","title":"Tags","parent":"JDK8源码阅读笔记","content":"","description":""}]