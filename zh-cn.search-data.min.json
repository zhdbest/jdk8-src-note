[{"id":0,"href":"/jdk8-src-note/","title":"JDK8源码阅读笔记","parent":"","content":""},{"id":1,"href":"/jdk8-src-note/java/util/Vector/","title":"Vector","parent":"util","content":"  1. protected Object[] elementData; 2. protected int elementCount; 3. protected int capacityIncrement; 4. private static final long serialVersionUID = -2767605614048989439L; 5. public Vector(int initialCapacity, int capacityIncrement) 6. public Vector(int initialCapacity) 7. public Vector() 8. public Vector(Collection\u0026lt;? extends E\u0026gt; c) 9. public synchronized void copyInto(Object[] anArray) 10. public synchronized void trimToSize() 11. public synchronized void ensureCapacity(int minCapacity) 12. private void ensureCapacityHelper(int minCapacity) 13. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 14. private void grow(int minCapacity) 15. private static int hugeCapacity(int minCapacity) 16. public synchronized void setSize(int newSize) 17. public synchronized int capacity() 18. public synchronized int size() 19. public synchronized boolean isEmpty() 20. public Enumeration\u0026lt;E\u0026gt; elements() 21. public boolean contains(Object o) 22. public int indexOf(Object o) 23. public synchronized int indexOf(Object o, int index) 24. public synchronized int lastIndexOf(Object o) 25. public synchronized int lastIndexOf(Object o, int index) 26. public synchronized E elementAt(int index) 27. public synchronized E firstElement() 28. public synchronized E lastElement() 29. public synchronized void setElementAt(E obj, int index) 30. public synchronized void removeElementAt(int index) 31. public synchronized void insertElementAt(E obj, int index) 32. public synchronized void addElement(E obj) 33. public synchronized boolean removeElement(Object obj) 34. public synchronized void removeAllElements() 35. public synchronized Object clone() 36. public synchronized Object[] toArray() 37. public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a) 38. E elementData(int index) 39. public synchronized E get(int index) 40. public synchronized E set(int index, E element) 41. public synchronized boolean add(E e) 42. public boolean remove(Object o) 43. public void add(int index, E element) 44. public synchronized E remove(int index) 45. public void clear() 46. public synchronized boolean containsAll(Collection\u0026lt;?\u0026gt; c) 47. public synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 48. public synchronized boolean removeAll(Collection\u0026lt;?\u0026gt; c) 49. public synchronized boolean retainAll(Collection\u0026lt;?\u0026gt; c) 50. public synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 51. public synchronized boolean equals(Object o) 52. public synchronized int hashCode() 53. public synchronized String toString() 54. public synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 55. protected synchronized void removeRange(int fromIndex, int toIndex) 56. private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException 57. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 58. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index) 59. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator() 60. public synchronized Iterator\u0026lt;E\u0026gt; iterator() 61. private class Itr implements Iterator\u0026lt;E\u0026gt;  61.1 int cursor; 61.2 int lastRet = -1; 61.3 int expectedModCount = modCount; 61.4 public boolean hasNext() 61.5 public E next() 61.6 public void remove() 61.7 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 61.8 final void checkForComodification()   62. final class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;  62.1 ListItr(int index) 62.2 public boolean hasPrevious() 62.3 public int nextIndex() 62.4 public int previousIndex() 62.5 public E previous() 62.6 public void set(E e) 62.7 public void add(E e)   63. public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action) 64. public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 65. public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 66. public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c) 67. public Spliterator\u0026lt;E\u0026gt; spliterator() 68. static final class VectorSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt;  68.1 private final Vector\u0026lt;E\u0026gt; list; 68.2 private Object[] array; 68.3 private int index; 68.4 private int fence; 68.5 private int expectedModCount; 68.6 VectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount) 68.7 private int getFence() 68.8 public Spliterator\u0026lt;E\u0026gt; trySplit() 68.9 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 68.10 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 68.11 public long estimateSize() 68.12 public int characteristics()       Vector类实现了一个可增长的对象数组。像数组一样，它包含可以使用整数索引访问的组件。但是，Vector的大小可以根据需要增加或缩小，以在Vector创建后能够添加和删除项目。\n每个vector都尝试通过维护一个capacity和一个capacityIncrement来优化存储管理。capacity始终至少与vector大小一样大，通常它会更大，因为随着组件添加到vector中，vector的存储以块的形式增加capacityIncrement的大小。一个应用程序可以在插入大量组件之前增加一个vector的容量，这将减少增量重新分配的次数。\n此类的iterator和listIterator方法返回的迭代器是“快速失败”的：如果在创建迭代器后的任何时间对vector进行结构上的修改，除了通过迭代器自己的remove或add方法之外，迭代器将抛出一个ConcurrentModificationException。因此，面对并发修改，迭代器快速而干净地失败，而不是在未来不确定的时间冒任意、不确定行为的风险。elements方法返回的Enumeration不是快速失败的。\n请注意，无法保证迭代器的快速失败行为，因为一般而言，在存在非同步地并发修改的情况下不可能做出任何严格保证。快速失败的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写一个依赖于这个异常来保证其正确性的程序是错误的：迭代器的快速失败行为应该只用于检测错误。\n从 Java 2 平台 v1.2 开始，该类经过改造实现了List接口，使其成为“Java 集合框架”的成员。与新的集合实现不同，Vector是同步的。如果不需要线程安全的实现，建议使用ArrayList代替Vector。\n 1. protected Object[] elementData;    存储vector组件的数组缓冲区。vector的容量是这个数组缓冲区的长度，并且至少足够包含vector的所有元素。\nVector中最后一个元素之后的任何数组元素都为空。\n 2. protected int elementCount;    此Vector对象中的有效组件数。组件elementData[0]到elementData[elementCount-1]是实际的条目。\n 3. protected int capacityIncrement;    当vector的大小要变得大于其容量时，vector的容量自动增加的量。如果容量增量小于或等于零，则每次需要增长时，vector的容量都会增加一倍。\n 4. private static final long serialVersionUID = -2767605614048989439L;    使用 JDK 1.0.2 中的 serialVersionUID 实现互通性。\n 5. public Vector(int initialCapacity, int capacityIncrement)    构造一个具有指定初始容量和容量增量的空vector。\n其源码如下：\npublic Vector(int initialCapacity, int capacityIncrement) { // 调用AbstractList()  super(); // 初始容量不可小于0  if (initialCapacity \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); // 初始化组件数组，也即元素数组  this.elementData = new Object[initialCapacity]; // 设定容量增量  this.capacityIncrement = capacityIncrement; }  6. public Vector(int initialCapacity)    构造一个具有指定初始容量且容量增量为零的空vector。\n源码如下：\npublic Vector(int initialCapacity) { this(initialCapacity, 0); }  7. public Vector()    构造一个空vector，使其内部数据数组的大小为10并且其标准容量增量为零。\n源码如下：\npublic Vector() { this(10); }  8. public Vector(Collection\u0026lt;? extends E\u0026gt; c)    构造一个包含指定集合元素的vector，按照集合的迭代器返回的顺序。\n源码如下：\npublic Vector(Collection\u0026lt;? extends E\u0026gt; c) { // 将参数中给定集合转化为数组  Object[] a = c.toArray(); // 数组长度即本Vector实例的元素数量  elementCount = a.length; // 如果指定集合是ArrayList，则数组a可直接赋值给本Vector实例用于存储数据的数组  if (c.getClass() == ArrayList.class) { elementData = a; } else { // 非ArrayList，可能与Vector实现差异较大，此处进行数组复制  elementData = Arrays.copyOf(a, elementCount, Object[].class); } }  9. public synchronized void copyInto(Object[] anArray)    将此vector的组件（即元素）复制到指定的数组中。此vector中索引k处的项目被复制到anArray的k位置。\n源码如下：\npublic synchronized void copyInto(Object[] anArray) { System.arraycopy(elementData, 0, anArray, 0, elementCount); }  10. public synchronized void trimToSize()    将此vector的容量修剪为vector的当前大小。如果此vector的容量大于其当前大小，则通过将其内部数据数组替换为较小的数组，将容量更改为等于大小，该数组保存在字段elementData中。应用程序可以使用此操作来最小化vector的存储。\npublic synchronized void trimToSize() { // 增加修改次数  modCount++; // 取出当前数组长度  int oldCapacity = elementData.length; // 如果当前元素个数 小于 当前数组长度  if (elementCount \u0026lt; oldCapacity) { // 复制当前数组存放了数据的部分，也即丢弃数组后面未存放元素的部分  elementData = Arrays.copyOf(elementData, elementCount); } }  11. public synchronized void ensureCapacity(int minCapacity)    如有必要，增加此vector的容量，以确保它至少可以容纳由最小容量参数指定的组件数量。\n如果此vector的当前容量小于minCapacity，则通过将其保存在字段elementData中的内部数据数组替换为更大的数组来增加其容量。新数据数组的大小为旧大小加上capacityIncrement，除非capacityIncrement的值小于或等于0，在这种情况下，新容量将是旧容量的两倍；但如果这个新大小仍然小于minCapacity，那么新容量将是minCapacity。\n源码如下：\npublic synchronized void ensureCapacity(int minCapacity) { if (minCapacity \u0026gt; 0) { // 增加修改次数  modCount++; // 调用确保容量方法的非同步版本  ensureCapacityHelper(minCapacity); } }  12. private void ensureCapacityHelper(int minCapacity)    本方法实现了ensureCapacity的非同步版本。本类中的同步方法可以在内部调用此方法以确保容量，而不会产生额外同步的成本。\n源码如下：\nprivate void ensureCapacityHelper(int minCapacity) { // overflow-conscious code \t// 如果参数中的最小容量大于当前vector存放数据的数组容量，则调用grow方法增大数组的容量  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }  13. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    要分配的数组的最大大小。\n一些 VM 在数组中保留一些头字。\n尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出 VM 限制\n 14. private void grow(int minCapacity)    增加数组elementData大小。\n源码如下：\nprivate void grow(int minCapacity) { // overflow-conscious code \t// 取出当前数组elementData的容量  int oldCapacity = elementData.length; // 如果容量增量大于0，则 新数组容量 = 旧数组容量 + 容量增量 \t// 否则， 新数组容量 = 旧数组容量 + 旧数组容量  int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); // 经上述逻辑计算出的新数组容量如果仍小于参数中指定的最小容量，则新数组容量直接取参数中的最小容量  if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; // 经上述逻辑计算出的新数组容量如果大于Vector限定的数组最大数量，则调用获取最大容量方法  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // 将elementData复制到扩容后的新数组  elementData = Arrays.copyOf(elementData, newCapacity); }  15. private static int hugeCapacity(int minCapacity)    获取巨大的容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { // 如果最小容量小于0，则抛出OutOfMemoryError  if (minCapacity \u0026lt; 0) // overflow  throw new OutOfMemoryError(); // 如果最小容量大于Vector设定的最大数组容量，则巨大容量取Integer的最大值 \t// 否则，巨大容量取Vector设定的最大数组容量  return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; }  16. public synchronized void setSize(int newSize)    设置此vector的大小。如果新大小大于当前大小，则往此vector的末尾添加null。如果新大小小于当前大小，则索引newSize位置及其之后的所有组件都将被丢弃。\n源码如下：\npublic synchronized void setSize(int newSize) { // 增加修改次数  modCount++; // 如果新大小大于当前元素个数，则调用ensureCapacityHelper确保数组容量  if (newSize \u0026gt; elementCount) { ensureCapacityHelper(newSize); } else { // 新大小小于等于当前元素个数，则遍历数组从新大小到元素个数-1位置的部分 \t// 将遍历到的每个元素都置为null  for (int i = newSize ; i \u0026lt; elementCount ; i++) { elementData[i] = null; } } // 将元素个数置为新大小  elementCount = newSize; }  17. public synchronized int capacity()    返回此vector的当前容量。\n当前容量：其内部数据数组（即此vector的elementData字段）的长度。\n源码如下：\npublic synchronized int capacity() { return elementData.length; }  18. public synchronized int size()    返回此vector中的组件数（即元素个数）。\n源码如下：\npublic synchronized int size() { return elementCount; }  19. public synchronized boolean isEmpty()    测试此vector是否没有组件。\n源码如下：\npublic synchronized boolean isEmpty() { return elementCount == 0; }  20. public Enumeration\u0026lt;E\u0026gt; elements()    返回此vector的组件的枚举。返回的Enumeration对象将生成此向量中的所有项目。生成的第一项是索引0处的项，然后是索引1处的项，依此类推。\n源码如下：\npublic Enumeration\u0026lt;E\u0026gt; elements() { // 因为Enumeration是一个接口，所以此处返回的是一个它的匿名内部类 \t// 该接口有两个方法：hasMoreElements()、nextElement()  return new Enumeration\u0026lt;E\u0026gt;() { // 从0开始计数，此处count可以理解为游标  int count = 0; // 判断是否还有其他元素  public boolean hasMoreElements() { // 判断当前游标是否小于元素个数  return count \u0026lt; elementCount; } // 获取下一个元素  public E nextElement() { synchronized (Vector.this) { if (count \u0026lt; elementCount) { // 如果当前游标小于当前元素个数，则返回当前游标位置的元素  return elementData(count++); } } throw new NoSuchElementException(\u0026#34;Vector Enumeration\u0026#34;); } }; }  21. public boolean contains(Object o)    如果此vector包含指定的元素，则返回true。更正式地说，当且仅当此vector包含至少一个元素e使得(o==null ? e==null : o.equals(e))时才返回true。\n源码如下：\npublic boolean contains(Object o) { // 调用indexOf方法判断指定元素在数组中的索引位置是否大于等于0  return indexOf(o, 0) \u0026gt;= 0; }  22. public int indexOf(Object o)    返回指定元素在此vector中第一次出现的索引，如果此向量不包含该元素，则返回-1。更正式地说，返回最小索引i使得(o==null ? get(i)==null : o.equals(get(i)))，或者如果有是没有这样的索引则返回-1。\n源码如下：\npublic int indexOf(Object o) { // 从索引位置0处开始匹配  return indexOf(o, 0); }  23. public synchronized int indexOf(Object o, int index)    返回此vector中指定元素第一次出现的索引，从index开始搜索，如果未找到该元素，则返回-1。更正式地说，返回最小索引i使得(i \u0026gt;= index \u0026amp;\u0026amp; (o==null ? get(i)==null : o.equals(get(i))))，如果没有这样的索引，则返回-1。\n源码如下：\npublic synchronized int indexOf(Object o, int index) { if (o == null) { // 指定对象为null，则遍历数组找到元素为null的索引位置  for (int i = index ; i \u0026lt; elementCount ; i++) if (elementData[i]==null) return i; } else { // 指定对象不为null，则遍历数组找到equals为true的元素的索引位置  for (int i = index ; i \u0026lt; elementCount ; i++) if (o.equals(elementData[i])) return i; } // 找不到则返回-1  return -1; }  24. public synchronized int lastIndexOf(Object o)    返回指定元素在此vector中最后一次出现的索引，如果此vector不包含该元素，则返回-1。更正式地，返回最大索引i使得(o==null ? get(i)==null : o.equals(get(i)))，或者如果没有这样的索引则返回-1。\n源码如下：\npublic synchronized int lastIndexOf(Object o) { return lastIndexOf(o, elementCount-1); }  25. public synchronized int lastIndexOf(Object o, int index)    返回指定元素在此vector中最后一次出现的索引，从index开始向前搜索（即向索引变小的方向搜索），如果未找到该元素，则返回-1。更正式地说，返回最高索引i使得(i \u0026lt;= index \u0026amp;\u0026amp; (o==null ? get(i)==null : o.equals(get(i))))，如果没有这样的索引则返回-1。\n源码如下：\npublic synchronized int lastIndexOf(Object o, int index) { // 检查开始索引是否大于等于元素个数，如果是则抛出数组越界异常  if (index \u0026gt;= elementCount) throw new IndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34;+ elementCount); // 和indexOf方法类似，指定对象是否为空走不同的逻辑  if (o == null) { // 从index位置开始，一直往前遍历（索引变小的方向）  for (int i = index; i \u0026gt;= 0; i--) // 命中即返回  if (elementData[i]==null) return i; } else { for (int i = index; i \u0026gt;= 0; i--) if (o.equals(elementData[i])) return i; } // 未找到，则返回-1  return -1; }  26. public synchronized E elementAt(int index)    返回指定索引处的组件（即元素）。\n此方法在功能上与get(int)方法相同（get(int)是List接口的方法之一）。\n源码如下：\npublic synchronized E elementAt(int index) { // 数组越界检查  if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } // 调用elementData方法  return elementData(index); }  27. public synchronized E firstElement()    返回此vector的第一个组件（索引0处的项目）。\n源码如下：\npublic synchronized E firstElement() { if (elementCount == 0) { throw new NoSuchElementException(); } // 没有特殊逻辑，就是从数组中根据索引0取数据  return elementData(0); }  28. public synchronized E lastElement()    返回vector的最后一个组件。\n源码如下：\npublic synchronized E lastElement() { if (elementCount == 0) { throw new NoSuchElementException(); } // 返回elementData数组中最后一个元素，对应索引位置为：元素个数 - 1  return elementData(elementCount - 1); }  29. public synchronized void setElementAt(E obj, int index)    将此vector的指定index处的组件设置为指定对象，该位置之前的组件将被丢弃。\n该索引必须大于或等于0且小于vector的当前大小。\n此方法在功能上与set(int, E)方法（它是List接口的方法之一）相同。请注意，set方法颠倒了参数的顺序，以更紧密地匹配数组用法。另请注意，set方法会返回存储在指定位置的旧值。\n源码如下：\npublic synchronized void setElementAt(E obj, int index) { if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } elementData[index] = obj; }  30. public synchronized void removeElementAt(int index)    删除指定索引处的组件。此vector中索引大于或等于指定index的每个组件向前移动，使其索引比之前的值小 1。这个vector的大小减少1。\n索引必须是大于或等于0且小于vector的当前大小的值。\n此方法在功能上与remove(int)方法（它是List接口的一部分）相同。需要注意，remove方法会返回存储在指定位置的旧值。\n源码如下：\npublic synchronized void removeElementAt(int index) { // 增加修改次数  modCount++; // 校验指定的索引index是否出于合理区间（即：大于等于0且小于元素个数）  if (index \u0026gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt;= \u0026#34; + elementCount); } else if (index \u0026lt; 0) { throw new ArrayIndexOutOfBoundsException(index); } // 计算出所需要异动位置的元素个数  int j = elementCount - index - 1; if (j \u0026gt; 0) { // 进行数组复制 \t// 将elementData数组的“index+1”及之后的元素复制到elementData数组的“index”处及之后的位置 \t// 复制元素的个数为j  System.arraycopy(elementData, index + 1, elementData, index, j); } // 元素个数减一  elementCount--; // 将末尾的元素置为null，以使其可被垃圾回收  elementData[elementCount] = null; /* to let gc do its work */ }  31. public synchronized void insertElementAt(E obj, int index)    将指定对象作为组件插入此vector中指定index处。此vector中索引大于或等于指定index的每个组件向后移动，使其索引比之前的值大 1。\n索引必须是大于等于0且小于等于vector的当前大小的值。（如果索引等于vector的当前大小，则新元素将追加到当前vector。）\n此方法在功能上与add(int, E)方法（它是List接口的一部分）相同。需要注意，add方法颠倒了参数的顺序，以更接近数组用法。\n源码如下：\npublic synchronized void insertElementAt(E obj, int index) { // 修改次数加1  modCount++; // 校验指定的索引index是否在合理的区间内  if (index \u0026gt; elementCount) { throw new ArrayIndexOutOfBoundsException(index + \u0026#34; \u0026gt; \u0026#34; + elementCount); } // 确保vector容量足够  ensureCapacityHelper(elementCount + 1); // 执行数组复制，将elementData数组index及之后的元素复制到elementData的index+1处及之后的位置 \t// 复制的元素个数为元素个数-指定索引index  System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); // 此时给index位置替换元素为指定的元素obj  elementData[index] = obj; // 元素个数加1  elementCount++; }  32. public synchronized void addElement(E obj)    将指定的组件添加到此vector的末尾，将其大小增加 1。如果该vector的大小变得大于其容量，则该vector的容量会增加。\n此方法在功能上与add(E)方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized void addElement(E obj) { // 修改次数加1  modCount++; // 确保容量足够（不够的话会进行扩容）  ensureCapacityHelper(elementCount + 1); // 将指定元素拼接到vector的末尾  elementData[elementCount++] = obj; }  33. public synchronized boolean removeElement(Object obj)    从此vector中删除指定参数的第一次（最低索引）出现。如果在此vector中找到对象，则向量中索引大于或等于该指定对象索引的每个元素将向前移动，使其索引比之前的值减1。\n此方法在功能上与remove(Object)方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized boolean removeElement(Object obj) { // 修改次数加1  modCount++; // 找到指定元素的索引位置（最小的那个）  int i = indexOf(obj); // 如果找到了，则删除并返回true，否则返回false  if (i \u0026gt;= 0) { // 删除指定索引位置的元素  removeElementAt(i); return true; } return false; }  34. public synchronized void removeAllElements()    删除此vector中的所有组件并将其大小设置为零。\n此方法在功能上与clear方法（它是List接口的一部分）相同。\n源码如下：\npublic synchronized void removeAllElements() { // 修改次数加1  modCount++; // Let gc do its work \t// 遍历数组，将所有元素置为null，以使其可被垃圾回收  for (int i = 0; i \u0026lt; elementCount; i++) elementData[i] = null; // 将元素个数置为0  elementCount = 0; }  35. public synchronized Object clone()    返回此vector的克隆。该副本将包含对内部数据数组副本的引用，而不是对这个Vector对象的原始内部数据数组的引用。\n源码如下：\npublic synchronized Object clone() { try { // 调用Object的clone方法获取一个Vector对象，但此时持有元素的数据数组未被复制  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Vector\u0026lt;E\u0026gt; v = (Vector\u0026lt;E\u0026gt;) super.clone(); // 将持有元素的数据数组复制一份，并赋值给上面新得到的Vector对象  v.elementData = Arrays.copyOf(elementData, elementCount); // 修改次数赋值为0  v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn\u0026#39;t happen, since we are Cloneable  throw new InternalError(e); } }  36. public synchronized Object[] toArray()    以正确的顺序返回包含此Vector中所有元素的数组。\n源码如下：\npublic synchronized Object[] toArray() { // 返回的是内部数据数组的副本  return Arrays.copyOf(elementData, elementCount); }  37. public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a)    以正确的顺序返回包含此Vector中所有元素的数组；返回数组的运行时类型是指定数组的类型。如果Vector适合指定的数组，则在其中返回。否则，将使用指定数组的运行时类型和此Vector的大小分配一个新数组。\n如果Vector适合指定的数组并有剩余空间（即，该数组的元素比Vector多），则紧跟Vector末尾的数组中的元素将设置为null。（如果调用者知道Vector不包含任何空元素，这对于确定Vector的长度很有用。）\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized \u0026lt;T\u0026gt; T[] toArray(T[] a) { // 如果指定的数组a的大小小于当前Vector对象的元素个数，则直接数组复制到一个新的数组并返回  if (a.length \u0026lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 指定数组a的大小大于等于当前Vector对象的元素个数，说明其可以承载当前Vector的所有元素 \t// 将Vector对象中持有元素的数据数组复制到指定的数组a  System.arraycopy(elementData, 0, a, 0, elementCount); // 如果指定的数组a的容量大于当前Vector对象的大小，则在数组a的最后一个元素的下一个元素设置为null（也即elementCount索引位置）  if (a.length \u0026gt; elementCount) a[elementCount] = null; return a; }  38. E elementData(int index)    获取指定索引位置的元素。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) E elementData(int index) { // 直接从数组中取出指定索引位置的元素  return (E) elementData[index]; }  39. public synchronized E get(int index)    返回此Vector中指定位置的元素。\npublic synchronized E get(int index) { // 指定索引的合法性检查  if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 返回数组中指定位置的元素  return elementData(index); }  40. public synchronized E set(int index, E element)    用指定的元素替换此Vector中指定位置的元素。\n源码如下：\npublic synchronized E set(int index, E element) { // 指定索引的合法性检查  if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 取出指定索引位置的原值  E oldValue = elementData(index); // 将指定索引位置的元素替换为指定的元素  elementData[index] = element; // 返回此索引位置的原值  return oldValue; }  41. public synchronized boolean add(E e)    将指定的元素附加到此Vector的末尾。\n源码如下：\npublic synchronized boolean add(E e) { // 修改次数加1  modCount++; // 确保容量足够  ensureCapacityHelper(elementCount + 1); // 将数组的elementCount索引位置设置为指定元素e，然后将elementCount加1  elementData[elementCount++] = e; return true; }  42. public boolean remove(Object o)    移除此Vector中第一次出现的指定元素，如果Vector不包含该元素，则它保持不变。更正式地说，删除满足(o==null ? get(i)==null : o.equals(get(i)))的最低索引i的元素，（如果存在这样的元素）。\n源码如下：\npublic boolean remove(Object o) { return removeElement(o); }  43. public void add(int index, E element)    在此Vector的指定位置插入指定元素。将当前在该位置的元素（如果有）和任何后续元素向右移动（将它们的索引加一）。\n源码如下：\npublic void add(int index, E element) { insertElementAt(element, index); }  44. public synchronized E remove(int index)    移除此Vector中指定位置的元素。将任何后续元素向左移动（将它们的索引中减一）。返回从Vector中删除的元素。\n源码如下：\npublic synchronized E remove(int index) { // 修改次数加1  modCount++; // 指定索引的合法性校验  if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 取出指定索引位置的原值  E oldValue = elementData(index); // 需要移动索引位置的元素个数 = 指定索引及其后面的元素  int numMoved = elementCount - index - 1; // 需要移动索引的元素个数大于0，则通过数组复制进行批量移动  if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将元素个数减1，然后将元素个数位置的元素置为null，以使其可被垃圾回收  elementData[--elementCount] = null; // Let gc do its work  // 返回原值  return oldValue; }  45. public void clear()    从此Vector中删除所有元素。此调用返回后，Vector将为空（除非它引发异常）。\n源码如下：\npublic void clear() { removeAllElements(); }  46. public synchronized boolean containsAll(Collection\u0026lt;?\u0026gt; c)    如果此Vector包含指定Collection中的所有元素，则返回true。\n当指定的集合为空时，会抛出NullPointerException。\n源码如下：\npublic synchronized boolean containsAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的containsAll进行判断  return super.containsAll(c); }  47. public synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定Collection中的所有元素按照指定该集合的迭代器返回的顺序追加到此Vector的末尾。如果在操作进行时修改了指定的Collection，则此操作的行为将变得未知。 （这意味着如果指定的Collection是此Vector且此Vector非空，则此次调用的行为未知。）\n如果此Vector由于调用而更改，则返回true。\n源码如下：\npublic synchronized boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 修改次数加1  modCount++; // 将指定的集合转化为数组  Object[] a = c.toArray(); // 取出数组的长度  int numNew = a.length; // 确保容量足够容纳下此数组  ensureCapacityHelper(elementCount + numNew); // 将数组a复制到此Vector的最后一个元素后面  System.arraycopy(a, 0, elementData, elementCount, numNew); // 增加元素个数  elementCount += numNew; // 返回新增加的元素个数是否不为0，不为0说明有新元素添加到此Vector，返回true  return numNew != 0; }  48. public synchronized boolean removeAll(Collection\u0026lt;?\u0026gt; c)    从此Vector中删除包含在指定Collection中的所有元素。\n源码如下：\npublic synchronized boolean removeAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的removeAll方法  return super.removeAll(c); }  49. public synchronized boolean retainAll(Collection\u0026lt;?\u0026gt; c)    仅保留此Vector中包含在指定Collection中的元素。换句话说，从此Vector中删除所有未包含在指定Collection中的元素。\n源码如下：\npublic synchronized boolean retainAll(Collection\u0026lt;?\u0026gt; c) { // 调用AbstractCollection的retainAll方法  return super.retainAll(c); }  50. public synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    将指定Collection中的所有元素插入此Vector的指定位置。将当前在该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的迭代器返回的顺序出现在Vector中。\npublic synchronized boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 增加修改次数  modCount++; // 指定索引的合法性校验，大于等于0 且 小于等于元素个数  if (index \u0026lt; 0 || index \u0026gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); // 将指定集合转化为数组  Object[] a = c.toArray(); // 数组大小  int numNew = a.length; // 确保此Vector的容量足够容纳下指定集合的所有元素  ensureCapacityHelper(elementCount + numNew); // 需移动索引的元素个数  int numMoved = elementCount - index; // 如果需移动索引的元素个数大于0，则执行数组复制，先往后移动这些元素  if (numMoved \u0026gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将指定集合转化的数组复制到此Vector数据数组的指定位置  System.arraycopy(a, 0, elementData, index, numNew); // 元素个数增加  elementCount += numNew; // 返回是否新增了元素至此Vector  return numNew != 0; }  51. public synchronized boolean equals(Object o)    比较指定的Object与此Vector是否相等。当且仅当指定的Object也是一个List，两个List的大小相同，并且两个List中所有对应的元素对都相等时，才返回true。（如果(e1==null ? e2==null : e1.equals(e2))，说明两个元素e1和e2相等。）换句话说, 如果两个List以相同的顺序包含相同的元素，则它们被定义为相等。\n源码如下：\npublic synchronized boolean equals(Object o) { // 调用AbstractList的equals方法  return super.equals(o); }  52. public synchronized int hashCode()    返回此Vector的哈希编码值。\n源码如下：\npublic synchronized int hashCode() { // 调用AbstractList的hashCode方法  return super.hashCode(); }  53. public synchronized String toString()    返回此Vector的字符串表示形式，其中包含每个元素的字符串表示形式。\n源码如下：\npublic synchronized String toString() { // 调用AbstractCollection的toString方法  return super.toString(); }  54. public synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    返回此List中的fromIndex(包含)和toIndex(不包含)之间部分的视图。 （如果fromIndex和toIndex相等，则返回的List为空。）返回的List基于此List，因此返回的List中的更改会反映在此List中，反之亦然。返回的List支持此List支持的所有可选List操作。\n这种方法消除了对显式范围操作（数组通常存在的排序）的需要。通过对子列表视图而不是整个列表进行操作，任何需要列表的操作都可以用作范围操作。例如，以下惯用语法从List中删除一系列元素：list.subList(from, to).clear();，可以为indexOf和lastIndexOf构造类似的习惯用法，并且Collections类中的所有算法都可以应用于子列表。\n如果基础列表（即此列表）以除了通过返回列表以外的任何方式进行了结构修改，则此方法返回的列表的语义将变得未知。 （结构修改是那些改变List的大小，或者以其他方式扰乱它，以致正在进行的迭代可能会产生不正确的结果。）\n源码如下：\npublic synchronized List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { // 调用Collections中的方法获取一个同步的列表  return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); }  55. protected synchronized void removeRange(int fromIndex, int toIndex)    从此列表中删除所有索引在fromIndex（含）和toIndex（不含）之间的所有元素。将所有后续元素向左移动（减小其索引）。此调用减小列表的（toIndex-fromIndex）个元素。 （如果toIndex == fromIndex，则此操作无效。）\n源码如下：\nprotected synchronized void removeRange(int fromIndex, int toIndex) { // 增加修改次数  modCount++; // 计算出需移动多少个元素  int numMoved = elementCount - toIndex; // 将需移动的元素往前移动至fromIndex处  System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work \t// 此时，Vector对象的元素个数未变，因为要被删除的范围内的元素已被其后的元素覆盖 \t// 需要将移动前的索引位置的元素置为空，以促使垃圾回收 \t// 例如： \t// 原Vector：[0, 1, 2, 3, 4]，现在对其调用removeRange(1, 3)方法 \t// 数组复制后：[0, 3, 4, 3, 4] \t// 最终：[0, 3, 4]  int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; }  56. private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException    从流中加载Vector实例（即反序列化它）。此方法执行检查以确保字段的一致性。\n源码如下：\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { // 从流中读取出字段信息  ObjectInputStream.GetField gfields = in.readFields(); // 取出elementCount字段的值  int count = gfields.get(\u0026#34;elementCount\u0026#34;, 0); // 取出elementData字段的值  Object[] data = (Object[])gfields.get(\u0026#34;elementData\u0026#34;, null); // 对取出字段的合理性做校验 \t// 判断包括：count不能小于0 且 data不能为空 且count需与data的长度一致  if (count \u0026lt; 0 || data == null || count \u0026gt; data.length) { throw new StreamCorruptedException(\u0026#34;Inconsistent vector internals\u0026#34;); } // 将流中的elementCount赋值给当前Vector的elementCount  elementCount = count; // 将流中的elementData数组的拷贝赋值给当前Vector的elementData  elementData = data.clone(); }  57. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException    将Vector实例的状态保存到流中（即序列化它）。该方法执行同步以保证序列化数据的一致性。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) { // 将capacityIncrement放入流  fields.put(\u0026#34;capacityIncrement\u0026#34;, capacityIncrement); // 将elementCount放入流  fields.put(\u0026#34;elementCount\u0026#34;, elementCount); // 执行对象数组的复制  data = elementData.clone(); } // 将对象数组的拷贝放入流  fields.put(\u0026#34;elementData\u0026#34;, data); // 将上述设定写入流中  s.writeFields(); }  58. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index)    返回在此列表元素上从指定位置开始的列表迭代器（以适当的顺序）。指定的索引指示初始调用next将返回的第一个元素。初次调用previous将返回指定索引减一的元素。\n返回的列表迭代器是“快速失败”的。\n源码如下：\npublic synchronized ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 指定索引的合理性校验  if (index \u0026lt; 0 || index \u0026gt; elementCount) throw new IndexOutOfBoundsException(\u0026#34;Index: \u0026#34;+index); // 返回一个ListItr实例  return new ListItr(index); }  59. public synchronized ListIterator\u0026lt;E\u0026gt; listIterator()    返回此列表中的元素的列表迭代器（按适当顺序）。\n返回的列表迭代器是“快速失败”的。\n源码如下：\npublic synchronized ListIterator\u0026lt;E\u0026gt; listIterator() { // 返回一个从索引位置0处开始的列表迭代器实例  return new ListItr(0); }  60. public synchronized Iterator\u0026lt;E\u0026gt; iterator()    返回在此列表中元素上的迭代器（以正确的顺序）。\n返回的迭代器是“快速失败”的。\n源码如下：\npublic synchronized Iterator\u0026lt;E\u0026gt; iterator() { // 返回一个Itr实例  return new Itr(); }  61. private class Itr implements Iterator\u0026lt;E\u0026gt;    AbstractList.Itr的优化版本。\n61.1 int cursor;    要返回的下一个元素的索引，也即“游标“。\n61.2 int lastRet = -1;    返回的最后一个元素的索引，如果还没有返回过元素，则是-1。\n61.3 int expectedModCount = modCount;    期望更新次数，默认值取当前Vector的修改次数。\n61.4 public boolean hasNext()    判断是否还有下一个元素可返回，若有，则返回true。\n源码如下：\npublic boolean hasNext() { // Racy but within spec, since modifications are checked  // within or after synchronization in next/previous \t// 返回当前游标是否处于elementCount索引位置  return cursor != elementCount; } 61.5 public E next()    获取下一个元素。\n源码如下：\npublic E next() { synchronized (Vector.this) { // 检查是否有修改  checkForComodification(); int i = cursor; // 如果当前游标大于等于元素个数，则抛出无此元素异常  if (i \u0026gt;= elementCount) throw new NoSuchElementException(); // 游标后移一位（即加1）  cursor = i + 1; // 将移动前的原游标位置赋值给最后返回的索引字段，然后取出该位置的元素返回  return elementData(lastRet = i); } } 61.6 public void remove()    删除当前迭代器最近一次返回的元素。\n源码如下：\npublic void remove() { // 如果最后返回索引字段的值为-1，说明要么还未调用next获取过元素，要么已经删除过该元素  if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); // 调用Vector的remove方法删除最后返回索引位置的元素  Vector.this.remove(lastRet); // 更新期望更新次数  expectedModCount = modCount; } // 当前游标置于最近一次返回的索引处  cursor = lastRet; // 最近返回的索引字段的值置为-1  lastRet = -1; } 61.7 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对迭代器尚未遍历到的元素执行给定的操作。\n源码如下：\n@Override public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); synchronized (Vector.this) { final int size = elementCount; int i = cursor; // 如果当前游标位置大于等于元素个数，在说明没有未遍历到的元素了，此时直接返回  if (i \u0026gt;= size) { return; } // 啊，这个缩进看的真难受 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前Vector存放数据的数组  final E[] elementData = (E[]) Vector.this.elementData; // 如果当前游标位置大于等于数组长度，说明可能存在并发修改，此时将抛出异常  if (i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 遍历剩余的元素，每次都执行并发修改检查  while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { // 对遍历到的元素执行给定的操作  action.accept(elementData[i++]); } // update once at end of iteration to reduce heap write traffic \t// 在遍历结束时更新一次以减少堆写入流量  cursor = i; lastRet = i - 1; // 再执行并发修改检查  checkForComodification(); } } 61.8 final void checkForComodification()    检查是否存在并发修改。\n源码如下：\nfinal void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }  62. final class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;    AbstractList.ListItr的优化版本。\n62.1 ListItr(int index)    构建一个ListItr。\n源码如下：\nListItr(int index) { super(); cursor = index; } 62.2 public boolean hasPrevious()    判断前面是否还有元素可返回，若有，则返回true。\n源码如下：\npublic boolean hasPrevious() { // 若当前游标不在索引位置0处，说明前面还有元素可返回  return cursor != 0; } 62.3 public int nextIndex()    返回下一个元素的索引。\n源码如下：\npublic int nextIndex() { // 即返回游标位置  return cursor; } 62.4 public int previousIndex()    返回上一个元素的索引。\n源码如下：\npublic int previousIndex() { // 返回当前游标位置减1  return cursor - 1; } 62.5 public E previous()    返回上一个元素。\n源码如下：\npublic E previous() { synchronized (Vector.this) { checkForComodification(); // 取出前面一个元素的索引位置  int i = cursor - 1; // 如果得到的索引位置小于0，则说明前面没有元素了，此时抛出异常  if (i \u0026lt; 0) throw new NoSuchElementException(); // 将得到的索引位置赋值给游标  cursor = i; // 将得到的索引位置赋值给最近一次返回的元素索引字段，然后返回该位置的元素  return elementData(lastRet = i); } } 62.6 public void set(E e)    替换掉最近一次返回的元素。\n源码如下：\npublic void set(E e) { // 如果最近返回的元素索引位置为-1，说明此时没有最近一次返回的元素（也可能已被删除），则此时抛出异常  if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); // 调用Vector的set方法 替换最近一次返回的元素为指定的元素  Vector.this.set(lastRet, e); } } 62.7 public void add(E e)    在最近一次返回的元素后面添加参数中指定的元素。\n源码如下：\npublic void add(E e) { int i = cursor; synchronized (Vector.this) { checkForComodification(); // 在当前游标位置插入指定的元素e  Vector.this.add(i, e); // 更新期望更新次数  expectedModCount = modCount; } // 游标后移一位  cursor = i + 1; // 最近返回的元素索引置为-1  lastRet = -1; }  63. public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action)    对当前Vector实例的每个元素执行给定的动作。\n源码如下：\n@Override public synchronized void forEach(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) final E[] elementData = (E[]) this.elementData; final int elementCount = this.elementCount; // 遍历当前Vector的对象数组  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; elementCount; i++) { // 对每个元素执行给定动作  action.accept(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } }  64. public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter)    删除当前Vector实例中满足给定条件的元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); // 先找出要被删除的元素  // figure out which elements are to be removed  // 判断过程中抛出了任何异常，都不会导致此集合改变  // any exception thrown from the filter predicate at this stage  // will leave the collection unmodified  int removeCount = 0; final int size = elementCount; // 创建一个BitSet实例，用于记录要被删除记录的索引  final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; // 遍历当前Vector的对象数组  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前位置的元素  final E element = (E) elementData[i]; // 对当前位置的元素执行给定的条件判断  if (filter.test(element)) { // 如果判断的结果为true，则记录当前索引  removeSet.set(i); removeCount++; } } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } // shift surviving elements left over the spaces left by removed elements  // 将未删除的元素向左移  final boolean anyToRemove = removeCount \u0026gt; 0; if (anyToRemove) { // 计算出剩余后的元素个数  final int newSize = size - removeCount; // 遍历对象数组，i代表了原数组索引，j代表新数组索引  for (int i=0, j=0; (i \u0026lt; size) \u0026amp;\u0026amp; (j \u0026lt; newSize); i++, j++) { // 取出i及以后的第一个未被删除的元素的索引  i = removeSet.nextClearBit(i); // 将该未被删除的元素放置到j位置  elementData[j] = elementData[i]; } // 遍历新对象数组（指完成元素移动后的数组），将后部的元素置为null  for (int k=newSize; k \u0026lt; size; k++) { elementData[k] = null; // Let gc do its work  } elementCount = newSize; if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } return anyToRemove; }  65. public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator)    对每个元素执行给定的操作，并用得到的返回值替换该元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public synchronized void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = elementCount; // 遍历对象数组  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { // 对当前元素执行给定的操作，用计算出的结果替换当前元素  elementData[i] = operator.apply((E) elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; }  66. public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c)    使用给定的比较器对当前Vector进行排序。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public synchronized void sort(Comparator\u0026lt;? super E\u0026gt; c) { final int expectedModCount = modCount; // 使用Arrays.sort方法对对象数组进行排序  Arrays.sort((E[]) elementData, 0, elementCount, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; }  67. public Spliterator\u0026lt;E\u0026gt; spliterator()    在此列表的元素上创建一个“延迟绑定”、“快速失败”的拆分器。\n该拆分器报告的特征有：Spliterator#SIZED、Spliterator#SUBSIZED、Spliterator#ORDERED。覆盖该实现时应该记录附加的特征值的报告。\n源码如下：\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { // 返回一个VectorSpliterator实例  return new VectorSpliterator\u0026lt;\u0026gt;(this, null, 0, -1, 0); }  68. static final class VectorSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt;    Vector的拆分器，类似于ArrayList的拆分器。\n68.1 private final Vector\u0026lt;E\u0026gt; list;    当前拆分器所持有的Vector实例。\n68.2 private Object[] array;    当前拆分器所持有的Vector实例（即上面的list）的元素数据数组（elementData）。\n68.3 private int index;    当前索引，在前进和拆分时修改。\n68.4 private int fence;    在使用前一直为-1；然后是从1到最后一个索引。\n68.5 private int expectedModCount;    设置围栏（fence）时初始化该值。\n68.6 VectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount)    创建覆盖给定范围的新拆分器，也是当前拆分器类的唯一构造函数。\n源码如下：\nVectorSpliterator(Vector\u0026lt;E\u0026gt; list, Object[] array, int origin, int fence, int expectedModCount) { this.list = list; this.array = array; this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; } 68.7 private int getFence()    首次使用时初始化围栏的值。\n源码如下：\nprivate int getFence() { // initialize on first use  int hi; // 围栏小于0才执行初始化，否则直接返回当前的围栏值  if ((hi = fence) \u0026lt; 0) { synchronized(list) { // 初始化array属性，将其值置为列表的元素数据数组  array = list.elementData; // 期望修改次数置为列表的修改次数  expectedModCount = list.modCount; // 将围栏设置为列表的元素个数  hi = fence = list.elementCount; } } return hi; } 68.8 public Spliterator\u0026lt;E\u0026gt; trySplit()    执行拆分。\n源码如下：\npublic Spliterator\u0026lt;E\u0026gt; trySplit() { // 获取围栏位置、当前索引位置，然后基于这俩计算出从当前索引至围栏位置的中间位置  int hi = getFence(), lo = index, mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1; // 只有当当前索引小于上面计算出的中间位置时拆分才有意义，所以，不满足时不会进行拆分  return (lo \u0026gt;= mid) ? null : // 如果需要拆分时，创建一个新的VectorSpliterator实例，其范围为当前索引至中间位置  // 同时index = mid这一步，将当前拆分器的当前索引位置推后至中间位置  // 至此，完成拆分  new VectorSpliterator\u0026lt;E\u0026gt;(list, array, lo, index = mid, expectedModCount); } 68.9 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action)    对当前索引位置的元素执行给定的操作，然后将当前索引右移一位（即加一）。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { int i; if (action == null) throw new NullPointerException(); // 当前索引不可大于等于围栏位置  if (getFence() \u0026gt; (i = index)) { // 上面已经取出了当前索引的位置，赋值给了i，此处对当前索引进行右移操作，即加一  index = i + 1; // 对i位置的元素执行给定的操作  action.accept((E)array[i]); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } 68.10 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对当前拆分器的剩余元素依次执行给的操作。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { int i, hi; // hoist accesses and checks from loop  Vector\u0026lt;E\u0026gt; lst; Object[] a; if (action == null) throw new NullPointerException(); // list不可为空  if ((lst = list) != null) { // 如果围栏小于0，则重新获取围栏  if ((hi = fence) \u0026lt; 0) { synchronized(lst) { expectedModCount = lst.modCount; a = array = lst.elementData; hi = fence = lst.elementCount; } } else a = array; // 如果数组不为空 且 当前索引大于等于0 且 围栏位置小于等于数组长度，则遍历数组  // 此处有个隐秘操作：index = hi，这一步将当前索引位置推至围栏位置，这样就不用每遍历到一个元素就对index进行加1了  if (a != null \u0026amp;\u0026amp; (i = index) \u0026gt;= 0 \u0026amp;\u0026amp; (index = hi) \u0026lt;= a.length) { // 遍历数组，从当前索引位置到围栏位置  while (i \u0026lt; hi) // 依次执行给定操作  action.accept((E) a[i++]); if (lst.modCount == expectedModCount) return; } } throw new ConcurrentModificationException(); } 68.11 public long estimateSize()    获取剩余元素的预估个数。\n源码如下：\npublic long estimateSize() { // 围栏位置减去当前索引位置  return (long) (getFence() - index); } 68.12 public int characteristics()    获取当前拆分器报告的特征值。\n源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } "},{"id":2,"href":"/jdk8-src-note/java/util/Queue/","title":"Queue","parent":"util","content":"  1. boolean add(E e) 2. boolean offer(E e) 3. E remove() 4. E poll() 5. E element() 6. E peek()     设计用于在处理之前存放元素的集合。除了基本的Collection操作之外，队列还提供其他插入，提取和检查操作。这些方法均以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值（null或false，具体取决于操作）。插入操作的后一种形式是专门为与有限容量的Queue实现一起使用而设计的；在大多数实现中，插入操作不会失败。\nQueue方法摘要：\n    抛出异常 返回特殊值     插入 add(e) offer(e)   删除 remove() poll()   检索 element() peek()    队列通常但不一定以FIFO（先进先出）的方式对元素进行排序。例外情况包括优先级队列（根据提供的比较器对元素进行排序或元素的自然排序）和LIFO（后进先出）队列（或堆栈）。无论使用哪种排序，队列的head都是通过调用remove()或poll()来删除的元素。在FIFO队列中，所有新元素都插入到队列的尾部。其他种类的队列可能使用不同的放置规则。每个Queue实现都必须指定其排序属性。\noffer方法在可能的情况下插入一个元素，否则返回false。这与Collection.add方法不同，该方法只能通过引发未经检查的异常来表示添加元素失败。offer方法被设计用于在正常情况下（而不是在例外情况下）发生故障（例如在固定容量（或“有界”）队列中）时使用。\nremove()和poll()方法删除并返回队列的开头（head）。确切地说，从队列中删除哪个元素是队列的排序策略决定的，不同实现的实现方法不同。remove()和poll()方法的区别仅在于队列为空时它们的行为：remove()方法引发异常，而poll()方法返回null。\nelement()和peek()方法返回（但不删除）队列头（head）。\nQueue接口未定义在并发编程中常见的阻塞队列方法。这些等待元素出现或空间可用的方法在java.util.concurrent.BlockingQueue接口中进行了定义，该接口扩展了Queue接口。\nQueue实现通常不允许插入null元素，尽管某些实现（例如LinkedList）不禁止插入null。即使在允许的实现中，也不应将null插入Queue中，因为poll方法也将null用作特殊的返回值，以指示队列不包含任何元素。\nQueue实现通常不定义equals和hashCode方法基于元素的版本，而是从类Object继承基于身份的版本，因为基于元素的相等性并不总是明确定义对于具有相同元素但排序属性不同的队列。\n该接口也是Java集合框架的成员。\n 1. boolean add(E e)    如果可以立即将指定的元素插入此队列，而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出IllegalStateException。\n 2. boolean offer(E e)    如果不会违反容量限制可以立即将指定的元素插入此队列。当使用容量受限的队列时，此方法通常比add更可取，后者插入元素时只能通过引发异常来标识无法插入。\n 3. E remove()    检索并删除此队列的头。此方法与poll的不同之处仅在于，如果此队列为空，它将引发异常。\n 4. E poll()    检索并删除此队列的开头，如果此队列为空，则返回null。\n 5. E element()    检索但不删除此队列的头。此方法与peek的不同之处仅在于，如果此队列为空，它将引发异常。\n 6. E peek()    检索但不删除此队列的开头，如果此队列为空，则返回null。\n"},{"id":3,"href":"/jdk8-src-note/java/util/LinkedList/","title":"LinkedList","parent":"util","content":"  1. transient int size = 0; 2. transient Nodefirst; 3. transient Nodelast; 4. public LinkedList() 5. public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) 6. private void linkFirst(E e) 7. void linkLast(E e) 8. void linkBefore(E e, Nodesucc) 9. private E unlinkFirst(Nodef) 10. private E unlinkLast(Nodel) 11. E unlink(Nodex) 12. public E getFirst() 13. public E getLast() 14. public E removeFirst() 15. public E removeLast() 16. public void addFirst(E e) 17. public void addLast(E e) 18. public boolean contains(Object o) 19. public int size() 20. public boolean add(E e) 21. public boolean remove(Object o) 22. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 23. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 24. public void clear() 25. public E get(int index) 26. public E set(int index, E element) 27. public void add(int index, E element) 28. public E remove(int index) 29. private boolean isElementIndex(int index) 30. private boolean isPositionIndex(int index) 31. private String outOfBoundsMsg(int index) 32. private void checkElementIndex(int index) 33. private void checkPositionIndex(int index) 34. Nodenode(int index) 35. public int indexOf(Object o) 36. public int lastIndexOf(Object o) 37. public E peek() 38. public E element() 39. public E poll() 40. public E remove() 41. public boolean offer(E e) 42. public boolean offerFirst(E e) 43. public boolean offerLast(E e) 44. public E peekFirst() 45. public E peekLast() 46. public E pollFirst() 47. public E pollLast() 48. public void push(E e) 49. public E pop() 50. public boolean removeFirstOccurrence(Object o) 51. public boolean removeLastOccurrence(Object o) 52. public ListIteratorlistIterator(int index) 53. private class ListItr implements ListIterator  53.1 private NodelastReturned; 53.2 private Nodenext; 53.3 private int nextIndex; 53.4 private int expectedModCount = modCount; 53.5 ListItr(int index) 53.6 public boolean hasNext() 53.7 public E next() 53.8 public boolean hasPrevious() 53.9 public E previous() 53.10 public int nextIndex() 53.11 public int previousIndex() 53.12 public void remove() 53.13 public void set(E e) 53.14 public void add(E e) 53.15 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 53.16 final void checkForComodification()   54. private static class Node  54.1 E item; 54.2 Nodenext; 54.3 Nodeprev; 54.4 Node(Nodeprev, E element, Nodenext)   55. public IteratordescendingIterator() 56. private class DescendingIterator implements Iterator  56.1 private final ListItr itr = new ListItr(size()); 56.2 public boolean hasNext() 56.3 public E next() 56.4 public void remove()   57. private LinkedListsuperClone() 58. public Object clone() 59. public Object[] toArray() 60. public T[] toArray(T[] a) 61. private static final long serialVersionUID = 876323262645176354L; 62. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException 63. private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException 64. public Spliteratorspliterator() 65. static final class LLSpliteratorimplements Spliterator  65.1 static final int BATCH_UNIT = 1 \u0026laquo; 10; 65.2 static final int MAX_BATCH = 1 \u0026laquo; 25; 65.3 final LinkedListlist; 65.4 Nodecurrent; 65.5 int est; 65.6 int expectedModCount; 65.6 int batch; 65.7 LLSpliterator(LinkedListlist, int est, int expectedModCount) 65.8 final int getEst() 65.9 public long estimateSize() 65.10 public SpliteratortrySplit() 65.11 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 65.12 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 65.13 public int characteristics()       List和Deque接口的双向链表实现。实现所有可选的列表操作，并允许所有元素（包括null）。\n所有操作均按双向链表的预期执行。索引到列表中的操作将从列表的开头或结尾开始遍历列表，从开头遍历还是从结尾遍历主要看哪个更接近指定索引的位置。\n请注意，此实现是不同步的。如果多个线程同时访问一个链表，并且至少一个线程在结构上修改了链表，则它必须在外部保证同步。（结构修改是添加或删除一个或多个元素的任何操作；仅设置元素的值不是结构修改。）通常，通过在自然封装列表的某个对象上进行同步来完成此操作。\n如果不存在这样的对象，则应使用Collections.synchronizedList方法“包装”列表。最好在创建时完成此操作，以防止意外的不同步访问列表：\nList list = Collections.synchronizedList(new LinkedList(...)); 此类的iterator和listIterator方法返回的迭代器是“快速失败”的：如果在创建迭代器后的任何时间除了通过迭代器自己的remove或add方法之外对列表进行结构修改，则迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间内冒任意、不确定行为的风险。\n请注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。快速失败的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常以确保其正确性的程序是错误的：迭代器的快速失败行为应仅用于检测错误。\n该类是Java集合框架的成员。\n 1. transient int size = 0;    列表元素的数量。\n 2. transient Nodefirst;    指向第一个结点的指针。\n恒成立：(first == null \u0026amp;\u0026amp; last == null) || (first.prev == null \u0026amp;\u0026amp; first.item != null)\n 3. transient Nodelast;    指向最后一个结点的指针。\n恒成立：(first == null \u0026amp;\u0026amp; last == null) || (last.next == null \u0026amp;\u0026amp; last.item != null)\n 4. public LinkedList()    构造一个空列表。\n 5. public LinkedList(Collection\u0026lt;? extends E\u0026gt; c)    构造一个列表，该列表包含给定集合的元素，其顺序为该集合的迭代器返回顺序。\n先调用无参构造函数，再调用 addAll 将参数中指定集合的元素添加进当前链表。\n 6. private void linkFirst(E e)    将参数中给定的元素 e 作为当前链表的第一个元素。\n操作方法如下：\nprivate void linkFirst(E e) { // 取出链表的第一结点  final Node\u0026lt;E\u0026gt; f = first; // 构造一个新的结点，该新结点的前驱结点为null、持有元素为e、后继结点为原第一结点  final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 设置新结点为第一结点  first = newNode; if (f == null) // 原第一结点为空，也即原链表是空的，并无结点，此时也设置当前列表的最后结点为上述新结点  last = newNode; else // 原第一结点不为空，说明原链表非空，此时需调整原第一结点的前驱结点为上述结点  f.prev = newNode; size++; modCount++; }  7. void linkLast(E e)    将参数中给定的元素 e 作为当前链表的最后一个元素。\n操作方法与 linkFirst 类似，只不过该方法是在链表的尾部进行操作。\n 8. void linkBefore(E e, Nodesucc)    在非null结点succ之前插入元素e。\nvoid linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // 此处未对succ进行判空，但要求其必须非空，否则会抛出NPE  // assert succ != null; \t// 取出给定结点的前驱结点  final Node\u0026lt;E\u0026gt; pred = succ.prev; // 构造一个新结点，以达成在给定结点与给定结点的前驱结点之间，将给定元素插入 \t// 该新结点的前驱结点为参数中给定结点的前驱结点 \t// 该新结点持有的元素为参数中给定的元素 \t// 该新结点的后继结点为参数中给定的结点  final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 将该新结点设置为给定结点的前驱结点  succ.prev = newNode; if (pred == null) // 如果给定结点的前驱结点为空，也即给定结点就是当前链表的第一结点，则设置链表的第一结点为该新结点  first = newNode; else // 如果给定结点的前驱结点不为空，则需要设置该前驱结点的后继结点为该新结点  pred.next = newNode; size++; modCount++; }  9. private E unlinkFirst(Nodef)    取消到非空的第一结点f的链接。\nprivate E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // 给定的结点f需要是头结点并且不为空  // assert f == first \u0026amp;\u0026amp; f != null; \t// 取出给定结点所持有的元素  final E element = f.item; // 取出给定结点的后继结点  final Node\u0026lt;E\u0026gt; next = f.next; // 将给定结点所持有的元素置为空  f.item = null; // 将给定结点的后继结点置为null，帮助垃圾回收  f.next = null; // help GC \t// 将上述取出的给定结点的后继结点设置为当前列表的头结点  first = next; if (next == null) // 如果给定结点的后继结点为空，也即原链表仅一个结点，此时将链表的最后结点设置为null  last = null; else // 如果给定结点的后继结点不为空，此时将该后继结点的前驱结点置为null，因为该后继结点已经成为链表的头结点了  next.prev = null; size--; modCount++; return element; }  10. private E unlinkLast(Nodel)    取消到非空的尾结点l的链接。\n该方法与unlinkFirst类似，只不过在链表的尾部进行操作。\n 11. E unlink(Nodex)    取消到非null结点x链接。\n本方法主要用于在链表中拆掉某个结点，其本质就是改变链表中该结点及其前驱和后继结点的关系，源码如下：\nE unlink(Node\u0026lt;E\u0026gt; x) { // 结点x不可为空，否则会抛出NPE  // assert x != null; \t// 取出结点x所持有的元素  final E element = x.item; // 取出结点x的后继结点  final Node\u0026lt;E\u0026gt; next = x.next; // 取出结点x的前驱结点  final Node\u0026lt;E\u0026gt; prev = x.prev; // 修改前驱关系  if (prev == null) { // 前驱结点为空，说明给定的结点x是链表的头结点 \t// 此时将头结点设置给结点x的后继结点，这样就相当于从链表中拆掉了结点x  first = next; } else { // 前驱结点不为空，说明给定的结点x并非链表的头结点 \t// 此时将此前驱结点的后继结点设置为结点x的后继结点  prev.next = next; // 同时将结点x的前驱结点设置为空  x.prev = null; } // 修改后继关系  if (next == null) { // 后继结点为空，说明给定的结点x是链表的尾结点 \t// 此时将链表的最后结点设置为结点x的前驱结点，相当于从链表中拆掉了结点x  last = prev; } else { // 后继结点不为空，说明给定结点x并非链表的尾结点 \t// 此时，将结点x的后继结点的前驱结点设置为结点x的前驱结点  next.prev = prev; // 同时将结点x的后继结点置为空  x.next = null; } x.item = null; size--; modCount++; return element; }  12. public E getFirst()    返回此列表中的第一个元素。\n直接获取该链表的头结点 first ，如果该结点为空，则抛出 NoSuchElementException ，否则返回该结点所持有的元素。\n 13. public E getLast()    返回此列表中的最后一个元素。\n与 getFirst() 方法类似，只不过操作的是尾结点。\n 14. public E removeFirst()    从此列表中删除并返回第一个元素。\n该方法首先获取该链表的头结点 first ，如果该结点为空，则抛出 NoSuchElementException ，否则调用 unlinkFirst 方法拆除当前链表的头结点，该拆除方法将返回头结点所持有的元素，然后也作为本方法的返回值返回。\n 15. public E removeLast()    从此列表中删除并返回最后一个元素。\n该方法与 removeLast 方法类似，只不过操作的是尾结点，调用的拆除方法是 unlinkLast 。\n 16. public void addFirst(E e)    将给定的元素插入到此列表的开头。\n该方法直接调用 linkFirst 方法。\n 17. public void addLast(E e)    将给定的元素追加到此列表的末尾。\n该方法直接调用 linkLast 方法。\n 18. public boolean contains(Object o)    如果当前列表包含给定的元素 o 则返回 true 。更准确的说，当且仅当当前列表包含至少一个元素 o 满足 (o==null ? e==null : o.equals(e)) 时返回 true 。\n该方法的主要逻辑是：通过 indexOf 方法判断得到的返回值是否为 -1 ，如果为 -1 则说明不包含该元素。\n 19. public int size()    返回此列表中的元素数。也就是返回当前列表的属性 size 。\n 20. public boolean add(E e)    将指定的元素追加到此列表的末尾。\n直接调用 linkLast 方法，然后返回 true 。\n 21. public boolean remove(Object o)    如果列表中存在指定元素，则从该列表中删除该元素的第一次出现。如果此列表不包含该元素，则它保持不变。更准确地说，删除满足 (o==null ? get(i)==null : o.equals(get(i))) 的最小索引 i 位置的元素（如果存在的话）。如果此列表包含指定的元素（或者等效地，如果此列表由于当前方法被调用而更改），则返回true。\n该方法的源码如下：\npublic boolean remove(Object o) { if (o == null) { // 当给定元素为null时，从头开始遍历链表，找到第一个元素为null的结点，然后调用unlink方法将其从链表中拆除  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 给定元素不为null时，从头开始遍历链表，找到第一个元素与给定元素equals的结点，调用unlink将其拆除  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } // 未找到给定元素，返回false  return false; }  22. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    按照给定集合的迭代器返回的顺序，将给定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了给定的集合，则此操作的行为是不确定的。 （请注意，如果给定的集合是此列表，并且是非空的，则将发生这种情况。）\n该方法的源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 调用可指定插入位置的addAll方法，指定的位置为列表的末尾 \t// 这也意味着，默认的addAll是将给定集合的元素拼接到链表的结尾的，除非用户指定插入位置  return addAll(size, c); }  23. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    从指定位置开始，将指定集合中的所有元素插入此列表。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按指定集合的迭代器返回的顺序出现在列表中。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断给定的索引位置是否合理，需要大于等于0并小于等于size  checkPositionIndex(index); // 将指定的集合转化为数组  Object[] a = c.toArray(); int numNew = a.length; // 如果数组长度为0，也即指定的集合为空集合，此时返回false  if (numNew == 0) return false; // 定义两个结点，一个前驱结点、一个后继结点，这一步主要是找到将指定集合中元素编入链表的位置 \t// 指定集合的所有元素将放置在该前驱结点和后继结点之间  Node\u0026lt;E\u0026gt; pred, succ; if (index == size) { // index等于size，也就意味着此次是将指定集合的元素插入到列表的末尾 \t// 后继结点置空，  succ = null; // 前驱结点置为当前链表的尾结点  pred = last; } else { // 取出指定索引位置index处的结点作为后继结点  succ = node(index); // 取出指定索引位置index处的前驱结点作为前驱结点  pred = succ.prev; } // 遍历指定的集合所转化的数组a，将其中的元素逐个编入链表  for (Object o : a) { // 将数组a中的元素强转为当前列表所持有的类型  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新结点，持有当前遍历到的元素  Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); if (pred == null) // 如果前驱结点为null，说明是当前结点是头结点  first = newNode; else // 前驱结点不为null，则设置该前驱结点的后继结点为当前结点，从而实现将当前结点编入链表中  pred.next = newNode; // 设置前驱结点变量为当前结点，作为下一个结点的前驱结点  pred = newNode; } // 这一步主要是将原链表指定索引位置index以后的结点挂在指定集合最后一个元素所在结点的后面  if (succ == null) { // 后继结点为空，说明指定集合的元素是拼接到链表尾部的，则设置链表的尾部为当前结点（即指定结合最后元素所在的结点）  last = pred; } else { // 后继结点不为空，则设置当前结点（即指定结合最后元素所在的结点）的后继结点为该后继结点  pred.next = succ; // 设置该后继结点的前驱结点为当前结点（即指定结合最后元素所在的结点）  succ.prev = pred; } size += numNew; modCount++; return true; }  24. public void clear()    从此列表中删除所有元素。此调用返回后，该列表将为空。\npublic void clear() { // Clearing all of the links between nodes is \u0026#34;unnecessary\u0026#34;, but:  // - helps a generational GC if the discarded nodes inhabit  // more than one generation  // - is sure to free memory even if there is a reachable Iterator \t// 从头开始遍历链表  for (Node\u0026lt;E\u0026gt; x = first; x != null; ) { // 先把当前结点的后继结点取出  Node\u0026lt;E\u0026gt; next = x.next; // 然后将当前结点的元素、前驱结点、后继结点置为空  x.item = null; x.next = null; x.prev = null; x = next; } // 将链表的头部结点、尾部结点置为null  first = last = null; size = 0; modCount++; }  25. public E get(int index)    返回此列表中指定位置的元素。\n源码如下：\npublic E get(int index) { // 校验元素索引  checkElementIndex(index); // 使用node方法取出指定索引位置的结点，然后返回该结点所持有的元素  return node(index).item; }  26. public E set(int index, E element)    用指定的元素替换此列表中指定位置的元素。\n元素如下：\npublic E set(int index, E element) { // 检查指定索引是否是当前列表元素的索引  checkElementIndex(index); // 取出指定索引位置的结点  Node\u0026lt;E\u0026gt; x = node(index); // 取出指定位置结点的元素  E oldVal = x.item; // 替换指定位置结点的元素为指定的元素  x.item = element; // 返回当前结点原来的元素  return oldVal; }  27. public void add(int index, E element)    将指定的元素插入此列表中的指定位置。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引添加一个）。\n源码如下：\npublic void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引  checkPositionIndex(index); if (index == size) // 如果index等于size，则说明指定元素需要拼接到结尾  linkLast(element); else // index不等于size，则先使用node方法取出指定位置的结点 \t// 然后调用linkBefore将指定元素插入到该结点之前  linkBefore(element, node(index)); }  28. public E remove(int index)    删除当前列表中指定位置的元素。然后将后面的元素左移（即索引减1）。返回被删除的元素。\n源码如下：\npublic E remove(int index) { // 先判断指定索引是否是当前列表元素的索引  checkElementIndex(index); // 先调用node方法获取指定索引位置的结点，再调用unlink方法将此结点从当前链表中拆除  return unlink(node(index)); }  29. private boolean isElementIndex(int index)    判断参数是否为现有元素的索引。要求索引大于等于0并且小于size。\n源码如下：\nprivate boolean isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; }  30. private boolean isPositionIndex(int index)    判断参数是否是迭代器或添加操作的有效位置的索引。\n其源码如下：\nprivate boolean isPositionIndex(int index) { // index必须大于等于0，并且小于等于列表的size \t// 此处给定的索引位置等于size也可以是因为该方法还用于插入元素时的索引判断，而插入时可以插入到列表的末尾，此时的插入位置正好为size  return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= size; }  31. private String outOfBoundsMsg(int index)    构造一个 IndexOutOfBoundsException 异常的详细信息。在许多可能的错误处理代码重构中，这种“概述”在服务器和客户机vm中都表现得最好。\n 32. private void checkElementIndex(int index)    检查指定索引是否是当前列表元素的索引，不满足的话则抛出数组越界异常。\n源码如下：\nprivate void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }  33. private void checkPositionIndex(int index)    检查位置索引，其源码如下：\nprivate void checkPositionIndex(int index) { // 此处调用位置索引判断方法，如果是非合理索引位置，则抛出数组越界异常  if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }  34. Nodenode(int index)    返回指定元素索引处的（非空）结点。\n源码如下：\nNode\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index);  // size \u0026gt;\u0026gt; 1，对size做右移1位的操作，类似于对其做除以2的操作，但不会四舍五入而是直接舍弃 \t// 此处判断指定的索引index是更靠近链表的开头还是结尾，从更靠近index的一端开始遍历可以节省开销  if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { // 从头部开始遍历  Node\u0026lt;E\u0026gt; x = first; // 一直找到指定索引位置的结点，然后返回  for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 从尾部开始遍历  Node\u0026lt;E\u0026gt; x = last; // 一直找到指定索引位置的结点，然后返回  for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } }  35. public int indexOf(Object o)    返回给定的元素在当前列表中第一次出现的索引位置，或者如果该元素在当前列表中不存在的话返回 -1 。更准确的说，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最小索引 i ，或者无此索引的话返回 -1 。\n索引，更像是基于数组的存储结构中才有的。其实， indexOf 是 List 接口中定义的方法，所以， LinkedList 中也实现了该方法，其并不能像基于数组的存储结构中那样，直接返回该元素在数组中的索引，而是从头开始遍历链表，从0开始计数，每经过一个结点，该计数值加1，命中的时候直接返回该计数值，源码如下：\npublic int indexOf(Object o) { // 从0开始计数  int index = 0; if (o == null) { // 给定对象为空时，判断结点持有的元素是否为空，为空则命中 \t// 从头开始遍历当前链表  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { // 判断结点持有的元素是否为空，若是，则返回当前计数值  if (x.item == null) return index; // 当前结点未命中，计数值加1  index++; } } else { // 给定对象不为空空时，通过equals判断结点持有的元素与给定元素是否相等，相等则命中 \t// 从头开始遍历当前链表  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { // 通过equals判断结点持有的元素与给定元素是否相等，若是，则返回当前计数值  if (o.equals(x.item)) return index; // 当前结点未命中，计数值加1  index++; } } // 当前列表中未匹配到给定的元素，返回-1  return -1; }  36. public int lastIndexOf(Object o)    返回当前列表中指定元素的最后一次出现的索引位置，或者如果指定元素在当前列表中不存在的话返回-1。更准确地说，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最大索引 i 或者指定元素不存在的话返回-1。\n该方法与 indexOf 类似，只不过当前方法是从链表的尾部开始向前遍历。\n 37. public E peek()    检索但不删除列表的头部元素（第一个元素）。\n该方法的源码如下：\npublic E peek() { // 首先取到头部结点  final Node\u0026lt;E\u0026gt; f = first; // 如果头部结点为空，则返回空，否则返回头部结点所持有的元素  return (f == null) ? null : f.item; }  38. public E element()    检索但不删除列表的头部元素（第一个元素）。\n该方法的源码如下：\npublic E element() { // 直接调用getFirst方法  return getFirst(); } 当前方法与 peek 的不同之处在于，当前方法在获取到的头部结点为空时，抛出 NoSuchElementException 。\n 39. public E poll()    检索以及删除列表的头部元素（第一个元素）。\n当前方法的源码如下：\npublic E poll() { // 先取出列表的头部结点  final Node\u0026lt;E\u0026gt; f = first; // 如果头部结点为空则返回空，否则调用unlinkFirst方法拆除当前头部结点  return (f == null) ? null : unlinkFirst(f); }  40. public E remove()    检索以及删除列表的头部元素（第一个元素）。\n当前方法的源码如下：\npublic E remove() { // 直接调用removeFirst方法  return removeFirst(); } 该方法与 poll 方法的不同之处在于，该方法在获取到的头部结点为空时会抛出 NoSuchElementException 。\n 41. public boolean offer(E e)    将给定的元素添加到列表的尾部（最后一个元素）。\n当前方法的源码如下：\npublic boolean offer(E e) { // 直接调用add方法  return add(e); }  42. public boolean offerFirst(E e)    将指定的元素插入到列表的前面。\n源码如下：\npublic boolean offerFirst(E e) { // 直接调用addFirst方法  addFirst(e); return true; }  43. public boolean offerLast(E e)    将指定的元素插入到列表的后面。\n源码如下：\npublic boolean offerLast(E e) { // 直接调用addLast方法  addLast(e); return true; }  44. public E peekFirst()    检索但不删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; }  45. public E peekLast()    检索但不删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; }  46. public E pollFirst()    检索并且删除列表的第一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; // 与peekFirst的不同之处就在于此处不是直接返回头结点的元素，而是调用unlinkFirst方法拆除头结点  return (f == null) ? null : unlinkFirst(f); }  47. public E pollLast()    检索并删除列表的最后一个元素，或者如果列表为空的话，返回 null 。\n源码如下：\npublic E pollLast() { final Node\u0026lt;E\u0026gt; l = last; // 调用unlinkLast拆除尾部结点  return (l == null) ? null : unlinkLast(l); }  48. public void push(E e)    将元素压入此列表所表示的堆栈。换句话说，将元素插入此列表的前面。\n该方法直接调用了 addFirst 方法。\n 49. public E pop()    从此列表所表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素。\n该方法直接调用了 removeFirst 方法。\n 50. public boolean removeFirstOccurrence(Object o)    删除此列表中第一次出现的指定元素（从头到尾遍历列表）。如果列表不包含该元素，则它保持不变。\n该方法直接调用 remove 方法。\n 51. public boolean removeLastOccurrence(Object o)    删除此列表中最后一次出现的指定元素（从头到尾遍历列表）。如果列表不包含该元素，则它保持不变。\n该方法的源码如下：\npublic boolean removeLastOccurrence(Object o) { // 判断指定的对象是否为空，以区分是使用 == null 进行判断还是使用equals进行判断  if (o == null) { // 从尾部开始遍历，命中则使用unlink方法拆除结点  for (Node\u0026lt;E\u0026gt; x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { for (Node\u0026lt;E\u0026gt; x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; }  52. public ListIteratorlistIterator(int index)    从列表中的指定位置开始（按适当顺序）返回此列表中元素的列表迭代器。遵守List.listIterator(int)的通用规范。\n该列表迭代器是“快速失败”的：如果在创建Iterator之后的任何时间对列表进行结构修改，除非是通过列表迭代器自己的remove或add方法，否则列表迭代器将抛出ConcurrentModificationException。因此，面对并发修改，迭代器会干净利落地失败，而不会在未来的不确定时间内冒任意不确定行为的风险。\n该方法的源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 检查指定索引是否大于等于0且小于等于size  checkPositionIndex(index); // 返回ListItr  return new ListItr(index); }  53. private class ListItr implements ListIterator   该类是 LinkedList 的私有类，提供了 ListIterator 的实现。\n53.1 private NodelastReturned;    最后返回的结点。\n53.2 private Nodenext;    下一个要返回的结点。\n53.3 private int nextIndex;    下一个结点的索引位置。\n53.4 private int expectedModCount = modCount;    期望的修改次数。\n53.5 ListItr(int index)    当前类的唯一构造方法。\n该方法的源码如下：\nListItr(int index) { // assert isPositionIndex(index); \t// 如果指定的索引等于当前列表的元素个数，则设定下一个结点为null，否则就设置为指定索引位置的结点  next = (index == size) ? null : node(index); // 设定下一个结点的索引为指定索引  nextIndex = index; } 53.6 public boolean hasNext()    判断当前迭代器是否还有下一个元素。源码如下：\npublic boolean hasNext() { // 判断下一个结点的索引是否小于列表的元素个数，若小于则说明还有下一个元素  return nextIndex \u0026lt; size; } 53.7 public E next()    获取下一个元素。源码如下：\npublic E next() { // 检查是否存在并发修改，存在则抛出异常  checkForComodification(); // 判断是否有下一个元素，若没有则抛出异常  if (!hasNext()) throw new NoSuchElementException(); // 设置最后返回的结点为下一个结点  lastReturned = next; // 设置下一个结点的下一个结点为下一个结点，类似于游标后移一位  next = next.next; // 下一个结点索引加1  nextIndex++; // 返回最后返回结点所持有的元素，其实该最后返回的结点正是之前的下一个结点（next）  return lastReturned.item; } 53.8 public boolean hasPrevious()    判断前面是否还有元素。源码如下：\npublic boolean hasPrevious() { // 判断下一个索引是否大于0，若是，则认定为前面还有元素  return nextIndex \u0026gt; 0; } 53.9 public E previous()    获取当前迭代器的上一个元素，源码如下：\npublic E previous() { // 进行并发修改检查  checkForComodification(); // 不存在上一个元素，则抛出异常  if (!hasPrevious()) throw new NoSuchElementException(); // 如果下一个结点为空，设定上一个返回的结点、下一个结点为列表的尾结点 \t// 如果下一个结点不为空，设定上一个返回的结点、下一个结点为下一个结点的前驱结点  lastReturned = next = (next == null) ? last : next.prev; // 下一个结点的索引减1  nextIndex--; // 返回最后返回结点所持有的元素  return lastReturned.item; } 53.10 public int nextIndex()    返回下一个元素的索引，源码如下：\npublic int nextIndex() { return nextIndex; } 53.11 public int previousIndex()    返回上一个元素的索引，源码如下：\npublic int previousIndex() { // 返回下一个元素的索引减1  return nextIndex - 1; } 53.12 public void remove()    删除当前遍历到的结点，也即最后返回的结点。源码如下：\npublic void remove() { // 进行并发修改检查  checkForComodification(); // 如果最后返回的结点为空，则抛出异常  if (lastReturned == null) throw new IllegalStateException(); // 取出最后返回结点的下一个结点  Node\u0026lt;E\u0026gt; lastNext = lastReturned.next; // 调用unlink方法拆除最后返回的结点  unlink(lastReturned); // 如果迭代器的下一个结点和最后返回的结点是同一个，则设置下一个结点为最后返回结点的下一个结点 \t// 否则，下一个结点的索引减1  if (next == lastReturned) next = lastNext; else nextIndex--; // 设定最后返回结点为空  lastReturned = null; // 期望修改次数加1  expectedModCount++; } 53.13 public void set(E e)    替换最后一次返回的元素为参数中指定的元素。源码如下：\npublic void set(E e) { // 如果最后一次返回的结点为空，则抛出 IllegalStateException  if (lastReturned == null) throw new IllegalStateException(); // 检查是否存在并发修改  checkForComodification(); // 替换最后一次返回结点所持有的元素  lastReturned.item = e; } 53.14 public void add(E e)    在最后一次返回的元素之后添加指定的元素。源码如下：\npublic void add(E e) { // 进行并发修改检查  checkForComodification(); // 将最后返回的结点置为空  lastReturned = null; // 如果next为空，说明迭代器当前所在的结点即为尾结点，直接使用linkLast方法把指定元素凭借到尾部即可  // 如果next不为空，则把指定元素加到next结点之前 \tif (next == null) linkLast(e); else linkBefore(e, next); // 下一个元素索引加1  nextIndex++; // 期望并发修改次数加1  expectedModCount++; } 53.15 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对迭代器尚未遍历到的元素执行指定的操作。源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { // 指定的操作不可为空  Objects.requireNonNull(action); // 在没有并发修改且尚有未遍历到的元素时进行遍历  while (modCount == expectedModCount \u0026amp;\u0026amp; nextIndex \u0026lt; size) { // 对当前遍历到的元素执行给定操作  action.accept(next.item); // 设置最后返回结点为下一个结点  lastReturned = next; // 设置下一个结点为下一个结点的下一个结点  next = next.next; // 下一个元素索引加1  nextIndex++; } // 检查是否存在并发修改  checkForComodification(); } 53.16 final void checkForComodification()    检查是否存在并发修改，存在则抛出异常。源码如下：\nfinal void checkForComodification() { // 当前修改数与期望修改数不同，则抛出并发修改异常  if (modCount != expectedModCount) throw new ConcurrentModificationException(); }  54. private static class Node   链表中的结点，其持有一个元素，并记录当前结点的前驱结点、后继结点。\n54.1 E item;    当前结点持有的元素。\n54.2 Nodenext;    当前结点持有的后继结点，用于记录当前结点的下一个结点是哪个。\n54.3 Nodeprev;    当前结点持有的前驱结点，用于记录当前结点的上一个结点是哪个。\n54.4 Node(Nodeprev, E element, Nodenext)    当前结点类的构造函数，也是唯一一个构造函数，用于构造一个结点。参数包括了一个结点的所需的所有要素。\n 55. public IteratordescendingIterator()    获取一个降序的迭代器，即从尾部向头部开始遍历。\n该方法创建一个DescendingIterator实例并返回。\n 56. private class DescendingIterator implements Iterator   通过ListItr.previous提供降序迭代器的适配器。\n56.1 private final ListItr itr = new ListItr(size());    ListItr 实例，本类基于此实例对外提供服务。遍历的位置初始化为列表的尾部。\n56.2 public boolean hasNext()    判断是否还有下一个，因为此类提供的是反向的遍历。所以， hasNext 返回的是列表是否还有上一个元素。其源码如下：\npublic boolean hasNext() { // 遍历方向是从列表的尾部向头部，所以此处返回的是迭代器的hasPrevious()  return itr.hasPrevious(); } 56.3 public E next()    获取下一个要遍历到的元素。此处也与上个方法相同， next 其实是列表的上一个元素。其源码如下：\npublic E next() { return itr.previous(); } 56.4 public void remove()    删除当前遍历到的结点。源码如下：\npublic void remove() { itr.remove(); }  57. private LinkedListsuperClone()    调用父类的 clone 方法，也即 Object.clone 方法，源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) private LinkedList\u0026lt;E\u0026gt; superClone() { try { // 调用父类的clone方法  return (LinkedList\u0026lt;E\u0026gt;) super.clone(); } catch (CloneNotSupportedException e) { // 如果捕获到不支持clone的异常，则包装成内部异常抛出  throw new InternalError(e); } }  58. public Object clone()    返回此LinkedList的浅复制副本。 （元素本身不会被克隆）\npublic Object clone() { LinkedList\u0026lt;E\u0026gt; clone = superClone(); // 将clone对象置为初始状态  // Put clone into \u0026#34;virgin\u0026#34; state  clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // 为clone对象初始化元素  // Initialize clone with our elements  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) clone.add(x.item); return clone; }  59. public Object[] toArray()    以正确的顺序（从第一个元素到最后一个元素）返回一个包含此列表中所有元素的数组。\n返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，此方法必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n源码如下：\npublic Object[] toArray() { // 创建一个数组  Object[] result = new Object[size]; int i = 0; // 然后从头开始遍历列表，将每个元素放入数组  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) result[i++] = x.item; return result; }  60. public T[] toArray(T[] a)    该方法返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。\n如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接列表末尾的数组中的元素将设置为null。 （如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n源码如下：\npublic \u0026lt;T\u0026gt; T[] toArray(T[] a) { // 如果指定的数组a的长度小于当前列表的长度，则先对数组进行扩容，扩到size大小  if (a.length \u0026lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; Object[] result = a; // 从头开始遍历数组，将每个元素放到数组中  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) result[i++] = x.item; // 如果数组a的长度大于列表的size，则设置数组列表元素的后面位置为null  if (a.length \u0026gt; size) a[size] = null; return a; }  61. private static final long serialVersionUID = 876323262645176354L;    序列化版本ID。\n 62. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException    将此LinkedList实例的状态保存到流中（即，对其进行序列化）。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // 将当前类的非静态和非瞬态字段写入此流  // Write out any hidden serialization magic  s.defaultWriteObject(); // 写出size  // Write out size  s.writeInt(size); // 写出所有元素  // Write out all elements in the proper order.  for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) s.writeObject(x.item); }  63. private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException    从流中重新构造此LinkedList实例（即，将其反序列化）。\n源码如下：\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // 从此流中读取所有非静态、非瞬态的属性 \t// Read in any hidden serialization magic  s.defaultReadObject(); // 读取size  // Read in size  int size = s.readInt(); // 读取所有元素  // Read in all elements in the proper order.  for (int i = 0; i \u0026lt; size; i++) linkLast((E)s.readObject()); }  64. public Spliteratorspliterator()    创建一个包含此列表所有元素的“后期绑定”和“快速失败”的 Spliterator 。\n该Spliterator报告SIZED和ORDERED。重写该实现时应记录其他特征值的报告。\nSpliterator还报告SUBSIZED并实现trySplit以允许有限的并行性。\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { return new LLSpliterator\u0026lt;E\u0026gt;(this, -1, 0); }  65. static final class LLSpliteratorimplements Spliterator   LinkedList的拆分器实现，其 LL 即 LinkedList 的缩写。\n65.1 static final int BATCH_UNIT = 1 \u0026laquo; 10;    批处理数组大小的增量，默认为1024。\n65.2 static final int MAX_BATCH = 1 \u0026laquo; 25;    批次最大数组大小，默认为33554432。因为拆分的时候会将“被拆分出”结点的元素放入数组，然后再构建成拆分器返回，此字段即是此处用作限制该数组容量上限的。\n65.3 final LinkedListlist;    该拆分器所持有的LinkedList，除非遍历，否则可为null。\n65.4 Nodecurrent;    当前结点，在初始化之前为null。\n65.5 int est;    估计的大小，在第一次需要之前为-1。\n65.6 int expectedModCount;    期望修改次数，设置 est 时初始化。\n65.6 int batch;    拆分的批次大小。\n65.7 LLSpliterator(LinkedListlist, int est, int expectedModCount)    当前类唯一的构造方法。\nLLSpliterator(LinkedList\u0026lt;E\u0026gt; list, int est, int expectedModCount) { // 设定属性值  this.list = list; this.est = est; this.expectedModCount = expectedModCount; } 65.8 final int getEst()    获取列表预估的大小。主要用途包括确认是从头部开始遍历还是尾部开始遍历。\n源代码如下：\nfinal int getEst() { int s; // force initialization  final LinkedList\u0026lt;E\u0026gt; lst; // 判断如果预估的大小大于0，则直接返回。因为est在第一次使用前为-1  if ((s = est) \u0026lt; 0) { if ((lst = list) == null) // 如果列表为空，则预估大小为0  s = est = 0; else { // 列表不为空 \t// 赋值期望修改次数为列表的修改次数  expectedModCount = lst.modCount; // 设置当前结点为列表的头结点  current = lst.first; // 设置预估大小为列表的大小  s = est = lst.size; } } return s; } 65.9 public long estimateSize()    获取预估大小，其实就是 getEst() 的 public 版本。不同之处还在于，当前方法会把返回结果强转为 long 类型。\n源码如下：\npublic long estimateSize() { return (long) getEst(); } 65.10 public SpliteratortrySplit()    执行拆分。源码如下：\npublic Spliterator\u0026lt;E\u0026gt; trySplit() { Node\u0026lt;E\u0026gt; p; // 获取预估大小  int s = getEst(); // 预估大小大于1 且 当前结点不为空 才执行拆分，否则返回空  if (s \u0026gt; 1 \u0026amp;\u0026amp; (p = current) != null) { // n取当前批次数 + 批次增量、列表预估大小、最大批次数组大小 三者中最小的那个  int n = batch + BATCH_UNIT; if (n \u0026gt; s) n = s; if (n \u0026gt; MAX_BATCH) n = MAX_BATCH; // 声明一个对象数组，容量为前面计算出的n  Object[] a = new Object[n]; int j = 0; // 从当前结点开始往后遍历，取出每个结点的元素放入数组，直至列表末尾或数组被塞满  do { a[j++] = p.item; } while ((p = p.next) != null \u0026amp;\u0026amp; j \u0026lt; n); // 将上面遍历到的最后一个结点设置为拆分器的当前结点  current = p; // 将上面遍历的结点个数设置为拆分器的批次大小  batch = j; // 设置拆分器的预估大小为上一次的预估大小减去本次拆分出的结点数  est = s - j; // 基于以上条件构造一个拆分器并返回  return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED); } return null; } 65.11 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对当前拆分器的剩余未遍历到的元素执行给定的操作。\n源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Node\u0026lt;E\u0026gt; p; int n; // 指定操作不可为空  if (action == null) throw new NullPointerException(); // 仅在拆分器的预估大小大于0 并且 当前结点不为空时执行  if ((n = getEst()) \u0026gt; 0 \u0026amp;\u0026amp; (p = current) != null) { // 将当前结点置为null，也就是遍历完成后的状态  current = null; // 将预估大小置为null，也就是遍历完成后的状态  est = 0; // 从当前结点开始遍历，直接拆分器持有的最后一个结点，对每个元素执行给定操作  do { E e = p.item; p = p.next; action.accept(e); } while (p != null \u0026amp;\u0026amp; --n \u0026gt; 0); } // 执行并发修改检查  if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); } 65.12 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action)    对当前拆分器的当前结点执行给定的操作。\n源码如下：\npublic boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { Node\u0026lt;E\u0026gt; p; // 给定操作不可为空  if (action == null) throw new NullPointerException(); // 预估大小大于0 并且 当前结点不为空才执行  if (getEst() \u0026gt; 0 \u0026amp;\u0026amp; (p = current) != null) { // 对预估大小执行减1操作  --est; // 取出当前结点所持有的元素  E e = p.item; // 设置当前结点为下一个结点  current = p.next; // 对元素执行给定的操作  action.accept(e); // 判断是否存在并发修改  if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); // 返回成功  return true; } return false; } 65.13 public int characteristics()    返回当前拆分器的特征值。源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; } "},{"id":4,"href":"/jdk8-src-note/java/util/Deque/","title":"Deque","parent":"util","content":"  1. void addFirst(E e) 2. void addLast(E e) 3. boolean offerFirst(E e) 4. boolean offerLast(E e) 5. E removeFirst() 6. E removeLast() 7. E pollFirst() 8. E pollLast() 9. E getFirst() 10. E getLast() 11. E peekFirst() 12. E peekLast() 13. boolean removeFirstOccurrence(Object o) 14. boolean removeLastOccurrence(Object o) 15. boolean add(E e) 16. boolean offer(E e) 17. E remove() 18. E poll() 19. E element() 20. E peek() 21. void push(E e) 22. E pop() 23. boolean remove(Object o) 24. boolean contains(Object o) 25. public int size() 26. Iterator\u0026lt;E\u0026gt; iterator() 27. Iterator\u0026lt;E\u0026gt; descendingIterator()     支持在两端插入和删除元素的线性集合。名称deque是“double ended queue”的缩写，通常发音为“ deck”。大多数Deque实现对它们可能包含的元素数量没有固定的限制，但是此接口支持容量受限的双端队列以及没有固定大小限制的双端队列。\n该接口定义了访问双端队列两端元素的方法。提供了用于插入，删除和检查元素的方法。这些方法均以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值（null或false，具体取决于操作）。后一种形式的插入操作是专为容量受限的Deque实现而设计的；在大多数实现中，插入操作不会失败。\n下表总结了上述十二种方法：\n    抛出异常（头元素） 返回特殊值（头元素） 抛出异常（末尾元素） 返回特殊值（末尾元素）     插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e)   删除 removeFirst() pollFirst() removeLast() pollLast()   检索 getFirst() peekFirst() getLast() peekLast()    此接口扩展了Queue接口。当将双端队列当作队列使用时，将导致FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。如下表所示，从Queue接口继承的方法与Deque方法完全等效：\n   Queue方法 等效的Deque方法     add(e) addLast(e)   offer(e) offerLast(e)   remove() removeFirst()   poll() pollFirst()   element() getFirst()   peek() peekFirst()    双端队列也可以用作LIFO（后进先出）堆栈。此接口应优先于旧式Stack类使用。当双端队列用作堆栈时，元素从双端队列的开头被压入以及弹出。堆栈方法完全等同于Deque方法，如下表所示：\n   Stack方法 等效的Deque方法      push(e) addFirst(e)    pop() removeFirst()    peek() peekFirst()     注意，当双端队列用作队列或堆栈时，peek方法同样有效。无论哪种情况，元素都是从双端队列的开头开始绘制的。\n该接口提供了两种删除内部元素的方法：removeFirstOccurrence和removeLastOccurrence。\n与List接口不同，此接口不支持对元素的索引访问。\n虽然并非严格要求Deque实现禁止插入空元素，但强烈建议这样做。强烈建议所有使用允许null元素的Deque实现的用户不要插入null。之所以如此，是因为各种方法都将null用作特殊的返回值，以指示双端队列为空。\nDeque实现通常不定义基于元素的equals和hashCode方法，而是从类Object继承基于身份的版本。\n该接口也是Java集合框架的成员。\n 1. void addFirst(E e)    如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此双端队列的前面，如果当前没有可用空间，则抛出IllegalStateException。使用有容量限制的双端队列时，通常最好使用方法offerFirst。\n 2. void addLast(E e)    如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此双端队列的后面，如果当前没有可用空间，则抛出IllegalStateException。使用有容量限制的双端队列时，通常最好使用方法offerLast。\n此方法等效于add。\n 3. boolean offerFirst(E e)    将指定的元素插入此双端队列的前面，除非该操作违反容量限制。使用容量受限的双端队列时，此方法通常比addFirst方法更可取，后者只能通过引发异常才能不插入元素。\n 4. boolean offerLast(E e)    将指定的元素插入此双端队列的后面，除非该操作违反容量限制。使用容量受限的双端队列时，此方法通常比addLast方法更可取，后者只能通过引发异常才能不插入元素。\n 5. E removeFirst()    检索并删除此双端队列的第一个元素。此方法与pollFirst的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n 6. E removeLast()    检索并删除此双端队列的最后一个元素。此方法与pollLast的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n 7. E pollFirst()    检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null。\n 8. E pollLast()    检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null。\n 9. E getFirst()    检索但不删除此双端队列的第一个元素。\n该方法与peekFirst的不同之处仅在于当双端队列为空时本方法将抛出异常。\n 10. E getLast()    检索但不删除此双端队列的最后一个元素。\n该方法与peekLast的不同之处仅在于当双端队列为空时本方法将抛出异常。\n 11. E peekFirst()    检索但不删除此双端队列的第一个元素，或者如果当前双端队列为空的话，则返回null。\n 12. E peekLast()    检索但不删除此双端队列的最后一个元素，或者如果当前双端队列为空的话，则返回null。\n 13. boolean removeFirstOccurrence(Object o)    从此双端队列中删除指定元素的第一次出现。如果双端队列不包含元素，则它保持不变。更准确地讲，删除第一个满足(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。\n如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用该方法而更改），则返回true。\n 14. boolean removeLastOccurrence(Object o)    从此双端队列中删除指定元素的最后一次出现。如果双端队列不包含元素，则它保持不变。更准确地讲，删除最后一个满足(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。\n如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用该方法而更改），则返回true。\n 15. boolean add(E e)    如果可能的话立即将指定的元素插入此双端队列所表示的队列中（换句话说，插入到此双端队列的末尾），而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出一个IllegalStateException。使用容量受限的双端队列时，通常最好使用offer。\n该方法等效于addLast。\n 16. boolean offer(E e)    如果可能的话立即将指定的元素插入此双端队列所表示的队列中（换句话说，插入到此双端队列的末尾），而不会违反容量限制，则在成功后返回true，如果当前没有可用空间，则返回false。使用容量受限的双端队列时，该方法通常好于使用add，因为add方法在触发容量上限后是抛出异常。\n该方法等效于offerLast。\n 17. E remove()    检索并删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n该方法等效于removeFirst()。\n 18. E poll()    检索并删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素），如果此双端队列为空，则返回null。\n该方法等效于pollFirst()。\n 19. E element()    检索但不删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek的不同之处仅在于，如果此双端队列为空，则它将引发异常。\n该方法等效于getFirst()。\n 20. E peek()    检索但不删除此双端队列所表示队列的头部（换句话说，此双端队列的第一个元素），如果此双端队列为空，则返回null。\n该方法等效于peekFirst()。\n 21. void push(E e)    如果不违反容量限制则立即将元素压入此双端队列表示的堆栈（换句话说，此双端队列的开头），如果当前没有可用空间，则抛出IllegalStateException。\n该方法等效于addFirst。\n 22. E pop()    从此双端队列所表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。\n该方法等效于removeFirst()。\n 23. boolean remove(Object o)    从此双端队列删除指定元素的第一次出现。如果双端队列不包含此元素，则它保持不变。更正式地讲，删除第一个可以使得(o==null ? e==null : o.equals(e))的元素e（如果存在这样的元素）。如果此双端队列包含指定的元素（或者等效地，如果此双端队列由于调用而更改），则返回true。\n该方法等效于removeFirstOccurrence(Object)。\n 24. boolean contains(Object o)    如果此双端队列包含指定的元素，则返回true。更正式地讲，当且仅当此双端队列至少包含一个元素e可以满足(o==null ? e==null : o.equals(e))时返回true。\n 25. public int size()    返回此双端队列中的元素数。\n 26. Iterator\u0026lt;E\u0026gt; iterator()    以适当的顺序返回此双端队列中的元素的迭代器。元素将按照从前（头）到后（尾）的顺序返回。\n 27. Iterator\u0026lt;E\u0026gt; descendingIterator()    以相反的顺序返回此双端队列中的元素的迭代器。元素将按从最后（尾）到第一个（头）的顺序返回。\n"},{"id":5,"href":"/jdk8-src-note/java/util/ArrayList/","title":"ArrayList","parent":"util","content":"  1. private static final long serialVersionUID = 8683452581122892189L; 2. private static final int DEFAULT_CAPACITY = 10; 3. private static final Object[] EMPTY_ELEMENTDATA = {}; 4. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 5. transient Object[] elementData; 6. private int size; 7. public ArrayList(int initialCapacity) 8. public ArrayList() 9. public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) 10. public void trimToSize() 11. public void ensureCapacity(int minCapacity) 12. private static int calculateCapacity(Object[] elementData, int minCapacity) 13. private void ensureCapacityInternal(int minCapacity) 14. private void ensureExplicitCapacity(int minCapacity) 15. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 16. private void grow(int minCapacity) 17. private static int hugeCapacity(int minCapacity) 18. public int size() 19. public boolean isEmpty() 20. public boolean contains(Object o) 21. public int indexOf(Object o) 22. public int lastIndexOf(Object o) 23. public Object clone() 24. public Object[] toArray() 25. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 26. E elementData(int index) 27. public E get(int index) 28. public E set(int index, E element) 29. public boolean add(E e) 30. public void add(int index, E element) 31. public E remove(int index) 32. public boolean remove(Object o) 33. private void fastRemove(int index) 34. public void clear() 35. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 36. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 37. protected void removeRange(int fromIndex, int toIndex) 38. private void rangeCheck(int index) 39. private void rangeCheckForAdd(int index) 40. private String outOfBoundsMsg(int index) 41. public boolean removeAll(Collection\u0026lt;?\u0026gt; c) 42. public boolean retainAll(Collection\u0026lt;?\u0026gt; c) 43. private boolean batchRemove(Collection\u0026lt;?\u0026gt; c, boolean complement) 44. private void writeObject(java.io.ObjectOutputStream s) 45. private void readObject(java.io.ObjectInputStream s) 46. public ListIterator\u0026lt;E\u0026gt; listIterator(int index) 47. public ListIterator\u0026lt;E\u0026gt; listIterator() 48. public Iterator\u0026lt;E\u0026gt; iterator() 49. private class Itr implements Iterator\u0026lt;E\u0026gt;  49.1 int cursor; 49.2 int lastRet = -1; 49.3 int expectedModCount = modCount; 49.4 Itr() 49.5 public boolean hasNext() 49.6 public E next() 49.7 public void remove() 49.8 public void forEachRemaining(Consumer consumer) 49.9 final void checkForComodification()   50. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;  50.1 ListItr(int index) 50.2 public boolean hasPrevious() 50.3 public int nextIndex() 50.4 public int previousIndex() 50.5 public E previous() 50.6 public void set(E e) 50.7 public void add(E e)   51. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 52. static void subListRangeCheck(int fromIndex, int toIndex, int size) 53. private class SubList extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess  53.1 private final AbstractList\u0026lt;E\u0026gt; parent; 53.2 private final int parentOffset; 53.3 private final int offset; 53.4 int size; 53.5 SubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex) 53.6 public E set(int index, E e) 53.7 public E get(int index) 53.8 public int size() 53.9 public void add(int index, E e) 53.10 public E remove(int index) 53.11 protected void removeRange(int fromIndex, int toIndex) 53.12 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 53.13 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 53.14 public Iterator\u0026lt;E\u0026gt; iterator() 53.15 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 53.16 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 53.17 private void rangeCheck(int index) 53.18 private void rangeCheckForAdd(int index) 53.19 private String outOfBoundsMsg(int index) 53.20 private void checkForComodification() 53.21 public Spliterator\u0026lt;E\u0026gt; spliterator()   54. public void forEach(Consumer\u0026lt;? super E\u0026gt; action) 55. public Spliterator\u0026lt;E\u0026gt; spliterator() 56. static final class ArrayListSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt;  56.1 private final ArrayList\u0026lt;E\u0026gt; list; 56.2 private int index; 56.3 private int fence; 56.4 private int expectedModCount; 56.5 ArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount) 56.6 private int getFence() 56.7 public ArrayListSpliterator\u0026lt;E\u0026gt; trySplit() 56.8 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) 56.9 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) 56.10 public long estimateSize() 56.11 public int characteristics()   57. public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 58. public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 59. public void sort(Comparator\u0026lt;? super E\u0026gt; c)     List接口的可变数组实现，实现了所有可选的列表操作，并允许存放所有元素，包括null。除了实现List接口之外，ArrayList类还提供一些方法来操作用于内部存储列表数组的大小。该类和Vector类大体类似，除了本类是非同步的。\nsize、isEmpty、get、set、iterator和listIterator操作均在恒定时间内运行。add操作执行需要均摊恒定时间，也即新增n个元素需要的时间为O(n)。所有其他操作都在线性时间内运行（粗略地说）。该实现与LinkedList实现相比，常量因子较低。\n每个ArrayList实例都有一个容量。容量是用于在列表中存储元素的数组的大小。它总是至少与列表大小一样大。将元素添加到ArrayList，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定扩充策略的详细信息。\n在添加大量元素之前，应用程序可以使用ensureCapacity操作先增加ArrayList实例的容量。这可以减少增量重新分配的数量。\n需要注意，本实现是非同步的，如果多个线程同时访问ArrayList实例，并且至少一个线程修改了列表结构，则它必须通过外部实现同步。（结构上的修改是指添加或删除一个或多个元素，或显式调整后备数组大小的任何操作；仅设置元素的值不是结构上的修改。）通常，是通过在自然封装列表的某个对象上进行同步来完成此操作。\n如果不存在这样的对象，则应使用Collections#synchronizedList方法“包装”列表。最好在创建列表时完成此操作，以防止意外不同步的访问列表：\nList list = Collections.synchronizedList(new ArrayList(...)); 此类的iterator()和listIterator(int)方法返回的迭代器采用的是“快速失败”机制：如果列表在迭代器创建后的任意时间、以任意方式进行了结构上的改动，除了通过迭代器自己的ListIterator#remove()或ListIterator#add(Object)方法外，迭代器都将抛出ConcurrentModificationException异常。因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间面临任意、不确定行为的风险。\n请注意，迭代器的“快速失败”行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。“快速失败”的迭代器会尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序以确保其正确性是错误的：迭代器的“快速失败”行为应仅用于检测bug。\n该类是Java集合框架的成员类。\n 1. private static final long serialVersionUID = 8683452581122892189L;    序列化版本唯一ID。\n 2. private static final int DEFAULT_CAPACITY = 10;    当前列表的默认初始容量。\n 3. private static final Object[] EMPTY_ELEMENTDATA = {};    用于空实例的共享空数组实例。\n 4. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};    共享的空数组实例，用于默认大小的空实例。将它与EMPTY_ELEMENTDATA区别开来，是为了了解添加第一个元素时要扩充多少。\n 5. transient Object[] elementData;    数组缓冲区，ArrayList的元素便存储在其中。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何满足elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList的容量都将扩展为DEFAULT_CAPACITY。\n该属性的访问修饰符非私有，以简化嵌套类访问。\n 6. private int size;    ArrayList的大小（包含的元素数量）。\n 7. public ArrayList(int initialCapacity)    构造一个具有指定初始容量的空列表。\n源码如下：\npublic ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 指定容量大于0，初始化一个指定容量的数组赋值给elementData  this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 指定容量等于0，elementData直接取空数组  this.elementData = EMPTY_ELEMENTDATA; } else { // 指定容量小于0，抛出异常  throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } }  8. public ArrayList()    构造一个初始容量为10的空列表。\n源码如下：\npublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; }  9. public ArrayList(Collection\u0026lt;? extends E\u0026gt; c)    构造一个包含给定的集合中所有元素的列表，元素插入本列表时按照集合的迭代器返回元素的顺序。\n源码如下：\npublic ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // 先将指定集合转换为对象数组  Object[] a = c.toArray(); // 将数组长度赋值给列表的size，然后判断size是否为0  if ((size = a.length) != 0) { // 如果指定的集合不为空，然后判断该指定集合是否是ArrayList  if (c.getClass() == ArrayList.class) { // 指定集合是ArrayList，直接把数组a赋值给当前集合的elementData数组  elementData = a; } else { // 指定集合不是ArrayList，需要将数组a复制给elementData数组  elementData = Arrays.copyOf(a, size, Object[].class); } } else { // 指定的集合为空，给elementData字段赋值一个空数组  // replace with empty array.  elementData = EMPTY_ELEMENTDATA; } } 至于为什么不能把指定的集合c转为数组a之后，把这个数组a直接赋值给当前的ArrayList的elementData呢？\n这是由于此处存在Java的一个bug（6260652），也就是c.toArray可能返回的不是Object[]类型。如下测试用例所示：\n@Test public void testArrayListWithCollection() { // list1，类型是Arrays中自已实现的ArrayList，其内部用于存储列表元素的数组类型为：E[]，E为泛型  List\u0026lt;Integer\u0026gt; list1 = Arrays.asList(1, 2, 3); System.out.println(list1.toArray().getClass()); // list2，类型是java.util.ArrayList，即使声明这是一个Integer列表，但其用于存储列表元素的数组类型仍为：Object[]  List\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); list2.add(1); System.out.println(list2.toArray().getClass()); // 使用参数为一个集合的构造器构造一个java.util.ArrayList实例，即使该集合的toArray()方法返回的并非Object[]类型，则该构造器也会对其进行转换  List\u0026lt;Integer\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(list1); System.out.println(list3.toArray().getClass()); } 输出：\nclass [Ljava.lang.Integer; class [Ljava.lang.Object; class [Ljava.lang.Object;  10. public void trimToSize()    将该ArrayList实例的容量调整为列表当前的大小。应用程序可以使用此操作来最大程度地减少ArrayList实例的存储。\n源码如下：\npublic void trimToSize() { // 修改次数加1  modCount++; // 只有当前列表的元素个数小于数组长度时才执行此操作  if (size \u0026lt; elementData.length) { // 列表的元素个数为0，则置elementData数组为空数组  // 否则，执行数组复制，将数组中有元素的部分复制出来赋值给elementData数组  elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } }  11. public void ensureCapacity(int minCapacity)    确保本列表的容量至少可以容纳参数minCapacity指定的元素个数，如有必要的话会增加此ArrayList实例的容量。\n源码如下：\npublic void ensureCapacity(int minCapacity) { // 先计算一个最小扩充值  // 如果当前列表的elementData数组不是默认容量的空数组，则最小扩充值取0  // 否则最小扩充值默认容量，也即10  int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table  ? 0 // larger than default for default empty table. It\u0026#39;s already  // supposed to be at default size.  : DEFAULT_CAPACITY; // 如果指定的最小容量大于最小扩充值，则调用ensureExplicitCapacity方法进行精确扩容  if (minCapacity \u0026gt; minExpand) { ensureExplicitCapacity(minCapacity); } }  12. private static int calculateCapacity(Object[] elementData, int minCapacity)    计算最小容量值。\n源码如下：\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) { // 如果指定的元素数组是默认容量空数组，则返回默认容量空数组和指定最小容量这二者的最大值  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } // 如果指定的元素数组已非默认容量空数组，此时直接返回最小容量  return minCapacity; }  13. private void ensureCapacityInternal(int minCapacity)    内部使用的（私有的）容量确保方法。\n源码如下：\nprivate void ensureCapacityInternal(int minCapacity) { // 先调用计算容量方法获得最小容量值，再调用ensureExplicitCapacity明确扩容  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); }  14. private void ensureExplicitCapacity(int minCapacity)    明确的扩容方法，判断若指定的最小容量大于当前元素数组的容量，则对数组进行扩容。\n源码如下：\nprivate void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code  // 指定的最小容量大于元素数组的长度才进行扩容  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); }  15. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8    可分配的数组的最大大小。一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超出虚拟机限制。\n 16. private void grow(int minCapacity)    增加容量以确保它至少可以容纳由最小容量参数指定的元素数量。\n源码如下：\nprivate void grow(int minCapacity) { // overflow-conscious code  // 取出原容量  int oldCapacity = elementData.length; // 先计算一个新容量，基本上是扩容1.5倍（其实0.5并不准确，因为右移一位计算时没有小数，小数位全舍弃）  int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); // 扩容“1.5”倍后，判断是否能满足最小容量需求  if (newCapacity - minCapacity \u0026lt; 0) // 仍无法满足最小容量需求，则此时新容量直接取参数中指定的最小容量  newCapacity = minCapacity; // 判断新容量是否大于最大数组容量  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) // 新容量大于最大数组容量，此时调用hugeCapacity来获取新容量  newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  // 对元素数组执行复制，复制后的数组容量为上面计算出的容量  elementData = Arrays.copyOf(elementData, newCapacity); }  17. private static int hugeCapacity(int minCapacity)    获取最大容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow  throw new OutOfMemoryError(); // 如参数指定的最小容量 大于 最大数组容量，则新容量取Integer的最大值  // 否则取最大数组容量  return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 之前说MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，因为有的虚拟机中实现的数组可能会有头字，进而导致数组的最大容量无法达到Integer.MAX_VALUE，那如果按照本方法中的扩容策略，容量最大还是可以取到Integer.MAX_VALUE的，那岂不还是会出现未知的风险？\n所以，ArrayList的最大容量并非Integer.MAX_VALUE - 8，而是Integer.MAX_VALUE。\n 18. public int size()    返回当前列表中元素的个数，即私有属性size。\n源码如下：\npublic int size() { return size; }  19. public boolean isEmpty()    判断当前ArrayList实例的元素数量（即size）是否为0。\n源码如下：\npublic boolean isEmpty() { return size == 0; }  20. public boolean contains(Object o)    判断当前列表是否包含参数中指定的元素。\n如果当前列表包含指定的元素，则返回true。更正式地说，当且仅当当前列表至少包含一个元素e可满足(o==null ? e==null : o.equals(e))时返回true。 源码如下：\npublic boolean contains(Object o) { // 先获取指定元素的索引，然后判断索引是否大于等于0，不大于等于0说明没找到  return indexOf(o) \u0026gt;= 0; }  21. public int indexOf(Object o)    返回参数中给定的元素在本列表中第一次出现的索引位置。如果给定的元素在本列表不存在，则返回-1。更准确的说，返回可满足(o==null ? get(i)==null : o.equals(get(i)))的最小索引i，如果该索引不存在的话，返回-1。\n源码如下：\npublic int indexOf(Object o) { // 根据指定元素是否为null采用不同的方式处理  // 均是从头开始遍历列表，命中了则返回当前索引  if (o == null) { for (int i = 0; i \u0026lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i \u0026lt; size; i++) if (o.equals(elementData[i])) return i; } // 未找到指定元素的索引，返回-1  return -1; }  22. public int lastIndexOf(Object o)    本方法与indexOf类似，不同之处在于，本方法是从后向前遍历，找到符合条件的最大索引。\n返回参数中给定的元素在本列表中最后一次出现的索引位置。如果给定的元素在本列表不存在，则返回-1。更准确的说，返回可满足(o==null ? get(i)==null : o.equals(get(i)))的最大索引i，如果该索引不存在的话，返回-1。\n源码如下：\npublic int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i \u0026gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i \u0026gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; }  23. public Object clone()    获取一个当前ArrayList实例的浅复制实例，即ArrayList实例是新的，但是其中的元素没有被复制，仍是原来的元素。\n源码如下：\npublic Object clone() { try { // 直接调用Object类的clone方法进行克隆  ArrayList\u0026lt;?\u0026gt; v = (ArrayList\u0026lt;?\u0026gt;) super.clone(); // 由于Object类的clone方法是浅复制，也即克隆出的新列表虽有新的内存地址，但新列表持有的对象数组仍是老List的对象数组，此时将数组再复制一份复制给新列表  v.elementData = Arrays.copyOf(elementData, size); // 将新列表的修改次数归0  v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn\u0026#39;t happen, since we are Cloneable  throw new InternalError(e); } }  24. public Object[] toArray()    返回一个以正确的顺序（从第一个元素到最后一个元素）包含当前列表中所有元素的数组。 返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，此方法必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n源码如下：\npublic Object[] toArray() { return Arrays.copyOf(elementData, size); }  25. public \u0026lt;T\u0026gt; T[] toArray(T[] a)    返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；所返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。 如果列表适合指定的数组并有剩余空间（即数组中的元素多于列表），则紧接集合结束后的数组中的元素设置为null。（如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n源码如下：\npublic \u0026lt;T\u0026gt; T[] toArray(T[] a) { if (a.length \u0026lt; size) // 如果指定的数组a容量不足，则会将对象数组复制到新数组中，新数组的类型就是指定的数组a的类型  // Make a new array of a\u0026#39;s runtime type, but my contents:  return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // a的容量足够，将对象数组复制到其中  System.arraycopy(elementData, 0, a, 0, size); // 如果对象数组a的长度大于当前列表元素个数，则最后一个元素后面的位置置为null  if (a.length \u0026gt; size) a[size] = null; return a; }  26. E elementData(int index)    获取指定索引位置的元素。\n源码如下：\nE elementData(int index) { // 取出元素后会将其强转为当前列表持有元素的类型，因为对象数组elementData中存的都是Object对象  return (E) elementData[index]; }  27. public E get(int index)    返回此列表中指定位置的元素。\n源码如下：\npublic E get(int index) { // 首先对索引位置进行范围检查  rangeCheck(index); // 调用elementData方法取出指定位置的数据  return elementData(index); }  28. public E set(int index, E element)    用指定的元素element替换此列表中指定位置index的元素。\n源码如下：\npublic E set(int index, E element) { // 首先对索引进行范围检查  rangeCheck(index); // 调用elementData方法取出指定位置当前的元素  E oldValue = elementData(index); // 替换元素数组中指定位置的元素为参数中指定的元素  elementData[index] = element; // 返回旧值  return oldValue; }  29. public boolean add(E e)    将指定的元素追加到此列表的末尾，然后返回true。\n源码如下：\npublic boolean add(E e) { // 确保容量足够  ensureCapacityInternal(size + 1); // Increments modCount!!  // 设置索引位置为size的元素为参数中指定的元素，然后再将size加1  elementData[size++] = e; return true; }  30. public void add(int index, E element)    将指定的元素element插入此列表中的指定位置index。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加1）。\n源码如下：\npublic void add(int index, E element) { // 首先对指定的索引index执行检查，看其是否符合新增的条件（大于0小于等于size）  rangeCheckForAdd(index); // 确保容量足够  ensureCapacityInternal(size + 1); // Increments modCount!!  // 将指定索引index之后的元素全部右移一位，即各索引加1  System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将指定索引位置index处的元素替换为参数中指定的元素element  elementData[index] = element; // 将列表元素个数加1  size++; }  31. public E remove(int index)    删除此列表中指定位置的元素。将所有后续元素向左移动（将其索引减1）。\n源码如下：\npublic E remove(int index) { // 对索引进行范围检查  rangeCheck(index); modCount++; // 取出指定索引位置当前的元素  E oldValue = elementData(index); // 计算出要移动的元素个数  int numMoved = size - index - 1; // 如果需移动的元素个数大于0，则将对象数组从index+1位置及之后的元素复制到index位置及之后  if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 先将size减1，然后将最后一个元素置为null，因为该位置的元素已被复制到它的前一位了  elementData[--size] = null; // clear to let GC do its work  // 返回旧值  return oldValue; }  32. public boolean remove(Object o)    如果存在指定元素，则从该列表中删除第一次出现的该元素。如果列表不包含该元素，则该列表将不会改变。更准确地说，是删除满足(o==null ? get(i)==null : o.equals(get(i)))（如果存在这样的元素）的最小索引i对应的元素。如果此列表包含指定的元素，则返回true（或者等效地，如果由于本方法被调用而导致此列表有更改，则返回true）。\n源码如下：\npublic boolean remove(Object o) { // 根据指定的元素o是否为空走不同的逻辑  if (o == null) { // 遍历对象数组，逐个判断每个元素是否与指定元素相等，相等则调用fastRemove进行删除  for (int index = 0; index \u0026lt; size; index++) if (elementData[index] == null) { fastRemove(index); // 删除了数据，返回true  return true; } } else { for (int index = 0; index \u0026lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } // 没有删除数据，返回false  return false; }  33. private void fastRemove(int index)    私有的删除方法，跳过边界检查并且不返回移除的值。\n源码如下：\nprivate void fastRemove(int index) { modCount++; // 与根据索引删除元素的方法中类似，先计算出要移动索引的元素个数  int numMoved = size - index - 1; // 如果需要移动索引，则同样把index+1及后面的元素复制到从index及之后的位置  if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将size减1，然后将最后一个元素置空  elementData[--size] = null; // clear to let GC do its work }  34. public void clear()    从此列表中删除所有元素。该方法被调用后，该列表将为空。\n源码如下：\npublic void clear() { modCount++; // clear to let GC do its work  // 遍历对象数组，将每个位置上的元素置为null  for (int i = 0; i \u0026lt; size; i++) elementData[i] = null; // 将size置为0  size = 0; }  35. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    按照参数中指定集合的Iterator返回的顺序，将指定集合中的所有元素追加到此列表的末尾。 如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。（这意味着如果指定的集合就是本列表自身，并且本列表是非空的，则此调用的行为是不确定的。）\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 将指定集合转为数组  Object[] a = c.toArray(); int numNew = a.length; // 元素插入前的常规操作：确认容量足够  ensureCapacityInternal(size + numNew); // Increments modCount  // 将指定集合转化成的数组a复制到本列表的对象数组中  System.arraycopy(a, 0, elementData, size, numNew); // 增加size  size += numNew; // 若此方法实际插入了元素，则返回true，否则返回false  return numNew != 0; }  36. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    从指定位置index开始，将指定集合c中的所有元素插入此列表。将当前位于该位置的元素（如果有的话）和任何后续元素向右移动（对它们的索引加一）。 新元素将按照指定集合的迭代器返回的顺序出现在列表中。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 检查指定索引是否合法（大于0小于等于size）  rangeCheckForAdd(index); // addAll的常规操作，将指定集合转为数组，然后确保容量足够  Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount  // 先判断是否要移动索引，如果插入位置不是列表末尾的话，就需要移动  // 此举是为了腾出空来放置指定集合内的元素  int numMoved = size - index; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将指定集合转化成的数组a复制到本列表的对象数组中刚腾出来的位置  System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; }  37. protected void removeRange(int fromIndex, int toIndex)    删除当前列表中所有索引位置在fromIndex（包含）和toIndex（不包含）之间的元素。后面的元素都向左异动（减小其索引）。\n调用此方法会缩短列表(toIndex - fromIndex)个元素。如果toIndex==fromIndex，该操作将不会对列表造成影响。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { modCount++; // 计算要移动的元素个数，toIndex及之后位置的元素都需要移动  int numMoved = size - toIndex; // 将toIndex及之后的元素复制到fromIndex及之后的位置  System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work  // 拿到列表的新大小  int newSize = size - (toIndex-fromIndex); // 将索引位置在新大小之后的元素均置为null  for (int i = newSize; i \u0026lt; size; i++) { elementData[i] = null; } size = newSize; }  38. private void rangeCheck(int index)    检查给定的索引是否在范围内。如果不是，则抛出适当的运行时异常。此方法不检查索引是否为负数：它始终在数组访问之前立即使用，如果索引为负数，则抛出 ArrayIndexOutOfBoundsException。\n源码如下：\nprivate void rangeCheck(int index) { if (index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }  39. private void rangeCheckForAdd(int index)    add和addAll使用的rangeCheck版本。\n源码如下：\nprivate void rangeCheckForAdd(int index) { // 该校验允许index等于size，因为在插入元素时，可以往size这个索引位置插入  if (index \u0026gt; size || index \u0026lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }  40. private String outOfBoundsMsg(int index)    构造一个IndexOutOfBoundsException详细消息。在错误处理代码的许多可能重构中，这种“概述”在服务器和客户端VM上表现最佳。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size; }  41. public boolean removeAll(Collection\u0026lt;?\u0026gt; c)    从此列表中移除指定集合中包含的所有元素。\n源码如下：\npublic boolean removeAll(Collection\u0026lt;?\u0026gt; c) { // 指定集合c不可为空  Objects.requireNonNull(c); // 调用batchRemove方法删除元素  return batchRemove(c, false); }  42. public boolean retainAll(Collection\u0026lt;?\u0026gt; c)    仅保留此列表中指定集合中包含的元素。换句话说，从该列表中删除所有未包含在指定集合中的元素。\n源码如下：\npublic boolean retainAll(Collection\u0026lt;?\u0026gt; c) { // 指定集合c必须非空  Objects.requireNonNull(c); // 调用batchRemove方法，此处与removeAll方法内不同，此处传的第二个参数为true  return batchRemove(c, true); }  43. private boolean batchRemove(Collection\u0026lt;?\u0026gt; c, boolean complement)    批量删除的方法，参数complement为补集的意思。也就是，当complement为true时，批量删除掉的是补集（即当前列表在指定集合c中的补集），否则批量删除掉的就是集合c。\n源码如下：\nprivate boolean batchRemove(Collection\u0026lt;?\u0026gt; c, boolean complement) { final Object[] elementData = this.elementData; // r：遍历当前集合时遍历到的索引位置；w：“新”对象数组的size  int r = 0, w = 0; boolean modified = false; try { // 遍历当前集合  for (; r \u0026lt; size; r++) // 先求出指定的集合c中是否包含当前迭代到的元素，再根据是否是删除补集来判断出是否要保留当前元素  if (c.contains(elementData[r]) == complement) // 将当前元素从新排入对象数组  elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection,  // even if c.contains() throws.  // 此处，如果r和size不相等，说明在遍历当前集合的过程中抛出了异常，未能遍历完  if (r != size) { // 此时将遍历停止的位置及之后的元素拼接到对象数组的w位置之后  System.arraycopy(elementData, r, elementData, w, size - r); // “新”对象数组的size加上后面那些没遍历到的元素个数，这就是调用完此方法后当前列表的元素个数了  w += size - r; } // 如果“新”对象数组的元素个数与当前列表的元素个数不相等，说明有元素被删除了  if (w != size) { // clear to let GC do its work  // 遍历对象数组从“新”数组大小之后的元素，对其逐个置为null  for (int i = w; i \u0026lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; } 上述所提到的“新”对象数组，其实数组还是当前列表的对象数组，只不过该方法在删除元素时采用的不是“删除”操作，而是采用的“保留”操作，未被保留的元素相当于被删除了。如果方法判定该元素需保留，则会将它放到对象数组的合适位置，该合适位置是从0开始往后排的，这些位置存放的都是要被保留的元素，这也就是所谓的“新”对象数组。\n 44. private void writeObject(java.io.ObjectOutputStream s)    将ArrayList实例的状态保存到流中（即序列化它）。该列表的对象数组的长度以及其存放的元素（会以正确的顺序）都会被序列化。\n源码如下：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff  // 写出元素数量和任何隐藏的内容  int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone()  // 写出大小作为与 clone() 的行为兼容性的容量  s.writeInt(size); // Write out all elements in the proper order.  // 以合适的顺序写出所有的元素  for (int i=0; i\u0026lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } }  45. private void readObject(java.io.ObjectInputStream s)    从流中重新构造ArrayList实例（即反序列化它）。\n源码如下：\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff  // 读取数量和任意隐藏的内容  s.defaultReadObject(); // Read in capacity  // 读取容量  s.readInt(); // ignored  // 如果容量大于0才读取元素  if (size \u0026gt; 0) { // be like clone(), allocate array based upon size not capacity  // 就像 clone()，根据大小而不是容量分配数组  int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order.  // 以合适的顺序读取所有元素  for (int i=0; i\u0026lt;size; i++) { a[i] = s.readObject(); } } }  46. public ListIterator\u0026lt;E\u0026gt; listIterator(int index)    从列表中的指定位置开始，返回此列表列表迭代器（元素以适当的顺序返回）。指定的索引表示初始调用ListIterator.next将返回的第一个元素。初次调用ListIterator#previous将返回具有指定索引减一的元素。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(int index) { // 对指定索引index进行校验  if (index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;Index: \u0026#34;+index); // 返回一个新ListItr实例  return new ListItr(index); } 如下为一些单元测试：\n@Test public void testListIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); // 指定索引获取的迭代器，调用next方法会获得该索引位置的元素  System.out.println(list.listIterator(2).previous()); System.out.println(list.listIterator(2).next()); // 不指定索引，等同于指定的索引为0，也即从头开始  System.out.println(list.listIterator().hasPrevious()); System.out.println(list.listIterator().next()); } 输出：\n2 3 false 1  47. public ListIterator\u0026lt;E\u0026gt; listIterator()    返回此列表中的元素的列表迭代器（按适当顺序）。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator() { return new ListItr(0); }  48. public Iterator\u0026lt;E\u0026gt; iterator()    返回一个以正确的顺序包含此列表中元素的迭代器。 源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); }  49. private class Itr implements Iterator\u0026lt;E\u0026gt;    优化版本的AbstractList.Itr，实现了Iterator接口。\n49.1 int cursor;    cursor意为游标，其用于标识当前迭代器已经执行到哪个元素位置了。所以，它代表的是下一个要返回的元素的index。\n49.2 int lastRet = -1;    该属性代表的是上一个返回的元素的index。当迭代器还没开始遍历的时候，其为-1。\n49.3 int expectedModCount = modCount;    期望操作数，用于并发修改检查。\n49.4 Itr()    无参构造器。\nItr() {} 49.5 public boolean hasNext()    用于判断当前迭代器是否还有其他元素。\n源码如下：\npublic boolean hasNext() { return cursor != size; } 49.6 public E next()    用于获取迭代器的下一个元素。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { checkForComodification(); // 记录下来当前游标位置  int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 游标后移一位  cursor = i + 1; // 将之前记录下的游标位置i赋值给最近一次返回的索引，然后取出该位置的元素并返回  return (E) elementData[lastRet = i]; } 49.7 public void remove()    删除当前元素。\n源码如下：\npublic void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用ArrayList的remove方法删除元素  ArrayList.this.remove(lastRet); // 将上次返回的元素索引赋值给游标  cursor = lastRet; // 将最近返回的元素索引置为-1  lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 49.8 public void forEachRemaining(Consumer consumer)    对迭代器尚未遍历到的元素执行给定的操作。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; // 记录下当前游标位置  int i = cursor; // 如果当前游标位置大于等于列表元素个数，说明已无未遍历到的元素了，直接返回即可  if (i \u0026gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 从当前游标位置一直到列表末尾，对每个元素执行给定的操作  while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic  // 在迭代结束时更新一次游标和lastRet，以减少堆写入流量  cursor = i; lastRet = i - 1; checkForComodification(); } 49.9 final void checkForComodification()    判断是否存在并发修改操作，若存在则抛出并发修改异常。\n源码如下：\nfinal void checkForComodification() { // 修改次数与期望修改次数不等，说明存在并发修改异常  if (modCount != expectedModCount) throw new ConcurrentModificationException(); }  50. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;    优化版本的AbstractList.ListItr，继承了Itr类并实现了ListIterator接口。\n50.1 ListItr(int index)    列表迭代器的构造方法，源码如下：\nListItr(int index) { super(); // 设置游标位置为指定索引  cursor = index; } 50.2 public boolean hasPrevious()    判断当前迭代器是否还有上一个元素，判断依据是当前游标cursor是否不等于0，不等于0，说明还有上一个元素，为0说明已到列表的开始位置，没有上一个元素了。\n源码如下：\npublic boolean hasPrevious() { return cursor != 0; } 50.3 public int nextIndex()    返回下一个元素的索引，其实就是返回当前游标cursor。\n源码如下：\npublic int nextIndex() { return cursor; } 50.4 public int previousIndex()    返回上一个元素的索引，其实就是返回当前游标cursor - 1。\n源码如下：\npublic int previousIndex() { return cursor - 1; } 50.5 public E previous()    返回上一个元素（非上一个返回的元素）。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E previous() { // 进行并发修改检查  checkForComodification(); // 取出上一个元素的索引位置  int i = cursor - 1; // 对得到的索引位置进行范围检查  if (i \u0026lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 将当前游标左移一位  cursor = i; // 将最后返回的索引置为之前算出的索引，然后返回该索引位置的元素  return (E) elementData[lastRet = i]; } 50.6 public void set(E e)    将迭代器最后返回的元素替换为指定的元素e。\n源码如下：\npublic void set(E e) { // lastRet小于0说明没有最近返回的元素或者最近返回的元素已被删除  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.set(lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 50.7 public void add(E e)    在当前游标位置插入指定的元素e。\n源码如下：\npublic void add(E e) { checkForComodification(); try { int i = cursor; // 在游标位置插入元素e  ArrayList.this.add(i, e); // 游标右移一位  cursor = i + 1; // 最近返回的索引置为-1，这个需要特别注意，此处并非置为新插入元素的索引位置  lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } }  51. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    返回当前列表在指定的fromIndex（包含）和toIndex（不包含）之间部分的视图。（如果fromIndex和toIndex相等，则返回的列表为空）返回的列表基于本列表，因此返回列表中的非结构性更改将反映会影响本列表，反之亦然。返回的列表支持列表的所有可选操作。 这种方法消除了显式范围操作（数组中常见的那种操作）的需要。任何期望获得列表的操作都可以用范围操作来代替，通过传递子列表视图而不是整个列表来实现。例如，下面的习惯用法从列表中删除一个元素范围：\nlist.subList(from, to).clear(); indexOf(Object)和lastIndexOf(Object)可以构造类似的习惯用法，并且Collections类中的所有算法都可以应用于子列表。 如果后备列表（即此列表）以除通过返回列表以外的任何其他方式进行结构化修改，则此方法返回的列表的操作将变得不确定。 （结构修改是指更改此列表的大小的结构修改，或以其他方式扰乱此列表的方式，使得正在进行的迭代可能会产生错误的结果。）\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } 示例：\n@Test public void testSubList() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); List\u0026lt;Integer\u0026gt; subList = list.subList(1, 3); System.out.println(list); System.out.println(subList); System.out.println(subList.getClass()); } 输出：\n[1, 2, 3, 4, 5] [2, 3] class java.util.ArrayList$SubList  52. static void subListRangeCheck(int fromIndex, int toIndex, int size)    对子列表的范围进行检查。\n源码如下：\nstatic void subListRangeCheck(int fromIndex, int toIndex, int size) { if (fromIndex \u0026lt; 0) throw new IndexOutOfBoundsException(\u0026#34;fromIndex = \u0026#34; + fromIndex); if (toIndex \u0026gt; size) throw new IndexOutOfBoundsException(\u0026#34;toIndex = \u0026#34; + toIndex); if (fromIndex \u0026gt; toIndex) throw new IllegalArgumentException(\u0026#34;fromIndex(\u0026#34; + fromIndex + \u0026#34;) \u0026gt; toIndex(\u0026#34; + toIndex + \u0026#34;)\u0026#34;); }  53. private class SubList extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess      “子”列表类，更准确地说，其实它是当前ArrayList的一个视图。\n它提供AbstractList可以提供的一切操作，但是它底层并非是像ArrayList一样通过elementData对象数组来存储数据，而是持有它父列表的引用，并且维护一个相对于其父列表的索引偏移量parentOffset，以及一个相对于其最顶层列表（非SubList类的实例，而是ArrayList类的实例）的偏移量offset。\n假设子列表中的某元素在子列表中的索引为subIndex，则该元素在父列表中的索引为：subIndex + parentOffset，在其最顶层的ArrayList中的索引为：subIndex + offset。\n53.1 private final AbstractList\u0026lt;E\u0026gt; parent;    当前子列表的父列表。\n53.2 private final int parentOffset;    当前子列表的父列表在其父列表中的偏移量。\n53.3 private final int offset;    当前子列表在其最顶层的ArrayList列表中的偏移量。\n假设存在ArrayList的实例A：[\u0026quot;零\u0026quot;, \u0026quot;一\u0026quot;, \u0026quot;二\u0026quot;, \u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;, \u0026quot;五\u0026quot;]，\n存在A的子列表SubList的实例S1：[\u0026quot;二\u0026quot;, \u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;]，”二“这个元素在该S1中的索引为0，在其父列表A中的索引为2，此时S1的parentOffset为2，同时S1的offset也为2。\n再假设S1也存在子列表SubList的实例S2：[\u0026quot;三\u0026quot;, \u0026quot;四\u0026quot;]，”四“这个元素在S2中的索引为1，在其父列表S1中的索引为2，在其最顶层的ArrayList列表A中的索引为4，此时S2的parentOffset为1（2 - 1），offset为3（4 - 1）。\n53.4 int size;    当前子列表的大小。\n53.5 SubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex)    SubList类唯一的构造函数。\n源码如下：\nSubList(AbstractList\u0026lt;E\u0026gt; parent, int offset, int fromIndex, int toIndex) { // 执行各种初始化  this.parent = parent; // 将fromIndex置为当前子列表相对于其父列表的偏移量  this.parentOffset = fromIndex; // 将当前子列表相对于其最顶级列表的偏移量加上当前子列表相对于其父列表的偏移量  this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; } 53.6 public E set(int index, E e)    设置当前子列表指定索引位置的元素为指定的元素e。\n源码如下：\npublic E set(int index, E e) { // 首先对指定索引index进行检查  rangeCheck(index); // 检查是否存在并发修改  checkForComodification(); // 首先计算出当前子列表中的index位置转换为其父列表的index（即当前指定索引加上偏移量）  // 调用父类的elementData方法取出对应位置的元素  E oldValue = ArrayList.this.elementData(offset + index); // 将父类对应位置的元素替换为指定的元素e  ArrayList.this.elementData[offset + index] = e; // 返回旧元素  return oldValue; } 53.7 public E get(int index)    获取指定索引位置的元素。\n源码如下：\npublic E get(int index) { // 首先进行范围检查  rangeCheck(index); // 进行并发修改检查  checkForComodification(); // 通过指定索引index和偏移量计算出目标元素在父列表中的位置，然后从父列表中将其取出并返回  return ArrayList.this.elementData(offset + index); } 53.8 public int size()    获取当前子列表的大小。\n源码如下：\npublic int size() { // 并发修改检查  checkForComodification(); // 返回当前子列表大小  return this.size; } 53.9 public void add(int index, E e)    向指定索引位置插入指定元素。\n源码如下：\npublic void add(int index, E e) { // 校验指定索引是否满足新增的要求  rangeCheckForAdd(index); // 并发修改校验  checkForComodification(); // 此处是调用的父类的add方法，而非最顶层的ArrayList的add方法  // 所以计算索引时，要使用parentOffset，而非offset  parent.add(parentOffset + index, e); this.modCount = parent.modCount; // 列表大小加1  this.size++; } 53.10 public E remove(int index)    删除指定索引位置的元素，并将该元素返回。\n源码如下：\npublic E remove(int index) { rangeCheck(index); checkForComodification(); // 与add一样，删除也是调用父类的方法，所以计算索引时要使用parentOffset  E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; } 53.11 protected void removeRange(int fromIndex, int toIndex)    删除索引在指定返回范围fromIndex（包含）和toIndex（不包含）之间的元素。\nprotected void removeRange(int fromIndex, int toIndex) { checkForComodification(); // 也是调用父类的范围删除方法来执行删除，所以使用parentOffset计算索引  parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; } 53.12 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前子列表的末尾。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 调用addAll方法，指定插入位置的索引为当前列表的size大小处，也即紧接着列表的末尾后面  return addAll(this.size, c); } 53.13 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前子列表的指定索引处。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { rangeCheckForAdd(index); int cSize = c.size(); // 指定的列表没有元素，直接返回false  if (cSize==0) return false; checkForComodification(); // 调用父类的插入方法  parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; } 53.14 public Iterator\u0026lt;E\u0026gt; iterator()    获取迭代器。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 调用AbstractList中的listIterator()方法获取迭代器  return listIterator(); } 53.15 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index)    获取从指定位置开始的迭代器。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { checkForComodification(); // 此处借用了插入元素时的索引校验方法，即允许指定的索引为列表的size  rangeCheckForAdd(index); final int offset = this.offset; // 此处返回一个ListIterator接口的匿名内部类的实例  return new ListIterator\u0026lt;E\u0026gt;() { // 游标等于指定索引  int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; // 判断是否还有下一个元素  public boolean hasNext() { // 判断当前游标是否等于当前子列表的大小  return cursor != SubList.this.size; } // 获取下一个元素  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 计算元素在顶层的ArrayList列表内的索引，若大于等于数组长度，则报错  if (offset + i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 游标右移一位  cursor = i + 1; // 将原游标位置赋值给最近返回的元素索引  // 计算出要取出的元素在其顶层的ArrayList中的索引位置  // 通过顶层列表的对象数组elementData获取对应索引位置的元素  return (E) elementData[offset + (lastRet = i)]; } // 判断前面是否还有元素  public boolean hasPrevious() { // 判断当前游标是否为0  return cursor != 0; } // 获取前面一个元素  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E previous() { checkForComodification(); // 计算出前一个元素在当前子列表中的索引位置  int i = cursor - 1; if (i \u0026lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 计算出前一个元素在顶层的ArrayList中的索引位置，并校验  if (offset + i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 这一步相当于是游标前移一位  cursor = i; // 将最近返回的索引位置置为前一个元素，并返回该元素  return (E) elementData[offset + (lastRet = i)]; } // 对剩下未遍历到的元素执行给定的操作  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; consumer) { Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; // 游标已在子列表末尾或之后，则说明已无未迭代到的元素，直接返回  if (i \u0026gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; // 计算出当前游标在顶层ArrayList中的索引位置，并校验  if (offset + i \u0026gt;= elementData.length) { throw new ConcurrentModificationException(); } // 从游标位置开始往后遍历，直到当前子列表的末尾，对每个元素执行给定的操作  while (i != size \u0026amp;\u0026amp; modCount == expectedModCount) { consumer.accept((E) elementData[offset + (i++)]); } // update once at end of iteration to reduce heap write traffic  // 最近返回索引和当前游标均一次性更新至子列表末尾  lastRet = cursor = i; checkForComodification(); } // 获取下一个元素索引  public int nextIndex() { // 返回当前游标  return cursor; } // 获取上一个元素索引  public int previousIndex() { // 返回当前游标之前的位置  return cursor - 1; } // 删除迭代器当前迭代到的元素  public void remove() { // 最近返回元素小于0，将抛出异常  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用子列表的remove方法删除对应元素  SubList.this.remove(lastRet); // 将游标置于最近返回的元素索引位置，相当于左移一位  cursor = lastRet; // 将最近返回的索引位置置为-1  lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 替换最近返回的索引位置的元素为指定的元素  public void set(E e) { // 最近返回的索引位置不可小于0，否则可能是迭代器还未获取过元素，或者已经进行了元素的增加（add）或删除（remove）  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 计算出元素在顶层ArrayList中的索引位置，用ArrayList的set方法替换元素  ArrayList.this.set(offset + lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 在当前游标位置插入指定元素  public void add(E e) { checkForComodification(); try { int i = cursor; // 调用子列表的add方法，在当前游标位置插入指定元素  SubList.this.add(i, e); // 将游标右移一位  cursor = i + 1; // 将最近返回的索引置为-1  lastRet = -1; expectedModCount = ArrayList.this.modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 检查是否存在并发修改  final void checkForComodification() { // 如果子列表的期望修改次数不等于ArrayList修改次数，说明存在并发修改  if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); } }; } 53.16 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    获取当前SubList实例的子列表。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); // 看，此处传入的offset为当前子列表的offset，而非ArrayList的subList方法中传入的0  return new SubList(this, offset, fromIndex, toIndex); } 53.17 private void rangeCheck(int index)    对指定索引进行合法性检查。\n源码如下：\nprivate void rangeCheck(int index) { // 指定的索引必须大于0且小于size，否则将造成数据越界  if (index \u0026lt; 0 || index \u0026gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 53.18 private void rangeCheckForAdd(int index)    在列表插入元素时，对插入位置进行校验。\n源码如下：\nprivate void rangeCheckForAdd(int index) { // 相较于rangeCheck，本校验方法允许指定索引等于size，因为可以往size位置插入元素  if (index \u0026lt; 0 || index \u0026gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 53.19 private String outOfBoundsMsg(int index)    获取数组越界异常的提示信息。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+this.size; } 53.20 private void checkForComodification()    检查列表是否存在并发修改。\n源码如下：\nprivate void checkForComodification() { // 判断ArrayList的修改次数与当前子列表的修改次数是否一致，否则抛出并发修改异常  if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); } 53.21 public Spliterator\u0026lt;E\u0026gt; spliterator()    获取当前子列表的拆分器。\n源码如下：\npublic Spliterator\u0026lt;E\u0026gt; spliterator() { checkForComodification(); // 注意，此处传入的是ArrayList，而非当前子列表  return new ArrayListSpliterator\u0026lt;E\u0026gt;(ArrayList.this, offset, offset + this.size, this.modCount); }  54. public void forEach(Consumer\u0026lt;? super E\u0026gt; action)    遍历当前列表，对每个元素执行给定的操作，直到每个元素都被迭代到或者中间出了异常。\n源码如下：\n@Override public void forEach(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前列表的对象数组，待会就遍历它  final E[] elementData = (E[]) this.elementData; final int size = this.size; // 遍历时每次循环都校验是否存在并发修改，存在则直接结束遍历  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { action.accept(elementData[i]); } // 若存在并发修改，直接抛出异常  if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } }  55. public Spliterator\u0026lt;E\u0026gt; spliterator()    在此列表中的元素上创建一个“后期绑定”和“快速失败”的Spliterator。Spliterator报告Spliterator#SIZED、Spliterator#SUBSIZED和Spliterator#ORDERED。覆盖本实现应该记录其他特征值的描述。\n源码如下：\n@Override public Spliterator\u0026lt;E\u0026gt; spliterator() { return new ArrayListSpliterator\u0026lt;\u0026gt;(this, 0, -1, 0); }  56. static final class ArrayListSpliterator\u0026lt;E\u0026gt; implements Spliterator\u0026lt;E\u0026gt;    基于索引一分为二、延迟初始化的Spliterator。\n如果ArrayList是不可变的或结构上不可变的（没有添加，删除等），我们可以使用Arrays.spliterator实现它们的分隔器。相反，我们在不牺牲太多性能的情况下，在遍历过程中检测到尽可能多的干扰。我们主要依靠modCounts，这不能保证检测到并发冲突，并且有时对线程内干扰过于保守，但是可以检测到足够的问题，值得在实践中使用。为了实现这一点：\n 我们延迟初始化fence和expectedModCount，直到需要提交给正在检查状态的最新点，从而提高精度。 （这不适用于SubList，因为SubList会创建带有当前非惰性值的Spliterator）。 我们仅在 forEach（对性能最敏感的方法）结束时执行一次 ConcurrentModificationException 检查。当使用forEach（而不是迭代器）时，我们通常只能在动作之后检测干扰，而不是之前。进一步的 CME 触发检查适用于所有其他可能不符合预期的情况，例如 null 或给定 size() 的太小的 elementData 数组，这可能仅由于干扰而发生。这允许 forEach 的内部循环在没有任何进一步检查的情况下运行，并简化了 lambda 解析。虽然这确实需要一些检查，但请注意，在 list.stream().forEach(a) 的常见情况下，除了 forEach 本身之外，不会在任何地方进行检查或其他计算。其他不太常用的方法无法利用这些精简中的大部分。  56.1 private final ArrayList\u0026lt;E\u0026gt; list;    该拆分器所属的list。\n56.2 private int index;    当前索引，在前进（advance）或拆分（split）时修改。\n56.3 private int fence;    直到使用前都是-1，然后直到最后一个索引。\n56.4 private int expectedModCount;    期望修改次数，设置fence时初始化。\n56.5 ArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount)    创建覆盖给定范围的新拆分器。\n源码如下：\nArrayListSpliterator(ArrayList\u0026lt;E\u0026gt; list, int origin, int fence, int expectedModCount) { // 参数中的list可以为空，除非要遍历它  this.list = list; // OK if null unless traversed  // 属性值初始化  this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; } 56.6 private int getFence()    第一次使用时，初始化围栏fence大小。\n源码如下：\nprivate int getFence() { // initialize fence to size on first use  int hi; // (a specialized variant appears in method forEach)  ArrayList\u0026lt;E\u0026gt; lst; // 将fence大于等于0，直接返回该值  if ((hi = fence) \u0026lt; 0) { // 如果list为空，则fence初始化为0，并最终返回0  if ((lst = list) == null) hi = fence = 0; else { // 如果list不为空  // 初始化拆分器的期望修改次数  expectedModCount = lst.modCount; // 将fence初始化为列表的大小  hi = fence = lst.size; } } return hi; } 56.7 public ArrayListSpliterator\u0026lt;E\u0026gt; trySplit()    执行拆分。\n源码如下：\npublic ArrayListSpliterator\u0026lt;E\u0026gt; trySplit() { // hi = getFence()，这一步是获取围栏位置  // lo = index，这一步是获取当前索引  // mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1，这一步很关键，求取当前迭代到的位置直到围栏位置的中间索引位置，将用于拆分出新拆分器  int hi = getFence(), lo = index, mid = (lo + hi) \u0026gt;\u0026gt;\u0026gt; 1; // 除非太小，否则将范围分成两半  return (lo \u0026gt;= mid) ? null : // divide range in half unless too small  // 拆分出去的新拆分器，是从当前迭代到的位置至上面求出的中间位置  // 此处还有一个不明显但很关键的操作：index = mid，这一步是将当前老拆分器的迭代位置置为上面求出的中间位置  // 这样老拆分器就一分为二了，新拆分器负责前半部分，老拆分器负责后半部分  new ArrayListSpliterator\u0026lt;E\u0026gt;(list, lo, index = mid, expectedModCount); } 例如：\n存在一个ArrayList，其size为35，然后其调用spliterator()获取到一个拆分器，此时该拆分器的fence为-1，index为0。\n若此时对该拆分器执行拆分（trySplit()）操作： 首先调用getFence()获取围栏大小，此方法中会对fence做初始化，最终拿到的fence是35，在加上当前索引为0，则计算出的中间值为17（(35 + 0) \u0026gt;\u0026gt;\u0026gt; 1 = 17）。 当前索引为0，小于中间值，此时可以进行拆分，此时方法返回的新拆分器实例的属性分别为：index为0，fence为17。同时，原拆分器的index更新为17。 此时就相当于一个持有35个元素的拆分器，拆分出去了一个持有17个元素的拆分器，自己还剩18个元素。（所谓“持有”，其实这两个拆分器都是持有该拆分器所属的list，但通过围栏字段fence区分出每个拆分器所负责的那一部分）\n如图所示：\n 56.8 public boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action)    对当前拆分器迭代到的元素执行给定的操作action。\n源码如下：\npublic boolean tryAdvance(Consumer\u0026lt;? super E\u0026gt; action) { if (action == null) throw new NullPointerException(); // 获取围栏位置以及当前索引  int hi = getFence(), i = index; // 如果当前索引大于等于围栏位置，说明所有元素均已遍历完，此时没有元素执行给定的操作  if (i \u0026lt; hi) { // 将索引右移一位  index = i + 1; // 取出右移前索引位置的元素  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E)list.elementData[i]; // 对取出的元素执行给定的操作  action.accept(e); // 校验是否存在并发修改  if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; } return false; } 56.9 public void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对当前拆分器剩余未迭代到的元素执行给定的操作action。所谓剩余是指：从当前索引位置到围栏位置之间的元素。\n源码如下：\npublic void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { int i, hi, mc; // hoist accesses and checks from loop  ArrayList\u0026lt;E\u0026gt; lst; Object[] a; if (action == null) throw new NullPointerException(); // 列表必须不能为空，否则抛出并发修改异常  if ((lst = list) != null \u0026amp;\u0026amp; (a = lst.elementData) != null) { // 如果围栏位置小于0，可能是刚基于列表创建的拆分器  if ((hi = fence) \u0026lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; // 如果当前索引位置大于等于0 且 围栏位置小于等于列表中对象数组的长度，则迭代数组  // 此处的隐秘操作：index = hi，这一步将拆分器的当前索引推至围栏位置了  if ((i = index) \u0026gt;= 0 \u0026amp;\u0026amp; (index = hi) \u0026lt;= a.length) { for (; i \u0026lt; hi; ++i) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) a[i]; action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); } 56.10 public long estimateSize()    获取当前拆分器还未进行操作的元素数量。\n源码如下：\npublic long estimateSize() { // 所有获取围栏位置，然后减去当前索引  return (long) (getFence() - index); } 56.11 public int characteristics()    该方法是返回当前拆分器的特征值，就ArrayListSpliterator而言，其特征值有：Spliterator.ORDERED、Spliterator.SIZED、Spliterator.SUBSIZED。\n源码如下：\npublic int characteristics() { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; }  57. public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter)    参数为一个断言，该方法即对当前列表的每个元素执行该断言的test方法，命中的则在当前列表中删除，最后返回的是是否删除了本列表的元素。\n源码如下：\n@Override public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); // figure out which elements are to be removed  // any exception thrown from the filter predicate at this stage  // will leave the collection unmodified  // 找出要删除哪些元素，在此阶段从断言中抛出的任何异常都不会使集合改变  int removeCount = 0; // 声明一个BitSet，用于存储要删除元素的索引  final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; // 从头开始遍历列表，先找出符合删除条件的元素索引  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 取出当前迭代到的元素  final E element = (E) elementData[i]; // 对取出的元素执行给定的测试  if (filter.test(element)) { // 若满足条件，将该索引记录到removeSet，并将删除数量加1  removeSet.set(i); removeCount++; } } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } // shift surviving elements left over the spaces left by removed elements  // 将剩下的元素移动到已删除元素留下的空间上  final boolean anyToRemove = removeCount \u0026gt; 0; // 上面找到了要删除的元素才执行下面的操作  if (anyToRemove) { // 计算出新的列表大小  final int newSize = size - removeCount; // 遍历列表，直到新的列表大小位置处  for (int i=0, j=0; (i \u0026lt; size) \u0026amp;\u0026amp; (j \u0026lt; newSize); i++, j++) { // 找到下一个未删除的元素索引  i = removeSet.nextClearBit(i); // 将该索引位置的元素复制到j位置  elementData[j] = elementData[i]; } // 将新列表尾部的元素都置为null（这些元素都已被复制到前面，覆盖了前面被删掉的元素）  for (int k=newSize; k \u0026lt; size; k++) { elementData[k] = null; // Let gc do its work  } // 将新列表的大小赋值给当前列表大小  this.size = newSize; // 执行并发修改检查  if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } return anyToRemove; } 如下为示例：\n@Test public void testRemoveIf() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.removeIf(l -\u0026gt; l \u0026gt;1 \u0026amp;\u0026amp; l \u0026lt; 4); System.out.println(list); } 输出：\n[1, 4, 5]  58. public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator)    对列表中每个元素执行参数中指定的操作，并使用此操作获得的值代替当前位置上的元素。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; // 遍历当前列表  for (int i=0; modCount == expectedModCount \u0026amp;\u0026amp; i \u0026lt; size; i++) { // 对每个元素执行给定的操作，使用计算出的结果替代当前元素  elementData[i] = operator.apply((E) elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 如下所示：\n@Test public void testReplaceAll() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.replaceAll(i -\u0026gt; i * 5); System.out.println(list); } 输出：\n[5, 10, 15, 20, 25]  59. public void sort(Comparator\u0026lt;? super E\u0026gt; c)    基于参数中指定的比较器，对当前列表进行排序。\n源码如下：\n@Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public void sort(Comparator\u0026lt;? super E\u0026gt; c) { final int expectedModCount = modCount; // 使用Arrays的sort方法对当前列表的元素数组执行排序  Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 如下所示：\n@Test public void testSort() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.sort(Comparator.comparingInt(i -\u0026gt; -i)); System.out.println(list); } 输出：\n[5, 4, 3, 2, 1] "},{"id":6,"href":"/jdk8-src-note/java/util/AbstractSequentialList/","title":"AbstractSequentialList","parent":"util","content":"  1. protected AbstractSequentialList() 2. public E get(int index) 3. public E set(int index, E element) 4. public void add(int index, E element) 5. public E remove(int index) 6. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 7. public Iterator\u0026lt;E\u0026gt; iterator() 8. public abstract ListIterator\u0026lt;E\u0026gt; listIterator(int index);     此类提供List接口的基本实现，以减少实现支持“顺序访问”数据存储（例如链表）的该接口所需的工作。对于随机访问数据（例如数组），应优先使用AbstractList类。\n该类与AbstractList类相反，因为它在列表的列表迭代器的顶部实现了“随机访问”方法（get(int index)，set(int index, E element)，add(int index, E element)，remove(int index)），而不是相反。\n要实现一个列表，编程者仅需要扩展此类并为listIterator和size方法提供实现。对于不可修改的列表，编程者只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。\n对于可修改的列表，编程者应该另外实现列表迭代器的set方法。对于可变大小的列表，程序员应该另外实现列表迭代器的remove和add方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）和参数为Collection的构造函数。\n该接口是Java集合框架的成员接口。\n 1. protected AbstractSequentialList()    唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n 2. public E get(int index)    返回此列表中指定位置的元素。\n此实现首先获取一个指向索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.next获取元素并返回它。\n 3. public E set(int index, E element)    用指定的元素替换此列表中指定位置的元素（可选操作）。\n此实现首先获取一个指向索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.next获取当前元素，并将其使用ListIterator.set替换。\n请注意，如果列表迭代器未实现set操作，则此实现将抛出UnsupportedOperationException。\n 4. public void add(int index, E element)    将指定的元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。\n此实现首先获取一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.add 插入指定的元素。\n请注意，如果列表迭代器未实现add操作，则此实现将抛出UnsupportedOperationException。\n 5. public E remove(int index)    删除此列表中指定位置的元素（可选操作）。将所有后续元素向左移动（将其索引减一）。返回从列表中删除的元素。\n此实现首先获取一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，它使用ListIterator.remove删除该元素。\n请注意，如果列表迭代器未实现remove操作，则此实现将抛出UnsupportedOperationException。\n 6. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    将指定集合中的所有元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在此列表中。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n此实现在指定集合上获得一个迭代器，并在此列表上获得一个指向指定索引元素的列表迭代器（使用listIterator(index)）。然后，遍历指定的集合，使用ListIterator.next（跳过已插入的元素）之后接着使用ListIterator.add，将从迭代器获得的元素一次插入到此列表中。\n请注意，如果listIterator方法返回的列表迭代器未实现add操作，则此实现将引发UnsupportedOperationException。\n 7. public Iterator\u0026lt;E\u0026gt; iterator()    返回此列表中元素的迭代器（按适当顺序）。\n此实现仅返回列表上的列表迭代器。\n 8. public abstract ListIterator\u0026lt;E\u0026gt; listIterator(int index);    返回此列表中的元素的列表迭代器（按适当顺序）。\n"},{"id":7,"href":"/jdk8-src-note/java/util/RandomAccess/","title":"RandomAccess","parent":"util","content":" List 接口的实现类所使用的标记接口，标识出它们支持快速（通常为恒定时间）随机访问。该接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问或顺序访问列表时提供良好的性能。\n当用于操纵随机访问列表（例如ArrayList）的最佳算法应用于顺序访问列表（例如LinkedList）时，会产生二次行为。鼓励通用的列表算法在应用一种算法（如果将其应用于顺序访问列表时会产生较差的性能）之前，检查给定列表是否为此接口的实例（通过instanceof判断），并在必要时更改其行为以确保可接受的性能。\n公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现会提供渐近线性的访问时间（如果它们变得很大），但实际上却是恒定的访问时间。这样的List实现通常应实现此接口。根据经验，对于类的典型实例，在以下场景下当循环1快于循环2时List实现应实现此接口：\n循环1：\nfor (int i=0, n=list.size(); i \u0026lt; n; i++) list.get(i); 循环2：\nfor (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 该接口也是Java集合框架成员。\n"},{"id":8,"href":"/jdk8-src-note/java/util/AbstractList/","title":"AbstractList","parent":"util","content":"  1. protected AbstractList() 2. public boolean add(E e) 3. abstract public E get(int index); 4. public E set(int index, E element) 5. public void add(int index, E element) 6. public E remove(int index) 7. public int indexOf(Object o) 8. public int lastIndexOf(Object o) 9. public void clear() 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 11. public Iterator\u0026lt;E\u0026gt; iterator() 12. public ListIterator\u0026lt;E\u0026gt; listIterator() 13. public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 14. private class Itr implements Iterator\u0026lt;E\u0026gt;  14.1 int cursor = 0; 14.2 int lastRet = -1; 14.3 int expectedModCount = modCount; 14.4 public boolean hasNext() 14.5 public E next() 14.6 public void remove() 14.7 final void checkForComodification()   15. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;  15.1 ListItr(int index) 15.2 public boolean hasPrevious() 15.3 public E previous() 15.4 public int nextIndex() 15.5 public int previousIndex() 15.6 public void set(E e) 15.7 public void add(E e)   16. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 17. public boolean equals(Object o) 18. public int hashCode() 19. protected void removeRange(int fromIndex, int toIndex) 20. protected transient int modCount = 0; 21. private void rangeCheckForAdd(int index) 22. private String outOfBoundsMsg(int index) 同一文件中的其他类  1. class SubList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt;  1.1 private final AbstractList\u0026lt;E\u0026gt; l; 1.2 private final int offset; 1.3 private int size; 1.4 SubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 1.5 public E set(int index, E element) 1.6 public E get(int index) 1.7 public int size() 1.8 public void add(int index, E element) 1.9 public E remove(int index) 1.10 protected void removeRange(int fromIndex, int toIndex) 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 1.13 public Iterator\u0026lt;E\u0026gt; iterator() 1.14 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index) 1.15 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) 1.16 private void rangeCheck(int index) 1.17 private void rangeCheckForAdd(int index) 1.18 private String outOfBoundsMsg(int index) 1.19 private void checkForComodification()   2. class RandomAccessSubList\u0026lt;E\u0026gt; extends SubList\u0026lt;E\u0026gt; implements RandomAccess  2.1 RandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) 2.2 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)         此类提供List接口的基本实现，以最大程度地减少实现支持“随机访问”数据存储（例如数组）所需的工作。对于顺序访问数据（例如链表），应优先使用AbstractSequentialList类。\n要实现不可修改的列表，编程者仅需扩展此类并为get和List的size方法提供实现。\n要实现可修改的列表，编程者必须另外重写set方法（否则将抛出UnsupportedOperationException）。如果列表是可变大小的，则程序员必须另外重写add和remove方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）的构造函数。\n与其他抽象集合的实现不同，编程者不必提供迭代器实现。迭代器和列表迭代器由此类在“随机访问”方法之上实现：\nget、set、add、remove。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合允许更有效的实现，则可以覆盖这些方法中的每一个。\n该类是Java集合框架的成员。\n1. protected AbstractList()    唯一构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractList() { } 2. public boolean add(E e)    将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制哪些元素可以添加到此列表。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n该方法的实现调用了add(int index, E element)方法，add(int index, E element)的默认实现是抛出UnsupportedOperationException，所以如果不重写它，那么调用当前方法也会抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { add(size(), e); return true; } 3. abstract public E get(int index);    获取列表在指定索引位置的元素。\n4. public E set(int index, E element)    在指定的索引位置设置指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E set(int index, E element) { throw new UnsupportedOperationException(); } 5. public void add(int index, E element)    在指定的索引位置添加指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic void add(int index, E element) { throw new UnsupportedOperationException(); } 6. public E remove(int index)    删除指定索引位置的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E remove(int index) { throw new UnsupportedOperationException(); } 7. public int indexOf(Object o)    此实现首先获取一个列表迭代器（通过listIterator()）。然后，在列表上进行迭代，直到找到指定的元素或到达列表的末尾。\n此方法，在通过listIterator()方法获取到列表迭代器后，逐个遍历元素：\n如果参数中给定的元素为null则判断next获得的元素是否为null，若是，则返回previousIndex。\n如果参数中给定的元素不为null，则通过equals方法判断next获取的元素是否和参数中给定的元素相同，若相同则返回则返回previousIndex。\n如果未能找到，则返回-1。\n源码如下：\npublic int indexOf(Object o) { // 此处获取的是列表迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(); if (o==null) { while (it.hasNext()) // 此处已调用过next方法，所以一旦命中，需要返回的是previousIndex()  if (it.next()==null) return it.previousIndex(); } else { while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); } return -1; } 8. public int lastIndexOf(Object o)    此实现首先获取一个指向列表末尾的列表迭代器（使用listIterator(size())）。然后，向后迭代列表，直到找到指定的元素，或者到达列表的开头。\n寻找元素的方法和indexOf方法一致，区别在于，本方法是从后往前找，也就是找的是指定的元素在列表中最后一次出现的位置，没找到则返回-1。\n源码如下：\npublic int lastIndexOf(Object o) { // 获取一个从列表末尾开始的迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(size()); if (o==null) { while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); } else { while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); } return -1; } 9. public void clear()    从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n该实现将调用removeRange(0, size())。\n请注意，如果未重写remove(int index)或removeRange(int fromIndex, int toIndex)，本方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { removeRange(0, size()); } 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    此实现在参数中指定的集合上获得一个迭代器并对其进行迭代，使用add(int, E)将从迭代器获得的元素插入到此列表的适当位置，一次插入一个。\n为了提高效率，许多实现将覆盖此方法。\n请注意，除非重写add(int, Object)和add(int, E)，否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断指定的索引是否符合插入位置的范围限制  rangeCheckForAdd(index); boolean modified = false; // 调用遍历指定的集合c，将迭代到的每个元素放入当前集合  for (E e : c) { add(index++, e); modified = true; } return modified; } 11. public Iterator\u0026lt;E\u0026gt; iterator()    以正确的顺序返回在此列表元素上的迭代器。\n此实现依赖于来源列表的size()，get(int)和remove(int)方法来返回迭代器接口的简单实现。\n请注意，除非重写列表的remove(int)方法，否则此方法返回的迭代器将在调用其remove方法时抛出UnsupportedOperationException。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 返回一个Itr实例  return new Itr(); } 12. public ListIterator\u0026lt;E\u0026gt; listIterator()    本方法将调用listIterator(final int index)方法，只不过传入的index为0。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator() { return listIterator(0); } 13. public ListIterator\u0026lt;E\u0026gt; listIterator(final int index)    此实现返回ListIterator接口的直接实现，该接口继承了iterator()方法所返回的Iterator接口。ListIterator实现依赖于来源列表的get(int)，set(int, E)，add(int, E)和remove(int)方法。\n请注意，此实现返回的列表迭代器在调用其remove，set和add方法时抛出UnsupportedOperationException，除非列表的remove(int)，set(int, E)和add(int, E)方法已被重写。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 判断index的大小是否符合范围限制  rangeCheckForAdd(index); // 返回一个从index位置开始的ListItr实例  return new ListItr(index); } 14. private class Itr implements Iterator\u0026lt;E\u0026gt;    14.1 int cursor = 0;    迭代器在遍历列表时，游标所在位置。也即后续调用next所返回元素的索引。\n14.2 int lastRet = -1;    最近一次调用next或previous返回的元素的索引。如果通过调用remove删除了此元素，则重置为-1。\n14.3 int expectedModCount = modCount;    迭代器认为来源列表应该具有的modCount值。如果违反了此期望，则说明迭代器已检测到并发修改。\n14.4 public boolean hasNext()    判断是否还有其他元素，如果调用next还能获取到元素，则该方法应返回true。\n源码如下：\npublic boolean hasNext() { // 判断当前游标cursor是否与列表的元素数量相等  return cursor != size(); } 14.5 public E next()    获取下一个元素。\n源码如下：\npublic E next() { // 检查是否存在并发修改  checkForComodification(); try { // 将当前游标位置赋值给变量i  int i = cursor; // 取出当前游标位置的元素，作为next  E next = get(i); // 设置最近返回的元素索引为i  lastRet = i; // 游标后移一位，即在当前值基础上加1  cursor = i + 1; // 返回之前取出的游标位置的元素  return next; } catch (IndexOutOfBoundsException e) { // 遇到数组下标越界异常，先检查是否存在并发修改，如不存在，则抛出无此元素异常  checkForComodification(); throw new NoSuchElementException(); } } 14.6 public void remove()    删除当前元素。\n源码如下：\npublic void remove() { // 如果lastRet小于0，则抛出IllegalStateException  // 这说明要么迭代器初始化好之后还没有调用过next或previous、要么当前元素已被删除了  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用列表的remove方法删除lastRet索引位置的元素  AbstractList.this.remove(lastRet); // 如果lastRet小于游标，则需将游标位置前移1位  if (lastRet \u0026lt; cursor) cursor--; // 将lastRet置为-1  lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { // 捕获到IndexOutOfBoundsException则说明存在并发修改，抛出ConcurrentModificationException  throw new ConcurrentModificationException(); } } 14.7 final void checkForComodification()    该方法旨在检查是否存在并发修改，判断方法即判断expectedModCount是否等于modCount，不等于则说明存在并发修改，则抛出ConcurrentModificationException。\n源码如下：\nfinal void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 15. private class ListItr extends Itr implements ListIterator\u0026lt;E\u0026gt;    15.1 ListItr(int index)    构造一个列表迭代器，使用给定的参数index作为当前列表迭代器的游标位置。\n源码如下：\nListItr(int index) { cursor = index; } 15.2 public boolean hasPrevious()    判断当前迭代器前面是否还有元素，判断方法是：当前的游标位置cursor是否为0，为0则说明前面已经没有元素了，此时返回false，否则返回true。\n源码如下：\npublic boolean hasPrevious() { return cursor != 0; } 15.3 public E previous()    获取上一个元素，获取方法为：\n使用当前游标位置减1，算出上一个元素的位置，然后取出该位置的元素，同时设置lastRet和游标位置cursor为该位置，然后返回该元素。\n源码如下：\npublic E previous() { checkForComodification(); try { // 将当前游标的前一位赋值给变量i  int i = cursor - 1; // 获取i位置的元素作为返回值  E previous = get(i); // 将最近返回的索引位置和游标位置均置为i  lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 15.4 public int nextIndex()    获取下一个元素的索引，获取方法是：直接返回当前游标位置cursor。\n源码如下：\npublic int nextIndex() { return cursor; } 15.5 public int previousIndex()    获取上一个元素的索引，获取方法是：返回当前游标位置cursor-1。\n源码如下：\npublic int previousIndex() { return cursor-1; } 15.6 public void set(E e)    设置当前位置（lastRet位置）的元素为参数中给定的元素，也即替换最后一次调用next或previous方法得到的元素。\n首先，判断lastRet是否小于0，小于0说明其还未调用过next或previous或者调用过remove方法已将当前位置的元素删掉或使用add方法添加了元素，如果小于0，则抛出IllegalStateException。然后检查是否存在并发修改，调用AbstractList的set方法进行赋值。\n源码如下：\npublic void set(E e) { // lastRet小于0说明其还未调用过next或previous  // 或者调用过remove方法已将当前位置的元素删掉  // 或者使用add方法添加了元素  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 使用列表的set方法进行元素的替换  AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 15.7 public void add(E e)    首先检查是否存在并发修改，然后在调用AbstractList的add方法在当前游标位置添加给定的元素。然后，将lastRet置为-1，同时将当前游标位置cursor加1。\n源码如下：\npublic void add(E e) { checkForComodification(); try { // 将当前游标的值赋给变量i  int i = cursor; // 调用列表的add方法将指定的元素e插入到列表的i位置处  AbstractList.this.add(i, e); // 设定最近返回的索引位置为-1  lastRet = -1; // 设定当前游标位置加1  cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 16. public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    此实现返回一个AbstractList的子类的列表。子类在私有字段中存储来源列表中子列表的偏移量、子列表的大小（可以在其生存期内更改）以及来源列表的预期modCount值。子类有两种变体，其中一种实现RandomAccess。如果此列表实现RandomAccess，则返回的列表将是实现RandomAccess的子类的实例。\n子类的set(int, E)，get(int)，add(int, E)，remove(int)，addAll(int, Collection)和removeRange(int, int)方法都在对索引进行边界检查并调整了偏移量之后，委派给了抽象列表上的相应方法。 addAll(Collection c)方法仅返回addAll(size, c)。\nlistIterator(int)方法在来源列表的列表迭代器上返回“包装对象”，该列表迭代器是使用来源列表上的相应方法创建的。iterator方法仅返回listIterator()，而size方法仅返回子类的size字段。\n所有方法首先检查来源列表的实际modCount是否等于其期望值，如果不是，则抛出ConcurrentModificationException。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { // 判断当前列表是否是RandomAccess的实例  // 若是，则返回一个RandomAccessSubList实例，否则返回SubList实例  return (this instanceof RandomAccess ? new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex) : new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex)); } 17. public boolean equals(Object o)    比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时，才返回true。 （如果(e1==null ? e2==null : e1.equals(e2))，则两个元素e1和e2是相等。）换句话说，如果两个列表包含相同顺序的相同元素，则定义为相等。\n此实现首先检查指定的对象是否是此列表。如果是，则返回true，如果不是，则检查指定对象是否为列表。如果不是列表，则返回false，如果是列表，则遍历两个列表，比较对应的元素对。如果有任何比较返回false，则此方法返回false。如果一个迭代器在另一个迭代器之前用尽了元素，则返回false（因为列表的长度不相等），否则，当迭代完成时，它将返回true。\n源码如下：\npublic boolean equals(Object o) { // 指定对象等于当前列表则直接返回true  if (o == this) return true; // 指定对象不是List接口的实例则直接返回false  if (!(o instanceof List)) return false; ListIterator\u0026lt;E\u0026gt; e1 = listIterator(); ListIterator\u0026lt;?\u0026gt; e2 = ((List\u0026lt;?\u0026gt;) o).listIterator(); // 同时遍历两个列表  while (e1.hasNext() \u0026amp;\u0026amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); // 如果发现存在一个元素不匹配，则返回false  if (!(o1==null ? o2==null : o1.equals(o2))) return false; } // 如果上面结束遍历，但仍有一个集合还有未迭代到的元素，则返回false  return !(e1.hasNext() || e2.hasNext()); } 18. public int hashCode()    返回该列表的hash值。\n此实现完全使用List中hashCode方法的文档中定义列表哈希函数的代码。\n源码如下：\npublic int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; } 19. protected void removeRange(int fromIndex, int toIndex)    从此列表中删除所有索引在fromIndex和toIndex（不含）之间的所有元素。将所有后续元素向左移动（减少其索引）。此调用通过删除toIndex-fromIndex元素来缩短列表。 （如果toIndex == fromIndex，则此操作无效。）\n此列表及其子列表上的clear操作调用此方法。重写此方法以利用列表实现的内部功能可以大大地改善此列表及其子列表上的clear操作的性能。\n此实现获取位于fromIndex之前位置的列表迭代器，并反复调用ListIterator.next，然后依次调用ListIterator.remove，直到删除了整个范围的元素。 注意：如果ListIterator.remove需要线性时间，则此实现需要平方时间。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { // 获取从fromIndex位置的列表迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(fromIndex); // 使用toIndex - fromIndex计算出要删除元素的个数，然后遍历，逐个删除元素  for (int i=0, n=toIndex-fromIndex; i\u0026lt;n; i++) { it.next(); it.remove(); } } 20. protected transient int modCount = 0;    此列表已被结构上修改的次数。结构上修改是指更改列表大小或以其他方式干扰列表的方式，即正在进行的迭代可能会产生错误的结果。\n此字段被iterator和listIterator方法返回的迭代器和列表迭代器的实现所使用。如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException以响应next，remove，previous，set或add操作。面对迭代期间的并发修改，提供了“快速失败”机制，而不是不确定的行为。\n子类对此字段的使用是可选的。如果子类希望提供“快速失败”的迭代器（和列表迭代器），则只需在其add和remove方法（以及它覆盖的所有其他会对列表进行结构修改的方法）。一次调用add或remove应只对此字段加1，否则迭代器（和列表迭代器）将误抛出ConcurrentModificationExceptions。如果实现不希望提供“快速失败”的迭代器，则可以忽略此字段。\n21. private void rangeCheckForAdd(int index)    添加元素到列表之前对要添加元素的位置进行校验，校验方式为：参数中指定的index是否小于0或者大于size()，若是则抛出IndexOutOfBoundsException。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size()) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 22. private String outOfBoundsMsg(int index)    获取一个数组越界的提示信息。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size(); } 同一文件中的其他类    1. class SubList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt;    AbstractList可以截取自身的一截，以SubList的形式返回，SubList也支持增删改查，它持有它的父列表，并提供增删查改操作，所以增删改也会影响到其父列表。\n它更像是其父列表的代理人，对该子列表的任何增删改，它都是通过其父列表的增删改来实现的。\n1.1 private final AbstractList\u0026lt;E\u0026gt; l;    当前SubList实例的父列表（也即当前实例基于的那个列表）。\n1.2 private final int offset;    基于父列表的索引偏移量，用于定位当前列表的位置。\n1.3 private int size;    当前列表的大小。\n1.4 SubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex)    构造方法，构造一个SubList实例。\n源码如下：\nSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { // 先进行校验  if (fromIndex \u0026lt; 0) throw new IndexOutOfBoundsException(\u0026#34;fromIndex = \u0026#34; + fromIndex); if (toIndex \u0026gt; list.size()) throw new IndexOutOfBoundsException(\u0026#34;toIndex = \u0026#34; + toIndex); if (fromIndex \u0026gt; toIndex) throw new IllegalArgumentException(\u0026#34;fromIndex(\u0026#34; + fromIndex + \u0026#34;) \u0026gt; toIndex(\u0026#34; + toIndex + \u0026#34;)\u0026#34;); // 再执行各个属性的初始化  l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; } 1.5 public E set(int index, E element)    替换指定索引位置的元素。\n源码如下：\npublic E set(int index, E element) { // 指定索引的合法性检查  rangeCheck(index); // 检查是否存在并发修改  checkForComodification(); // 调用负列表的set方法进行元素的替换，父列表对应的索引位置为：当前指定的索引 + 偏移量  return l.set(index+offset, element); } 1.6 public E get(int index)    获取指定索引位置的元素。\n源码如下：\npublic E get(int index) { // 与set方法相同的套路，索引范围检查、并发检查、通过父列表获取指定位置的元素  rangeCheck(index); checkForComodification(); return l.get(index+offset); } 1.7 public int size()    获取当前列表的大小。\n源码如下：\npublic int size() { // 先调用checkForComodification进行并发修改检查，再返回size  checkForComodification(); return size; } 1.8 public void add(int index, E element)    在指定的索引位置插入指定元素。\n源码如下：\npublic void add(int index, E element) { rangeCheckForAdd(index); checkForComodification(); // 使用父列表的add方法添加元素  l.add(index+offset, element); // 同步修改次数  this.modCount = l.modCount; size++; } 1.9 public E remove(int index)    删除指定索引位置的元素。\n源码如下：\npublic E remove(int index) { rangeCheck(index); checkForComodification(); // 使用父列表的remove方法删除指定元素  E result = l.remove(index+offset); this.modCount = l.modCount; size--; return result; } 1.10 protected void removeRange(int fromIndex, int toIndex)    删除指定索引范围内的元素。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { checkForComodification(); // 使用父列表的removeRange方法删除元素  l.removeRange(fromIndex+offset, toIndex+offset); this.modCount = l.modCount; size -= (toIndex-fromIndex); } 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前列表的末尾。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 当前列表的末尾并非一定是父列表的末尾，所以此处调用自己的addAll方法将元素插入到本列表末尾（即索引位置为size处）  return addAll(size, c); } 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前列表的指定位置。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 对指定的索引位置index的合法性做检查  rangeCheckForAdd(index); // 指定集合的大小为0，则直接返回false  int cSize = c.size(); if (cSize==0) return false; // 并发修改检查  checkForComodification(); // 调用父类的addAll方法添加指定集合的元素  l.addAll(offset+index, c); this.modCount = l.modCount; size += cSize; return true; } 1.13 public Iterator\u0026lt;E\u0026gt; iterator()    获取一个迭代器，调用父列表的listIterator。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 调用父列表的listIterator()方法  return listIterator(); } 1.14 public ListIterator\u0026lt;E\u0026gt; listIterator(final int index)    获取一个从指定索引位置开始的列表迭代器。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 进行并发修改检查  checkForComodification(); // 指定索引的合法性检查  rangeCheckForAdd(index); // 返回一个实现ListIterator的匿名内部类，首先其持有的也是父类的列表迭代器  // 只是进行操作的时候会加上偏移量  return new ListIterator\u0026lt;E\u0026gt;() { private final ListIterator\u0026lt;E\u0026gt; i = l.listIterator(index+offset); public boolean hasNext() { return nextIndex() \u0026lt; size; } public E next() { if (hasNext()) return i.next(); else throw new NoSuchElementException(); } public boolean hasPrevious() { return previousIndex() \u0026gt;= 0; } public E previous() { if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); } public int nextIndex() { return i.nextIndex() - offset; } public int previousIndex() { return i.previousIndex() - offset; } public void remove() { i.remove(); SubList.this.modCount = l.modCount; size--; } public void set(E e) { i.set(e); } public void add(E e) { i.add(e); SubList.this.modCount = l.modCount; size++; } }; } 1.15 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    返回一个当前类的实例，新实例基于当前子列表。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } 1.16 private void rangeCheck(int index)    范围检查，检查指定的索引是否会造成数组下标越界。\n源码如下：\nprivate void rangeCheck(int index) { if (index \u0026lt; 0 || index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.17 private void rangeCheckForAdd(int index)    新插入元素前对元素插入位置的校验，与rangeCheck类似，不同的是：rangeCheck校验的是index是否小于0或大于等于size，而rangeCheckForAdd校验的是index是否小于0或大于size，因为新增的时候可以在index为size的位置插入元素（也即在列表的末尾插入元素）。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.18 private String outOfBoundsMsg(int index)    整理索引越界时的提示信息，\u0026quot;Index: \u0026quot;+index+\u0026quot;, Size: \u0026quot;+size。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size; } 1.19 private void checkForComodification()    判断是否存在并发修改，判断依据是，当前列表的更新量modCount和其父列表的更新量modCount是否一致，不一致则抛出ConcurrentModificationException。\n源码如下：\nprivate void checkForComodification() { if (this.modCount != l.modCount) throw new ConcurrentModificationException(); } 2. class RandomAccessSubList\u0026lt;E\u0026gt; extends SubList\u0026lt;E\u0026gt; implements RandomAccess    该类是一个随机访问的子列表。\n2.1 RandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex)    构造方法，调用父类SubList的构造方法。\n源码如下：\nRandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { super(list, fromIndex, toIndex); } 2.2 public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex)    返回一个基于当前列表的新RandomAccessSubList实例。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } "},{"id":9,"href":"/jdk8-src-note/java/util/List/","title":"List","parent":"util","content":"  1. int size(); 2. boolean isEmpty(); 3. boolean contains(Object o); 4. Iterator\u0026lt;E\u0026gt; iterator(); 5. Object[] toArray(); 6. \u0026lt;T\u0026gt; T[] toArray(T[] a); 7. boolean add(E e); 8. boolean remove(Object o); 9. boolean containsAll(Collection\u0026lt;?\u0026gt; c); 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); 11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); 12. boolean removeAll(Collection\u0026lt;?\u0026gt; c); 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c); 14. default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c) 16. void clear(); 17. boolean equals(Object o); 18. int hashCode(); 19. E get(int index); 20. E set(int index, E element); 21. void add(int index, E element); 22. E remove(int index); 23. int indexOf(Object o); 24. int lastIndexOf(Object o); 25. ListIterator\u0026lt;E\u0026gt; listIterator(); 26. ListIterator\u0026lt;E\u0026gt; listIterator(int index); 27. List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex); 28. default Spliterator\u0026lt;E\u0026gt; spliterator()     有序集合（也称为sequence）。该接口的用户可以精确控制列表中每个元素的插入位置。用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素。\n与集合不同，列表通常允许重复的元素。更正式地说，列表通常允许成对的元素e1和e2，它们满足e1.equals(e2)，并且如果允许空值，它们通常允许多个空元素。有人希望通过在用户尝试插入重复元素时抛出运行时异常来实现禁止重复的列表，这也并非不可行，但我们希望这种用法很少见。\nList接口在已熟知的Collection 接口的规定之外有一些额外的规定，在iterator，add，remove，equals和hashCode方法上。为了方便起见，还包括其他继承方法的声明。\nList接口提供了四种使用位置（索引）访问列表元素的方法。列表（如Java数组）是从零开始的。请注意，对于某些实现（例如，LinkedList类），这些操作可能在时间上与索引值成比例地执行。因此，如果调用者不知道实现，则遍历列表中的元素通常比对其进行索引更可取。\nList接口提供了一个特殊的迭代器，称为ListIterator，除Iterator接口的常规操作外，它还允许元素插入和替换以及双向访问。它还提供了一种获取列表迭代器的方法，该列表迭代器从列表中的指定位置开始。\nList接口提供了两种搜索指定对象的方法。从性能的角度来看，应谨慎使用这些方法。在许多实现中，它们将执行昂贵的线性搜索。\nList接口提供了两种方法，可以有效地在列表中的任意点插入和删除多个元素。\n注意：虽然允许列表包含自己作为元素，但建议格外小心：equals和hashCode方法在这样的列表上不再有很好的定义。\n一些列表实现对它们可能包含的元素有限制。例如，某些实现禁止使用null元素，而某些实现对其元素类型进行限制。尝试添加不合格的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询不合格元素的存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些将表现出后者。更一般地，尝试对不合格元素进行操作，该操作的完成不会导致将不合格元素插入列表中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n该接口是Java集合框架的成员。\n1. int size();    返回此列表中的元素数。如果此列表包含多于 Integer.MAX_VALUE 个元素，则返回Integer.MAX_VALUE 。\n2. boolean isEmpty();    当前列表不包含元素时返回 true 。\n3. boolean contains(Object o);    如果当前列表包含指定的元素则返回 true 。\n更准确的说，当且仅当列表中至少存在一个元素满足 (o == null ? e == null : o.equals(e) 时返回 true 。\n如果指定的元素类型不匹配，则可以抛出 ClassCastException ，但这是可选操作，也可以不抛出异常。\n如果指定的元素是空，且当前列表不允许空元素，则可以抛出 NullPointerException ，这也是可选操作。\n4. Iterator\u0026lt;E\u0026gt; iterator();    以正确的顺序返回在此列表中的元素上的迭代器。\n5. Object[] toArray();    以正确的顺序（从第一个元素到最后一个元素）返回一个包含此列表中所有元素的数组。\n返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，即使此列表由数组支持，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n6. \u0026lt;T\u0026gt; T[] toArray(T[] a);    返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。\n如果列表适合指定的数组并有剩余空间（即数组中的元素多于列表），则数组中紧接列表末尾的元素将设置为null。 （如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n7. boolean add(E e);    将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制可以添加到此列表的元素。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n8. boolean remove(Object o);    如果存在指定元素，则从列表中删除该元素的第一个匹配项（可选操作）。如果此列表不包含该元素，则它保持不变。更准确的说，删除满足(o==null ? get(i)==null : o.equals(get(i))) 条件的最小索引i的元素（如果存在这样的元素）。如果此列表包含指定的元素（或者等效地，如果此列表由于调用而更改），则返回true。\n9. boolean containsAll(Collection\u0026lt;?\u0026gt; c);    如果此列表包含指定集合的所有元素，则返回true。\n按照指定集合的迭代器返回的顺序（可选操作），将指定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c);    按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c);    将指定集合中的所有元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在此列表中。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n12. boolean removeAll(Collection\u0026lt;?\u0026gt; c);    从此列表中删除指定集合中包含的所有其元素（可选操作）。\n13. boolean retainAll(Collection\u0026lt;?\u0026gt; c);    仅保留此列表中包含的指定集合中的元素（可选操作）。换句话说，从该列表中删除所有未包含在指定集合中的元素。\n14. default void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator)    用指定运算符应用于该元素的结果替换此列表中的每个元素。操作时抛出的错误或运行时异常将中继给调用方。\n对于此list，默认实现等效于：\nfinal ListIterator\u0026lt;E\u0026gt; li = list.listIterator(); while (li.hasNext()) { li.set(operator.apply(li.next())); } 如果列表的列表迭代器不支持set操作，则替换第一个元素时将引发UnsupportedOperationException。\n源码如下：\ndefault void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final ListIterator\u0026lt;E\u0026gt; li = this.listIterator(); // 使用迭代器遍历当前集合  while (li.hasNext()) { // 对遍历到的每个元素执行指定的操作，将得到的返回值替换当前元素  li.set(operator.apply(li.next())); } } 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c)    根据指定的Comparator 所指定的顺序对该列表进行排序。\n此列表中的所有元素必须相互可比，即使用指定的比较器（c.compare(e1, e2)）不得为任何元素例如列表中的e1、e2抛出ClassCastException。\n如果指定的比较器为null，则此列表中的所有元素都必须实现Comparable接口，并且应使用元素的Comparable自然排序。\n该列表必须是可修改的，但无需可调整大小。\n默认实现获取一个包含此列表中所有元素的数组，然后对该数组进行排序，并在此列表上进行迭代，从数组中的相应位置重置每个元素。（这避免了由于尝试对链表进行排序而导致的$n^2$ log(n)的性能开销。）\n此实现是一种稳定的，自适应的，可迭代的合并排序，当对输入数组进行部分排序时，所需的比较少于n lg(n)，而在对输入数组进行随机排序时，它提供了传统合并排序的性能。如果输入数组几乎已排序，则该实现需要大约n个比较。临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n/2对象引用，不一而足。\n该实现在其输入数组中利用了升序和降序的同等优势，并且可以在同一输入数组的不同部分中利用了升序和降序的优势。它非常适合合并两个或多个排序后的数组：简单地将数组连接起来并对排序后的数组进行排序。\n该实现改编自Tim Peters针对Python的列表排序TimSort。它使用了Peter McIlroy的“乐观排序和信息理论复杂性”技术，该技术在1993年1月举行的第四届ACM-SIAM离散算法年会上发表，第467-474页。\n源码如下：\ndefault void sort(Comparator\u0026lt;? super E\u0026gt; c) { // 将当前列表转换为数组a  Object[] a = this.toArray(); // 使用指定的比较器c对数组a进行排序  Arrays.sort(a, (Comparator) c); ListIterator\u0026lt;E\u0026gt; i = this.listIterator(); // 遍历数组a，将每个元素放入当前集合  for (Object e : a) { i.next(); i.set((E) e); } } 16. void clear();    从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n17. boolean equals(Object o);    比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时（如果(e1==null ? e2==null : e1.equals(e2))），才返回true。\n换句话说，如果两个列表包含相同顺序的相同元素，则将两个列表定义为相等。此定义确保equals方法可在List接口的不同实现中正常工作。\n18. int hashCode();    返回此列表的哈希码值。列表的哈希码定义为以下计算的结果：\nint hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); 这样可以确保list1.equals(list2)意味着对于任意两个列表list1和list2均有list1.hashCode()==list2.hashCode()，这是Object中hashCode的基本要求。\n19. E get(int index);    返回列表中指定位置的元素。\n20. E set(int index, E element);    替换列表中指定位置的元素为指定的元素（可选操作），然后将返回被替换掉的元素。\n21. void add(int index, E element);    将指定的元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。\n22. E remove(int index);    删除此列表中指定位置的元素（可选操作）。将所有后续元素向左移动（将其索引减一）。然后返回从列表中删除的元素。\n23. int indexOf(Object o);    返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最小索引i或-1（如果没有这样的索引）。\n24. int lastIndexOf(Object o);    返回指定元素在此列表中最后一次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最大索引i或-1（如果没有这样的索引）。\n25. ListIterator\u0026lt;E\u0026gt; listIterator();    返回此列表中的元素的列表迭代器（按适当顺序）。\n26. ListIterator\u0026lt;E\u0026gt; listIterator(int index);    返回在此列表从指定位置开始的列表迭代器（以适当的顺序）。指定的索引就是初始调用next将返回的第一个元素。初次调用previous将返回指定索引减一的元素。\n27. List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex);    返回此列表在指定的fromIndex（含）和toIndex（不含）之间的视图。 （如果fromIndex和toIndex相等，则返回列表为空。）返回的列表由此列表支持，因此该列表中反映了返回列表中的非结构性更改 ，反之亦然。返回的列表支持此列表支持的所有可选列表操作。\n此方法消除了对显式范围操作（数组通常存在的那种范围）的需要。通过subList视图而不是整个列表，可以对列表进行期望的任何范围操作。例如，以下常见用法从列表中删除了一系列元素：\nlist.subList(from, to).clear(); 可以为indexOf和lastIndexOf构建类似的习惯用法，并且Collections类中的所有语法都可以应用于子列表。\n如果后备列表（即此列表）以除通过返回列表以外的任何其他方式进行结构修改，则此方法返回的列表的语义将变得不确定。（结构修改是指更改此列表大小或以其他方式干扰列表的方式，正在进行的迭代可能会产生不正确的结果。）\n28. default Spliterator\u0026lt;E\u0026gt; spliterator()    创建一个包含此列表所有元素的 Spliterator 。\nSpliterator报告SIZED和ORDERED。实现类应记录其他特征值的报告。\n默认实现从列表的Iterator创建一个延迟绑定的拆分器。该拆分器继承了列表迭代器“快速失败”的属性。\n创建的Spliterator还报告SUBSIZED。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, Spliterator.ORDERED); } "},{"id":10,"href":"/jdk8-src-note/java/util/ListIterator/","title":"ListIterator","parent":"util","content":"  1. boolean hasNext(); 2. E next(); 3. boolean hasPrevious(); 4. E previous(); 5. int nextIndex(); 6. int previousIndex(); 7. void remove(); 8. void set(E e); 9. void add(E e);     列表的迭代器，允许编程者在任一方向上遍历列表，在迭代过程中修改列表，并获取迭代器在列表中的当前位置。ListIterator不持有当前元素，它的游标位置始终位于previous()返回的元素与next()返回的元素之间。 长度为n列表的迭代器具有n+1个可能的光标位置，如下面的插入符号（^）所示：\n Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 注意remove()和set(E e)方法不是根据光标位置定义的。它们被定义为对调用next()或previous()返回的最后一个元素进行操作。 该接口也是Java集合框架的成员接口。它继承于Iterator。\n注：下文中提到的“前”和“后”定义为：\n 前：索引增大的方向 后：索引减小的方向  1. boolean hasNext();    当按照前进的方向遍历一个数组时，如果当前列表迭代器还有其他元素时返回true。（换句话说，如果next()方法能返回一个元素而非抛出一个异常，则返回true）\n2. E next();    返回列表中的下一个元素并向前移动光标位置。 可以重复调用此方法以遍历列表，也可以将其与previous()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有下一个元素时抛出NoSuchElementException。\n3. boolean hasPrevious();    当反向遍历列表时，如果列表迭代器还有其他元素，则返回true。（换句话说，当调用previous()时能返回一个元素而非抛出异常时，返回true）\n4. E previous();    返回列表中的前一个元素，并将光标位置向后移动。可以重复调用此方法以向后遍历列表，也可以将其与next()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有上一个元素时抛出NoSuchElementException。\n5. int nextIndex();    返回下一个元素的索引，也即后续对next()的调用返回的元素。 （如果列表迭代器位于列表的末尾，则返回列表大小。）\n6. int previousIndex();    返回上一个元素的索引，也即后续对previous()调用返回的元素。（如果列表迭代器位于列表的开头，则返回-1）\n7. void remove();    从列表中删除next()或previous()返回的最后一个元素（可选操作）。每次调用next()或previous()时，只能进行一次此调用。仅当在上次调用next()或previous()之后没有调用add()时，才可以进行删除。 当没有调用next()或者previous()就调用remove()方法时或者在最后一次调用next()或previous()后已经调用过add()或remove()，则抛出IllegalStateException。\n8. void set(E e);    将next()或previous()返回的最后一个元素替换为指定的元素（可选操作）。仅在上次调用next()或previous()之后没有调用remove()或add()的情况下才能进行此调用。 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。 当没有调用next()或者previous()就调用set()方法时或者在最后一次调用next()或previous()后调用过add()或remove()，则抛出IllegalStateException。\n9. void add(E e);    将指定的元素插入列表（可选操作）。该元素将立即插入next()返回的元素之前（如果有的话）、previous()返回的元素之后（如果有的话）。 （如果列表不包含任何元素，则新元素将成为列表上的唯一元素。）新元素将插入到游标之前：对next()的后续调用将不受影响，对previous()的后续调用将返回新元素。 （此调用使得调用nextIndex()或previousIndex()返回的值加一。） 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。\n"},{"id":11,"href":"/jdk8-src-note/java/util/Iterator/","title":"Iterator","parent":"util","content":"  1. boolean hasNext() 2. E next() 3. default void remove() 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)   集合上的迭代器。Iterator在Java集合框架中取代Enumeration。迭代器与枚举有两个不同之处：\n 迭代器允许调用者在迭代期间以明确的语义从基础集合中删除元素。 方法名已得到改进。  该接口也是Java集合框架的成员。\n1. boolean hasNext()    如果当前迭代器包含更多元素，则返回true。（换句话说，如果调用next方法将返回一个元素而不是抛出异常，则返回true。）\n2. E next()    返回当前迭代器的下一个元素，如果不存在，则抛出NoSuchElementException。\n3. default void remove()    从基础集合中移除此迭代器返回的最后一个元素（可选操作）。每次调用next方法后只能调用此方法一次。如果在进行迭代时以任何方式修改基础集合，而不是调用此方法，则此时当前迭代器的行为将变得不确定。 可以看到该方法定义中有default关键字，其有一个默认实现，但是此默认执行仅抛出了一个UnsupportedOperationException，并无其他操作。 如果next方法还没有被调用，或者remove方法在最后一次调用next方法之后已经被调用过，则抛出IllegalStateException。\n源码如下：\ndefault void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对剩下的元素执行参数中指定的操作，直到所有元素（即剩下的所有元素）都被处理或者有异常抛出。如果指定了迭代的顺序，操作将按照迭代的顺序执行。 由action引发的异常会被转发给调用者。\n源码如下：\ndefault void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } 测试用例：\n@Test public void testIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); iterator.next(); iterator.next(); iterator.forEachRemaining(System.out::println); } 输出：\n3 4 5 "},{"id":12,"href":"/jdk8-src-note/java/util/AbstractCollection/","title":"AbstractCollection","parent":"util","content":"  1. protected AbstractCollection() 2. public abstract Iterator\u0026lt;E\u0026gt; iterator(); 3. public abstract int size(); 4. public boolean isEmpty() 5. public boolean contains(Object o) 6. public Object[] toArray() 7. public \u0026lt;T\u0026gt; T[] toArray(T[] a) 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 9. private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it) 10. private static int hugeCapacity(int minCapacity) 11. public boolean add(E e) 12. public boolean remove(Object o) 13. public boolean containsAll(Collection\u0026lt;?\u0026gt; c) 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 15. public boolean removeAll(Collection\u0026lt;?\u0026gt; c) 16. public boolean retainAll(Collection\u0026lt;?\u0026gt; c) 17. public void clear() 18. public String toString()     此类提供了Collection接口的基本实现，以最大程度地减少实现此接口所需的工作。\n要实现一个不可修改的集合，编程者只需扩展此类并为iterator和size方法提供实现。 （iterator方法返回的迭代器必须实现hasNext和next。）\n要实现一个可修改的集合，编程者必须另外重写此类的add方法（否则将抛出UnsupportedOperationException），并且iterator方法返回的迭代器必须另外实现其remove方法。\n按Collection照接口规范中的建议，程序员通常应提供void（无参数）的Collection构造函数。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合有更有效的实现，则可以重写这些方法中的每一个。\n该类是Java集合框架中的一员。\n1. protected AbstractCollection()    唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractCollection() { } 2. public abstract Iterator\u0026lt;E\u0026gt; iterator();    抽象方法，返回此集合中所包含元素的迭代器。\n3. public abstract int size();    抽象方法，返回此集合所包含的元素数量。\n4. public boolean isEmpty()    判断当前集合是否为空，底层是通过调用size()获取当前集合的元素数量，然后判断元素数量是否为0。\n源码如下：\npublic boolean isEmpty() { return size() == 0; } 5. public boolean contains(Object o)    此实现对集合中的元素进行迭代，依次检查每个元素是否与参数中给定的元素相等。\n使用该集合的迭代器遍历当前集合，如果参数中给定的参数o为null，则判断当前集合中是否存在为null的元素。如果参数中给定的参数不为null，则通过equals判断当前集合中是否存在和给定元素o相等的元素。\n源码如下：\npublic boolean contains(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false; } 6. public Object[] toArray()    此实现返回一个数组，该数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组连续存在，从索引0开始。返回数组的长度等于迭代器返回的元素数（即使此集合的大小在迭代过程中发生了变化，如果该集合允许在迭代过程中进行并发修改，就可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\npublic Object[] toArray() { // Estimate size of array; be prepared to see more or fewer elements  // 声明一个数组，大小为当前集合的大小（实际元素可能会多也可能会少） \tObject[] r = new Object[size()]; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，截止索引为当前集合的元素个数减1  for (int i = 0; i \u0026lt; r.length; i++) { // 如果未遍历完却发现迭代器已迭代至末尾了，说明元素比期望的要少，此时也不报错，而是复制一个数组返回  if (! it.hasNext()) // fewer elements than expected  return Arrays.copyOf(r, i); r[i] = it.next(); } // 如果遍历完成，但迭代器仍未至末尾，此时调用finishToArray方法重新分配数组并完成剩余元素的填充  return it.hasNext() ? finishToArray(r, it) : r; } 7. public \u0026lt;T\u0026gt; T[] toArray(T[] a)    此实现返回一个数组，此数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组中连续存在，从索引0开始。如果迭代器返回的元素数量太多而无法容纳到指定的数组中，那么元素也会以新分配数组的形式返回，其长度等于迭代器返回的元素数量，即使此集合的大小发生变化（如果在迭代过程中集合允许并发修改，则可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T[] toArray(T[] a) { // Estimate size of array; be prepared to see more or fewer elements  int size = size(); // 声明一个数组r，若指定数组a的容量大于等于集合的元素个数，说明数组a可以容纳当前集合的所有元素，此时r取指定的数组a \t// 否则，说明指定的数组a不足以容纳当前列表的所有元素，此时重新分配一个容量为当前集合元素个数的数组，并赋值给r  T[] r = a.length \u0026gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历集合  for (int i = 0; i \u0026lt; r.length; i++) { // 未遍历结束，但迭代器已至末尾，说明集合的元素在toArray过程中变少了  if (! it.hasNext()) { // fewer elements than expected  if (a == r) { // 如果数组r就是指定的数组a，则此处第i个元素置为null  r[i] = null; // null-terminate  } else if (a.length \u0026lt; i) { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a \t// 如果数组a的长度小于此处i，则复制一个数组返回  return Arrays.copyOf(r, i); } else { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a，且a的长度大于等于i，此时进行数组复制，把r复制给a  System.arraycopy(r, 0, a, 0, i); if (a.length \u0026gt; i) { // 如果a的长度大于i，则i位置的元素置为null  a[i] = null; } } // 返回数组a  return a; } r[i] = (T)it.next(); } // more elements than expected \t// 如果遍历完成，发现仍未至迭代器的末尾，则调用finishToArray重新分配数组并完成剩余元素的填充  return it.hasNext() ? finishToArray(r, it) : r; } 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    可分配的最大数组大小。一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出虚拟机限制。\n9. private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it)    当迭代器返回的元素比预期的多时，在toArray中重新分配正在使用的数组，并完成从迭代器中填充它的操作。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it) { int i = r.length; while (it.hasNext()) { int cap = r.length; // 当指定数组的大小等于当前需要存放元素的数组索引时，进行扩容  if (i == cap) { int newCap = cap + (cap \u0026gt;\u0026gt; 1) + 1; // overflow-conscious code  if (newCap - MAX_ARRAY_SIZE \u0026gt; 0) newCap = hugeCapacity(cap + 1); r = Arrays.copyOf(r, newCap); } // 在数组的i索引位置放置当前遍历到的元素，然后i加1  r[i++] = (T)it.next(); } // trim if overallocated \t// 如果重新分配后数组长度过长，则进行数组复制以实现trim效果  return (i == r.length) ? r : Arrays.copyOf(r, i); } 10. private static int hugeCapacity(int minCapacity)    获取数组的最大容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { // 负数是不可以的，直接抛出异常  if (minCapacity \u0026lt; 0) // overflow  throw new OutOfMemoryError (\u0026#34;Required array size too large\u0026#34;); // 如果最小容量需求大于集合所允许的最大数组容量，则此时取当前虚拟机所支持的Integer最大值 \t// 否则就取集合所允许的最大数组容量  return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 11. public boolean add(E e)    该方法的默认实现为抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { throw new UnsupportedOperationException(); } 12. public boolean remove(Object o)    此实现遍历集合以查找指定的元素。如果找到该元素，则使用迭代器的remove方法从集合中删除该元素。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合包含指定的对象，则此实现将引发UnsupportedOperationException。\n源码如下：\npublic boolean remove(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); // 当指定元素为null时，遍历集合，对每个元素执行 “== null”的判断 \t// 否则，使用equals方法判断，找到对应对象后，使用迭代器的remove方法删除 \t// 从此实现上看，仅删除第一个命中的元素，删除后即返回true  if (o==null) { while (it.hasNext()) { if (it.next()==null) { it.remove(); return true; } } } else { while (it.hasNext()) { if (o.equals(it.next())) { it.remove(); return true; } } } return false; } 13. public boolean containsAll(Collection\u0026lt;?\u0026gt; c)    此实现将遍历给定的集合，依次检查每个元素以查看其是否包含在此集合中。如果所有元素都包含，则返回true，否则返回false。\n源码如下：\npublic boolean containsAll(Collection\u0026lt;?\u0026gt; c) { // 遍历指定集合c，然后调用contains方法判断每一个迭代到的元素是否存在于当前集合中 \t// 发现有一个不包含则直接返回false  for (Object e : c) if (!contains(e)) return false; return true; } 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    此实现遍历给定的集合，并将迭代器返回的每个对象依次添加到此集合。\n请注意，除非重写add（假定指定的集合为非空），否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { boolean modified = false; // 遍历指定的集合c  for (E e : c) // 调用add方法添加元素到当前集合  if (add(e)) modified = true; return modified; } 15. public boolean removeAll(Collection\u0026lt;?\u0026gt; c)    此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合的一个或多个元素，则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean removeAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;?\u0026gt; it = iterator(); // 遍历当前集合  while (it.hasNext()) { // 使用指定集合的contains方法判断是否包含当前迭代到的元素  if (c.contains(it.next())) { // 如果包含，使用迭代器的remove方法删除  it.remove(); modified = true; } } return modified; } 16. public boolean retainAll(Collection\u0026lt;?\u0026gt; c)    此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果没有包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合中一个或多个不存在的元素，则此实现将抛出UnsupportedOperationException。\n总体来说，该方法执行后，当前集合中仅剩余当前集合和指定集合中均存在的元素。\n源码如下：\npublic boolean retainAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合  while (it.hasNext()) { // 如果指定集合中不包含当前迭代到的元素，则将其删除  if (!c.contains(it.next())) { it.remove(); modified = true; } } return modified; } 17. public void clear()    此实现遍历当前集合，并使用Iterator.remove操作删除每个元素。大多数实现可能会选择重写此方法以提高效率。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合非空，则此方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，使用迭代器删除每个元素  while (it.hasNext()) { it.next(); it.remove(); } } 18. public String toString()    返回此集合的字符串表示形式。字符串表示形式包括一个集合元素的列表，这些元素按其迭代器返回的顺序排列，并括在方括号（[]）中。相邻元素由字符,（逗号和空格）分隔。元素通过String的valueOf(Object obj)方法转换为字符串。\n源码如下：\npublic String toString() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 如果当前集合为空，则返回[]  if (! it.hasNext()) return \u0026#34;[]\u0026#34;; // 使用StringBuilder进行拼接  StringBuilder sb = new StringBuilder(); sb.append(\u0026#39;[\u0026#39;); for (;;) { E e = it.next(); // 如果当前元素就是当前集合，则此时使用“(this Collection)”来展示  sb.append(e == this ? \u0026#34;(this Collection)\u0026#34; : e); if (! it.hasNext()) return sb.append(\u0026#39;]\u0026#39;).toString(); sb.append(\u0026#39;,\u0026#39;).append(\u0026#39; \u0026#39;); } } "},{"id":13,"href":"/jdk8-src-note/java/util/Collection/","title":"Collection","parent":"util","content":"  1. int size() 2. boolean isEmpty() 3. boolean contains(Object o) 4. Iterator\u0026lt;E\u0026gt; iterator() 5. Object[] toArray() 6. \u0026lt;T\u0026gt; T[] toArray(T[] a) 7. boolean add(E e) 8. boolean remove(Object o) 9. boolean containsAll(Collection\u0026lt;?\u0026gt; c) 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 11. boolean removeAll(Collection\u0026lt;?\u0026gt; c) 12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c) 14. void clear() 15. boolean equals(Object o) 16. int hashCode() 17. default Spliterator\u0026lt;E\u0026gt; spliterator() 18. default Stream\u0026lt;E\u0026gt; stream() 19. default Stream\u0026lt;E\u0026gt; parallelStream()     Collection接口是集合层次结构中的根接口。集合表示一组对象，每个对象称为元素。有些集合允许重复元素，有些则不允许。有些集合是有序的，有些是无序的。\nJDK没有提供该接口的任何直接实现：它提供了更具体的子接口的实现，如Set和List。此接口通常用于传递集合并在需要最大通用性的地方操作它们。\nBags或multiset（可能包含重复元素的无序集合）应该直接实现这个接口。\n所有通用的Collection实现类（通常通过其某个子接口间接实现Collection）应提供两个“标准”的构造函数：void（无参数）构造函数（该构造函数创建一个空集合），以及一个具有单个类型为Collection的参数的构造函数，该构造函数将创建一个新集合，新集合的元素与参数中指定的Collection的元素相同。实际上，后一个构造函数允许用户复制任何集合，从而生成所需类型的等效集合。但是无法强制执行此约定（因为接口不能包含构造函数），但是Java平台库中的所有通用Collection实现都遵循此约定。\n该接口中包含一些具有“破坏性”的方法，也就是这些方法在被调用时操作集合，但该集合并不支持该操作，此时这些方法将抛出UnsupportedOperationException。在这种情况下，如果调用对集合没有影响，则这些方法可能（但不是必需）抛出UnsupportedOperationException。例如，对不可修改的集合调用addAll方法可能会（但并不一定）引发异常（如果要添加的集合为空的话）。\n一些集合实现对它们可能包含的元素有所限制。例如，某些实现禁止空元素，而有些实现对其元素类型有限制。尝试添加不匹配的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询集合中不匹配的元素是否存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些实现将表现出后者。更普遍的是，尝试对不匹配的元素进行操作，该操作的完成不会将不合格元素插入集合中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n同步策略是由每个集合自己决定的。在没有强有力保证的实现中，调用另一个线程正在改变的集合上的任何方法都可能导致未知的行为；这包括直接调用，将集合传递给可能执行调用的方法，以及使用现有的迭代器检查集合。\n集合框架接口中的许多方法都是根据Object的equals方法定义的。例如，contains方法的规范中说：“当且仅当此集合包含至少一个元素e满足(o==null ? e==null : o.equals(e))时，返回true”。此规范不应解释为暗示使用非空参数o调用Collection.contains时将导致对任何元素e都会调用o.equals(e)。各实现可以自由地进行优化，从而避免equals调用，例如，首先比较两个元素的哈希码。（Object的hashCode()规范保证哈希码不相等的两个对象不能相等。）更普遍的说，只要实现者认为合适，各种集合框架接口的实现都可以自由利用基础Object方法的指定行为。\n一些对集合执行递归遍历的操作可能会失败，但对于集合直接或间接包含其自身的自引用实例除外，包括clone()、equals()、hashCode()、toString()方法。实现类可以选择性地处理自引用场景，但是大多数当前的实现都没有这样做。\n该接口是Java集合框架的成员接口。\n默认的方法实现（继承的或其他）不应用任何同步协议。如果一个集合实现有一个特定的同步协议，那么它必须覆盖默认实现来应用该协议。\n1. int size()    返回当前集合内元素的数量。如果数量超过Integer.MAX_VALUE则返回Integer.MAX_VALUE。\n2. boolean isEmpty()    如果当前集合内没有元素，则返回true。\n3. boolean contains(Object o)    当集合包含指定的元素时返回true。更准确的说，当且仅当集合中至少存在一个元素e能够满足(o==null ? e==null : o.equals(e))时返回true。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素o为空，则抛出NullPointerException。\n4. Iterator\u0026lt;E\u0026gt; iterator()    返回此集合中元素的迭代器。没有关于元素返回顺序的保证（除非此集合是某个提供保证的类的实例）。\n5. Object[] toArray()    返回一个包含此集合中所有元素的数组。如果此集合保证其迭代器返回其元素的顺序，则此方法必须按相同的顺序返回元素。\n返回的数组将是“安全的”，因为此集合不维护对其的引用。 （换句话说，即使此集合是基于数组的，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的api和基于集合的api之间的桥梁。\n6. \u0026lt;T\u0026gt; T[] toArray(T[] a)    返回一个数组，该数组包含此集合中的所有元素。返回数组的运行时类型是指定数组的运行时类型。如果集合符合指定的数组，则在其中返回集合。否则，将使用指定数组的运行时类型和此集合的大小分配新数组。\n如果指定的数组能够容纳集合的所有元素并有剩余空间（即数组中的容量大于集合），则紧接集合结束后的数组中的元素设置为null。（如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n如果此集合保证其迭代器返回元素的顺序，则此方法必须按相同的顺序返回元素。\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的集合。以下代码可用于将集合转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n如果指定数组的运行时类型不是此集合中每个元素的运行时类型的超类型，则抛出ArrayStoreException。\n如果参数中指定的数组a为null，则抛出NullPointerException。\n7. boolean add(E e)    确保此集合包含指定的元素（可选操作）。如果此集合由于调用该方法而更改，则返回true。 （如果此集合不允许重复并且已经包含指定的元素，则返回false。）\n支持此操作的集合可能会对可以添加到此集合的元素加以限制。特别是，某些集合将拒绝添加null元素，而其他集合将对可能添加的元素类型施加限制。集合类应在其文档中明确指定对可以添加哪些元素的限制。\n如果某个集合由于除了已经包含该元素以外的其他原因拒绝添加特定元素，则它必须抛出异常（而不是返回false）。这保留了在此调用返回后集合始终包含指定元素的不变性。\n如果当前集合不支持add操作，则抛出UnsupportedOperationException。\n如果指定元素的类阻止将其添加到此集合中，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n如果元素的某些属性阻止将其添加到此集合中，则抛出IllegalArgumentException。\n如果由于插入限制当前无法添加该元素，则抛出IllegalStateException。\n8. boolean remove(Object o)    如果指定的元素在此集合中存在，则从此集合中删除它（可选操作）。\n更正式地讲，如果存在当前集合中存在一个或多个元素e可以满足(o==null ? e==null : o.equals(e))，则删除该元素e（注：此处源码中明确指出是满足条件的元素全部删除，还是删除其中的一个，它只是说：removes an element e such that ···）。如果此集合包含指定的元素（或者等效地，如果此集合由于调用而更改），则返回true。\n如果当前集合不支持remove操作，则抛出UnsupportedOperationException。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n9. boolean containsAll(Collection\u0026lt;?\u0026gt; c)    如果此集合包含指定集合中的所有元素，则返回true。\n如果指定集合中一个或多个元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的集合包含一个或多个null元素，并且此集合不允许null元素，则抛出NullPointerException。\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定集合中的所有元素添加到此集合中（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （这意味着如果指定的集合就是本集合，并且本集合是非空的，则此次调用的行为是不确定的。）\n11. boolean removeAll(Collection\u0026lt;?\u0026gt; c)    删除也包含在指定集合中的所有此集合的元素（可选操作）。在此调用返回之后，此集合将不包含与指定集合相同的元素。\n12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter)    1.8版本的JDK中新出的方法。删除此集合中满足给定断言的所有元素。在迭代过程中或断言中引发的错误或运行时异常将中继给调用方。\n默认实现使用其iterator遍历集合的所有元素。使用Iterator的remove()方法删除每个匹配的元素。如果集合的迭代器不支持删除，则将在第一个匹配元素上抛出UnsupportedOperationException。\n源码如下：\ndefault boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); while (each.hasNext()) { // 对每个元素执行给定的断言，命中则删除该元素  if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c)    只保留此集合中包含在指定集合中的元素（可选操作）。换句话说，从该集合中删除指定集合中不包含的所有元素。\n14. void clear()    从此集合中删除所有元素（可选操作）。此方法返回后，集合将为空。\n15. boolean equals(Object o)    将指定对象与此集合进行比较以判断是否相等。\n尽管Collection接口没有为Object.equals的常规规定添加任何规定，但是“直接”实现Collection接口的程序员（换句话说，创建Collection但不是Set或List的类）如果选择覆盖Object.equals的话则必须要当心。其实没有必要这样做，最简单的方法是依靠Object的实现，但是实现者可能希望实现“值比较”来代替默认的“引用比较”。（List和Set接口要求进行值比较。）\nObject.equals方法的通用规范规定，equals必须是对称的（换句话说，当且仅当b.equals(a)时a.equals(b)）。 List.equals和Set.equals的约定规定，List仅等于其他List，并且Set仅等于其他Set。因此，如果一个集合类它实现的既不是List也不是Set接口，那么当这个集合与List或Set比较时，它自定义的equals方法必须返回false。（按照这个逻辑，不可能编写一个类能够同时正确地实现List和Set接口的类。）\n16. int hashCode()    返回当前集合的hash code值。尽管Collection接口没有在Object.hashCode方法的常规约定之外添加任何规定，但编程者应注意，任何覆盖Object.equals方法的类还必须重写Object.hashCode方法，以便满足Object.hashCode方法的常规约定。特别是，c1.equals(c2)意味着c1.hashCode()==c2.hashCode()。\n17. default Spliterator\u0026lt;E\u0026gt; spliterator()    在此集合中的元素上创建一个Spliterator。\n实现中应该说明拆分器报告的特征值。如果拆分器报告Spliterator.SIZED并且该集合不包含任何元素，则就不需要报告这些特征值。\n子类应该覆盖默认的实现，以返回一个更高效的拆分器。为了保持stream()和parallelStream()方法的预期惰性行为，拆分器应该具有IMMUTABLE或CONCURRENT的特征，或者是后期绑定。\n如果这些都不可行，则覆盖的类应描述拆分器记录的绑定和结构干扰策略，并应覆盖stream()和parallelStream()方法，以使用拆分器的Supplier创建流，如：\nStream\u0026lt;E\u0026gt; s = StreamSupport.stream(() -\u0026gt; spliterator(), spliteratorCharacteristics) 这些要求确保stream()和parallelStream()方法生成的流将反映在终端流操作启动时集合的内容。\n默认实现通过集合的Iterator创建一个延迟绑定的拆分器。该拆分器继承了集合迭代器快速失败的特性。\n创建的Spliterator报告Spliterator.SIZED。\n创建的Spliterator另外还报告了Spliterator.SUBSIZED。\n如果拆分器没有覆盖任何元素，那么除了SIZED和SUBSIZED之外的其他特征值的报告，不会帮助客户端控制、专门化或简化计算。然而，这确实允许对空集合共享不可变的空拆分器实例（参见Spliterators.emptySpliterator()），并允许客户端确定这样的拆分器是否不包含元素。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, 0); } 18. default Stream\u0026lt;E\u0026gt; stream()    返回以该集合为源的顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现通过集合的Spliterator创建顺序的Stream。\n源码如下：\ndefault Stream\u0026lt;E\u0026gt; stream() { return StreamSupport.stream(spliterator(), false); } 19. default Stream\u0026lt;E\u0026gt; parallelStream()    返回以此集合为源的可能并行的Stream。此方法也允许返回顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现从集合的Spliterator创建并行的Stream。\ndefault Stream\u0026lt;E\u0026gt; parallelStream() { return StreamSupport.stream(spliterator(), true); } "},{"id":14,"href":"/jdk8-src-note/java/util/","title":"util","parent":"java","content":"    AbstractCollection     AbstractList     AbstractSequentialList     ArrayList     Collection     Deque     Iterator     LinkedList     List     ListIterator     Queue     RandomAccess     Vector      "},{"id":15,"href":"/jdk8-src-note/java/","title":"java","parent":"JDK8源码阅读笔记","content":"    util     AbstractCollection     AbstractList     AbstractSequentialList     ArrayList     Collection     Deque     Iterator     LinkedList     List     ListIterator     Queue     RandomAccess     Vector        "},{"id":16,"href":"/jdk8-src-note/categories/","title":"Categories","parent":"JDK8源码阅读笔记","content":""},{"id":17,"href":"/jdk8-src-note/tags/","title":"Tags","parent":"JDK8源码阅读笔记","content":""}]