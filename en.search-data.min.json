[{"id":0,"href":"/jdk8-src-note/","title":"JDK8源码阅读笔记","parent":"","content":""},{"id":1,"href":"/jdk8-src-note/java/util/RandomAccess/","title":"RandomAccess","parent":"util","content":"List 接口的实现类所使用的标记接口，标识出它们支持快速（通常为恒定时间）随机访问。该接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问或顺序访问列表时提供良好的性能。\n当用于操纵随机访问列表（例如ArrayList）的最佳算法应用于顺序访问列表（例如LinkedList）时，会产生二次行为。鼓励通用的列表算法在应用一种算法（如果将其应用于顺序访问列表时会产生较差的性能）之前，检查给定列表是否为此接口的实例（通过instanceof判断），并在必要时更改其行为以确保可接受的性能。\n公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现会提供渐近线性的访问时间（如果它们变得很大），但实际上却是恒定的访问时间。这样的List实现通常应实现此接口。根据经验，对于类的典型实例，在以下场景下当循环1快于循环2时List实现应实现此接口：\n循环1：\nfor (int i=0, n=list.size(); i \u0026lt; n; i++) list.get(i); 循环2：\nfor (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 该接口也是Java集合框架成员。\n"},{"id":2,"href":"/jdk8-src-note/java/util/AbstractList/","title":"AbstractList","parent":"util","content":"  1. protected AbstractList() 2. public boolean add(E e) 3. abstract public E get(int index); 4. public E set(int index, E element) 5. public void add(int index, E element) 6. public E remove(int index) 7. public int indexOf(Object o) 8. public int lastIndexOf(Object o) 9. public void clear() 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 11. public Iteratoriterator() 12. public ListIteratorlistIterator() 13. public ListIteratorlistIterator(final int index) 14. private class Itr implements Iterator  14.1 int cursor = 0; 14.2 int lastRet = -1; 14.3 int expectedModCount = modCount; 14.4 public boolean hasNext() 14.5 public E next() 14.6 public void remove() 14.7 final void checkForComodification()   15. private class ListItr extends Itr implements ListIterator  15.1 ListItr(int index) 15.2 public boolean hasPrevious() 15.3 public E previous() 15.4 public int nextIndex() 15.5 public int previousIndex() 15.6 public void set(E e) 15.7 public void add(E e)   16. public ListsubList(int fromIndex, int toIndex) 17. public boolean equals(Object o) 18. public int hashCode() 19. protected void removeRange(int fromIndex, int toIndex) 20. protected transient int modCount = 0; 21. private void rangeCheckForAdd(int index) 22. private String outOfBoundsMsg(int index) 同一文件中的其他类  1. class SubListextends AbstractList  1.1 private final AbstractListl; 1.2 private final int offset; 1.3 private int size; 1.4 SubList(AbstractListlist, int fromIndex, int toIndex) 1.5 public E set(int index, E element) 1.6 public E get(int index) 1.7 public int size() 1.8 public void add(int index, E element) 1.9 public E remove(int index) 1.10 protected void removeRange(int fromIndex, int toIndex) 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 1.13 public Iteratoriterator() 1.14 public ListIteratorlistIterator(final int index) 1.15 public ListsubList(int fromIndex, int toIndex) 1.16 private void rangeCheck(int index) 1.17 private void rangeCheckForAdd(int index) 1.18 private String outOfBoundsMsg(int index) 1.19 private void checkForComodification()   2. class RandomAccessSubListextends SubListimplements RandomAccess  2.1 RandomAccessSubList(AbstractListlist, int fromIndex, int toIndex) 2.2 public ListsubList(int fromIndex, int toIndex)        此类提供List接口的基本实现，以最大程度地减少实现支持“随机访问”数据存储（例如数组）所需的工作。对于顺序访问数据（例如链表），应优先使用AbstractSequentialList类。\n要实现不可修改的列表，编程者仅需扩展此类并为get和List的size方法提供实现。\n要实现可修改的列表，编程者必须另外重写set方法（否则将抛出UnsupportedOperationException）。如果列表是可变大小的，则程序员必须另外重写add和remove方法。\n根据Collection接口规范中的建议，编程者通常应提供一个void（无参数）的构造函数。\n与其他抽象集合的实现不同，编程者不必提供迭代器实现。迭代器和列表迭代器由此类在“随机访问”方法之上实现：\nget、set、add、remove。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合允许更有效的实现，则可以覆盖这些方法中的每一个。\n该类是Java集合框架的成员。\n1. protected AbstractList()    唯一构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractList() { } 2. public boolean add(E e)    将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制哪些元素可以添加到此列表。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n该方法的实现调用了add(int index, E element)方法，add(int index, E element)的默认实现是抛出UnsupportedOperationException，所以如果不重写它，那么调用当前方法也会抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { add(size(), e); return true; } 3. abstract public E get(int index);    获取列表在指定索引位置的元素。\n4. public E set(int index, E element)    在指定的索引位置设置指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E set(int index, E element) { throw new UnsupportedOperationException(); } 5. public void add(int index, E element)    在指定的索引位置添加指定的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic void add(int index, E element) { throw new UnsupportedOperationException(); } 6. public E remove(int index)    删除指定索引位置的元素，默认实现是抛出UnsupportedOperationException。\n源码如下：\npublic E remove(int index) { throw new UnsupportedOperationException(); } 7. public int indexOf(Object o)    此实现首先获取一个列表迭代器（通过listIterator()）。然后，在列表上进行迭代，直到找到指定的元素或到达列表的末尾。\n此方法，在通过listIterator()方法获取到列表迭代器后，逐个遍历元素：\n如果参数中给定的元素为null则判断next获得的元素是否为null，若是，则返回previousIndex。\n如果参数中给定的元素不为null，则通过equals方法判断next获取的元素是否和参数中给定的元素相同，若相同则返回则返回previousIndex。\n如果未能找到，则返回-1。\n源码如下：\npublic int indexOf(Object o) { // 此处获取的是列表迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(); if (o==null) { while (it.hasNext()) // 此处已调用过next方法，所以一旦命中，需要返回的是previousIndex()  if (it.next()==null) return it.previousIndex(); } else { while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); } return -1; } 8. public int lastIndexOf(Object o)    此实现首先获取一个指向列表末尾的列表迭代器（使用listIterator(size())）。然后，向后迭代列表，直到找到指定的元素，或者到达列表的开头。\n寻找元素的方法和indexOf方法一致，区别在于，本方法是从后往前找，也就是找的是指定的元素在列表中最后一次出现的位置，没找到则返回-1。\n源码如下：\npublic int lastIndexOf(Object o) { // 获取一个从列表末尾开始的迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(size()); if (o==null) { while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); } else { while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); } return -1; } 9. public void clear()    从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n该实现将调用removeRange(0, size())。\n请注意，如果未重写remove(int index)或removeRange(int fromIndex, int toIndex)，本方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { removeRange(0, size()); } 10. public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    此实现在参数中指定的集合上获得一个迭代器并对其进行迭代，使用add(int, E)将从迭代器获得的元素插入到此列表的适当位置，一次插入一个。\n为了提高效率，许多实现将覆盖此方法。\n请注意，除非重写add(int, Object)和add(int, E)，否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断指定的索引是否符合插入位置的范围限制  rangeCheckForAdd(index); boolean modified = false; // 调用遍历指定的集合c，将迭代到的每个元素放入当前集合  for (E e : c) { add(index++, e); modified = true; } return modified; } 11. public Iteratoriterator()    以正确的顺序返回在此列表元素上的迭代器。\n此实现依赖于来源列表的size()，get(int)和remove(int)方法来返回迭代器接口的简单实现。\n请注意，除非重写列表的remove(int)方法，否则此方法返回的迭代器将在调用其remove方法时抛出UnsupportedOperationException。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 返回一个Itr实例  return new Itr(); } 12. public ListIteratorlistIterator()    本方法将调用listIterator(final int index)方法，只不过传入的index为0。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator() { return listIterator(0); } 13. public ListIteratorlistIterator(final int index)    此实现返回ListIterator接口的直接实现，该接口继承了iterator()方法所返回的Iterator接口。ListIterator实现依赖于来源列表的get(int)，set(int, E)，add(int, E)和remove(int)方法。\n请注意，此实现返回的列表迭代器在调用其remove，set和add方法时抛出UnsupportedOperationException，除非列表的remove(int)，set(int, E)和add(int, E)方法已被重写。\n如规范中对modCount字段的描述，该实现在面对并发修改时抛出运行时异常。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 判断index的大小是否符合范围限制  rangeCheckForAdd(index); // 返回一个从index位置开始的ListItr实例  return new ListItr(index); } 14. private class Itr implements Iterator   14.1 int cursor = 0;    迭代器在遍历列表时，游标所在位置。也即后续调用next所返回元素的索引。\n14.2 int lastRet = -1;    最近一次调用next或previous返回的元素的索引。如果通过调用remove删除了此元素，则重置为-1。\n14.3 int expectedModCount = modCount;    迭代器认为来源列表应该具有的modCount值。如果违反了此期望，则说明迭代器已检测到并发修改。\n14.4 public boolean hasNext()    判断是否还有其他元素，如果调用next还能获取到元素，则该方法应返回true。\n源码如下：\npublic boolean hasNext() { // 判断当前游标cursor是否与列表的元素数量相等  return cursor != size(); } 14.5 public E next()    获取下一个元素。\n源码如下：\npublic E next() { // 检查是否存在并发修改  checkForComodification(); try { // 将当前游标位置赋值给变量i  int i = cursor; // 取出当前游标位置的元素，作为next  E next = get(i); // 设置最近返回的元素索引为i  lastRet = i; // 游标后移一位，即在当前值基础上加1  cursor = i + 1; // 返回之前取出的游标位置的元素  return next; } catch (IndexOutOfBoundsException e) { // 遇到数组下标越界异常，先检查是否存在并发修改，如不存在，则抛出无此元素异常  checkForComodification(); throw new NoSuchElementException(); } } 14.6 public void remove()    删除当前元素。\n源码如下：\npublic void remove() { // 如果lastRet小于0，则抛出IllegalStateException  // 这说明要么迭代器初始化好之后还没有调用过next或previous、要么当前元素已被删除了  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 调用列表的remove方法删除lastRet索引位置的元素  AbstractList.this.remove(lastRet); // 如果lastRet小于游标，则需将游标位置前移1位  if (lastRet \u0026lt; cursor) cursor--; // 将lastRet置为-1  lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { // 捕获到IndexOutOfBoundsException则说明存在并发修改，抛出ConcurrentModificationException  throw new ConcurrentModificationException(); } } 14.7 final void checkForComodification()    该方法旨在检查是否存在并发修改，判断方法即判断expectedModCount是否等于modCount，不等于则说明存在并发修改，则抛出ConcurrentModificationException。\n源码如下：\nfinal void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 15. private class ListItr extends Itr implements ListIterator   15.1 ListItr(int index)    构造一个列表迭代器，使用给定的参数index作为当前列表迭代器的游标位置。\n源码如下：\nListItr(int index) { cursor = index; } 15.2 public boolean hasPrevious()    判断当前迭代器前面是否还有元素，判断方法是：当前的游标位置cursor是否为0，为0则说明前面已经没有元素了，此时返回false，否则返回true。\n源码如下：\npublic boolean hasPrevious() { return cursor != 0; } 15.3 public E previous()    获取上一个元素，获取方法为：\n使用当前游标位置减1，算出上一个元素的位置，然后取出该位置的元素，同时设置lastRet和游标位置cursor为该位置，然后返回该元素。\n源码如下：\npublic E previous() { checkForComodification(); try { // 将当前游标的前一位赋值给变量i  int i = cursor - 1; // 获取i位置的元素作为返回值  E previous = get(i); // 将最近返回的索引位置和游标位置均置为i  lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 15.4 public int nextIndex()    获取下一个元素的索引，获取方法是：直接返回当前游标位置cursor。\n源码如下：\npublic int nextIndex() { return cursor; } 15.5 public int previousIndex()    获取上一个元素的索引，获取方法是：返回当前游标位置cursor-1。\n源码如下：\npublic int previousIndex() { return cursor-1; } 15.6 public void set(E e)    设置当前位置（lastRet位置）的元素为参数中给定的元素，也即替换最后一次调用next或previous方法得到的元素。\n首先，判断lastRet是否小于0，小于0说明其还未调用过next或previous或者调用过remove方法已将当前位置的元素删掉或使用add方法添加了元素，如果小于0，则抛出IllegalStateException。然后检查是否存在并发修改，调用AbstractList的set方法进行赋值。\n源码如下：\npublic void set(E e) { // lastRet小于0说明其还未调用过next或previous  // 或者调用过remove方法已将当前位置的元素删掉  // 或者使用add方法添加了元素  if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { // 使用列表的set方法进行元素的替换  AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 15.7 public void add(E e)    首先检查是否存在并发修改，然后在调用AbstractList的add方法在当前游标位置添加给定的元素。然后，将lastRet置为-1，同时将当前游标位置cursor加1。\n源码如下：\npublic void add(E e) { checkForComodification(); try { // 将当前游标的值赋给变量i  int i = cursor; // 调用列表的add方法将指定的元素e插入到列表的i位置处  AbstractList.this.add(i, e); // 设定最近返回的索引位置为-1  lastRet = -1; // 设定当前游标位置加1  cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 16. public ListsubList(int fromIndex, int toIndex)    此实现返回一个AbstractList的子类的列表。子类在私有字段中存储来源列表中子列表的偏移量、子列表的大小（可以在其生存期内更改）以及来源列表的预期modCount值。子类有两种变体，其中一种实现RandomAccess。如果此列表实现RandomAccess，则返回的列表将是实现RandomAccess的子类的实例。\n子类的set(int, E)，get(int)，add(int, E)，remove(int)，addAll(int, Collection)和removeRange(int, int)方法都在对索引进行边界检查并调整了偏移量之后，委派给了抽象列表上的相应方法。 addAll(Collection c)方法仅返回addAll(size, c)。\nlistIterator(int)方法在来源列表的列表迭代器上返回“包装对象”，该列表迭代器是使用来源列表上的相应方法创建的。iterator方法仅返回listIterator()，而size方法仅返回子类的size字段。\n所有方法首先检查来源列表的实际modCount是否等于其期望值，如果不是，则抛出ConcurrentModificationException。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { // 判断当前列表是否是RandomAccess的实例  // 若是，则返回一个RandomAccessSubList实例，否则返回SubList实例  return (this instanceof RandomAccess ? new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex) : new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex)); } 17. public boolean equals(Object o)    比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时，才返回true。 （如果(e1==null ? e2==null : e1.equals(e2))，则两个元素e1和e2是相等。）换句话说，如果两个列表包含相同顺序的相同元素，则定义为相等。\n此实现首先检查指定的对象是否是此列表。如果是，则返回true，如果不是，则检查指定对象是否为列表。如果不是列表，则返回false，如果是列表，则遍历两个列表，比较对应的元素对。如果有任何比较返回false，则此方法返回false。如果一个迭代器在另一个迭代器之前用尽了元素，则返回false（因为列表的长度不相等），否则，当迭代完成时，它将返回true。\n源码如下：\npublic boolean equals(Object o) { // 指定对象等于当前列表则直接返回true  if (o == this) return true; // 指定对象不是List接口的实例则直接返回false  if (!(o instanceof List)) return false; ListIterator\u0026lt;E\u0026gt; e1 = listIterator(); ListIterator\u0026lt;?\u0026gt; e2 = ((List\u0026lt;?\u0026gt;) o).listIterator(); // 同时遍历两个列表  while (e1.hasNext() \u0026amp;\u0026amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); // 如果发现存在一个元素不匹配，则返回false  if (!(o1==null ? o2==null : o1.equals(o2))) return false; } // 如果上面结束遍历，但仍有一个集合还有未迭代到的元素，则返回false  return !(e1.hasNext() || e2.hasNext()); } 18. public int hashCode()    返回该列表的hash值。\n此实现完全使用List中hashCode方法的文档中定义列表哈希函数的代码。\n源码如下：\npublic int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; } 19. protected void removeRange(int fromIndex, int toIndex)    从此列表中删除所有索引在fromIndex和toIndex（不含）之间的所有元素。将所有后续元素向左移动（减少其索引）。此调用通过删除toIndex-fromIndex元素来缩短列表。 （如果toIndex == fromIndex，则此操作无效。）\n此列表及其子列表上的clear操作调用此方法。重写此方法以利用列表实现的内部功能可以大大地改善此列表及其子列表上的clear操作的性能。\n此实现获取位于fromIndex之前位置的列表迭代器，并反复调用ListIterator.next，然后依次调用ListIterator.remove，直到删除了整个范围的元素。 注意：如果ListIterator.remove需要线性时间，则此实现需要平方时间。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { // 获取从fromIndex位置的列表迭代器  ListIterator\u0026lt;E\u0026gt; it = listIterator(fromIndex); // 使用toIndex - fromIndex计算出要删除元素的个数，然后遍历，逐个删除元素  for (int i=0, n=toIndex-fromIndex; i\u0026lt;n; i++) { it.next(); it.remove(); } } 20. protected transient int modCount = 0;    此列表已被结构上修改的次数。结构上修改是指更改列表大小或以其他方式干扰列表的方式，即正在进行的迭代可能会产生错误的结果。\n此字段被iterator和listIterator方法返回的迭代器和列表迭代器的实现所使用。如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException以响应next，remove，previous，set或add操作。面对迭代期间的并发修改，提供了“快速失败”机制，而不是不确定的行为。\n子类对此字段的使用是可选的。如果子类希望提供“快速失败”的迭代器（和列表迭代器），则只需在其add和remove方法（以及它覆盖的所有其他会对列表进行结构修改的方法）。一次调用add或remove应只对此字段加1，否则迭代器（和列表迭代器）将误抛出ConcurrentModificationExceptions。如果实现不希望提供“快速失败”的迭代器，则可以忽略此字段。\n21. private void rangeCheckForAdd(int index)    添加元素到列表之前对要添加元素的位置进行校验，校验方式为：参数中指定的index是否小于0或者大于size()，若是则抛出IndexOutOfBoundsException。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size()) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 22. private String outOfBoundsMsg(int index)    获取一个数组越界的提示信息。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size(); } 同一文件中的其他类    1. class SubListextends AbstractList   AbstractList可以截取自身的一截，以SubList的形式返回，SubList也支持增删改查，它持有它的父列表，并提供增删查改操作，所以增删改也会影响到其父列表。\n它更像是其父列表的代理人，对该子列表的任何增删改，它都是通过其父列表的增删改来实现的。\n1.1 private final AbstractListl;    当前SubList实例的父列表（也即当前实例基于的那个列表）。\n1.2 private final int offset;    基于父列表的索引偏移量，用于定位当前列表的位置。\n1.3 private int size;    当前列表的大小。\n1.4 SubList(AbstractListlist, int fromIndex, int toIndex)    构造方法，构造一个SubList实例。\n源码如下：\nSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { // 先进行校验  if (fromIndex \u0026lt; 0) throw new IndexOutOfBoundsException(\u0026#34;fromIndex = \u0026#34; + fromIndex); if (toIndex \u0026gt; list.size()) throw new IndexOutOfBoundsException(\u0026#34;toIndex = \u0026#34; + toIndex); if (fromIndex \u0026gt; toIndex) throw new IllegalArgumentException(\u0026#34;fromIndex(\u0026#34; + fromIndex + \u0026#34;) \u0026gt; toIndex(\u0026#34; + toIndex + \u0026#34;)\u0026#34;); // 再执行各个属性的初始化  l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; } 1.5 public E set(int index, E element)    替换指定索引位置的元素。\n源码如下：\npublic E set(int index, E element) { // 指定索引的合法性检查  rangeCheck(index); // 检查是否存在并发修改  checkForComodification(); // 调用负列表的set方法进行元素的替换，父列表对应的索引位置为：当前指定的索引 + 偏移量  return l.set(index+offset, element); } 1.6 public E get(int index)    获取指定索引位置的元素。\n源码如下：\npublic E get(int index) { // 与set方法相同的套路，索引范围检查、并发检查、通过父列表获取指定位置的元素  rangeCheck(index); checkForComodification(); return l.get(index+offset); } 1.7 public int size()    获取当前列表的大小。\n源码如下：\npublic int size() { // 先调用checkForComodification进行并发修改检查，再返回size  checkForComodification(); return size; } 1.8 public void add(int index, E element)    在指定的索引位置插入指定元素。\n源码如下：\npublic void add(int index, E element) { rangeCheckForAdd(index); checkForComodification(); // 使用父列表的add方法添加元素  l.add(index+offset, element); // 同步修改次数  this.modCount = l.modCount; size++; } 1.9 public E remove(int index)    删除指定索引位置的元素。\n源码如下：\npublic E remove(int index) { rangeCheck(index); checkForComodification(); // 使用父列表的remove方法删除指定元素  E result = l.remove(index+offset); this.modCount = l.modCount; size--; return result; } 1.10 protected void removeRange(int fromIndex, int toIndex)    删除指定索引范围内的元素。\n源码如下：\nprotected void removeRange(int fromIndex, int toIndex) { checkForComodification(); // 使用父列表的removeRange方法删除元素  l.removeRange(fromIndex+offset, toIndex+offset); this.modCount = l.modCount; size -= (toIndex-fromIndex); } 1.11 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前列表的末尾。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // 当前列表的末尾并非一定是父列表的末尾，所以此处调用自己的addAll方法将元素插入到本列表末尾（即索引位置为size处）  return addAll(size, c); } 1.12 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)    将指定集合内的元素添加到当前列表的指定位置。\n源码如下：\npublic boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 对指定的索引位置index的合法性做检查  rangeCheckForAdd(index); // 指定集合的大小为0，则直接返回false  int cSize = c.size(); if (cSize==0) return false; // 并发修改检查  checkForComodification(); // 调用父类的addAll方法添加指定集合的元素  l.addAll(offset+index, c); this.modCount = l.modCount; size += cSize; return true; } 1.13 public Iteratoriterator()    获取一个迭代器，调用父列表的listIterator。\n源码如下：\npublic Iterator\u0026lt;E\u0026gt; iterator() { // 调用父列表的listIterator()方法  return listIterator(); } 1.14 public ListIteratorlistIterator(final int index)    获取一个从指定索引位置开始的列表迭代器。\n源码如下：\npublic ListIterator\u0026lt;E\u0026gt; listIterator(final int index) { // 进行并发修改检查  checkForComodification(); // 指定索引的合法性检查  rangeCheckForAdd(index); // 返回一个实现ListIterator的匿名内部类，首先其持有的也是父类的列表迭代器  // 只是进行操作的时候会加上偏移量  return new ListIterator\u0026lt;E\u0026gt;() { private final ListIterator\u0026lt;E\u0026gt; i = l.listIterator(index+offset); public boolean hasNext() { return nextIndex() \u0026lt; size; } public E next() { if (hasNext()) return i.next(); else throw new NoSuchElementException(); } public boolean hasPrevious() { return previousIndex() \u0026gt;= 0; } public E previous() { if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); } public int nextIndex() { return i.nextIndex() - offset; } public int previousIndex() { return i.previousIndex() - offset; } public void remove() { i.remove(); SubList.this.modCount = l.modCount; size--; } public void set(E e) { i.set(e); } public void add(E e) { i.add(e); SubList.this.modCount = l.modCount; size++; } }; } 1.15 public ListsubList(int fromIndex, int toIndex)    返回一个当前类的实例，新实例基于当前子列表。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new SubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } 1.16 private void rangeCheck(int index)    范围检查，检查指定的索引是否会造成数组下标越界。\n源码如下：\nprivate void rangeCheck(int index) { if (index \u0026lt; 0 || index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.17 private void rangeCheckForAdd(int index)    新插入元素前对元素插入位置的校验，与rangeCheck类似，不同的是：rangeCheck校验的是index是否小于0或大于等于size，而rangeCheckForAdd校验的是index是否小于0或大于size，因为新增的时候可以在index为size的位置插入元素（也即在列表的末尾插入元素）。\n源码如下：\nprivate void rangeCheckForAdd(int index) { if (index \u0026lt; 0 || index \u0026gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 1.18 private String outOfBoundsMsg(int index)    整理索引越界时的提示信息，\u0026quot;Index: \u0026quot;+index+\u0026quot;, Size: \u0026quot;+size。\n源码如下：\nprivate String outOfBoundsMsg(int index) { return \u0026#34;Index: \u0026#34;+index+\u0026#34;, Size: \u0026#34;+size; } 1.19 private void checkForComodification()    判断是否存在并发修改，判断依据是，当前列表的更新量modCount和其父列表的更新量modCount是否一致，不一致则抛出ConcurrentModificationException。\n源码如下：\nprivate void checkForComodification() { if (this.modCount != l.modCount) throw new ConcurrentModificationException(); } 2. class RandomAccessSubListextends SubListimplements RandomAccess    该类是一个随机访问的子列表。\n2.1 RandomAccessSubList(AbstractListlist, int fromIndex, int toIndex)    构造方法，调用父类SubList的构造方法。\n源码如下：\nRandomAccessSubList(AbstractList\u0026lt;E\u0026gt; list, int fromIndex, int toIndex) { super(list, fromIndex, toIndex); } 2.2 public ListsubList(int fromIndex, int toIndex)    返回一个基于当前列表的新RandomAccessSubList实例。\n源码如下：\npublic List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { return new RandomAccessSubList\u0026lt;\u0026gt;(this, fromIndex, toIndex); } "},{"id":3,"href":"/jdk8-src-note/java/util/List/","title":"List","parent":"util","content":"  1. int size(); 2. boolean isEmpty(); 3. boolean contains(Object o); 4. Iteratoriterator(); 5. Object[] toArray(); 6. T[] toArray(T[] a); 7. boolean add(E e); 8. boolean remove(Object o); 9. boolean containsAll(Collection\u0026lt;?\u0026gt; c); 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c); 11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c); 12. boolean removeAll(Collection\u0026lt;?\u0026gt; c); 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c); 14. default void replaceAll(UnaryOperatoroperator) 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c) 16. void clear(); 17. boolean equals(Object o); 18. int hashCode(); 19. E get(int index); 20. E set(int index, E element); 21. void add(int index, E element); 22. E remove(int index); 23. int indexOf(Object o); 24. int lastIndexOf(Object o); 25. ListIteratorlistIterator(); 26. ListIteratorlistIterator(int index); 27. ListsubList(int fromIndex, int toIndex); 28. default Spliteratorspliterator()    有序集合（也称为sequence）。该接口的用户可以精确控制列表中每个元素的插入位置。用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素。\n与集合不同，列表通常允许重复的元素。更正式地说，列表通常允许成对的元素e1和e2，它们满足e1.equals(e2)，并且如果允许空值，它们通常允许多个空元素。有人希望通过在用户尝试插入重复元素时抛出运行时异常来实现禁止重复的列表，这也并非不可行，但我们希望这种用法很少见。\nList接口在已熟知的Collection 接口的规定之外有一些额外的规定，在iterator，add，remove，equals和hashCode方法上。为了方便起见，还包括其他继承方法的声明。\nList接口提供了四种使用位置（索引）访问列表元素的方法。列表（如Java数组）是从零开始的。请注意，对于某些实现（例如，LinkedList类），这些操作可能在时间上与索引值成比例地执行。因此，如果调用者不知道实现，则遍历列表中的元素通常比对其进行索引更可取。\nList接口提供了一个特殊的迭代器，称为ListIterator，除Iterator接口的常规操作外，它还允许元素插入和替换以及双向访问。它还提供了一种获取列表迭代器的方法，该列表迭代器从列表中的指定位置开始。\nList接口提供了两种搜索指定对象的方法。从性能的角度来看，应谨慎使用这些方法。在许多实现中，它们将执行昂贵的线性搜索。\nList接口提供了两种方法，可以有效地在列表中的任意点插入和删除多个元素。\n注意：虽然允许列表包含自己作为元素，但建议格外小心：equals和hashCode方法在这样的列表上不再有很好的定义。\n一些列表实现对它们可能包含的元素有限制。例如，某些实现禁止使用null元素，而某些实现对其元素类型进行限制。尝试添加不合格的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询不合格元素的存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些将表现出后者。更一般地，尝试对不合格元素进行操作，该操作的完成不会导致将不合格元素插入列表中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n该接口是Java集合框架的成员。\n1. int size();    返回此列表中的元素数。如果此列表包含多于 Integer.MAX_VALUE 个元素，则返回Integer.MAX_VALUE 。\n2. boolean isEmpty();    当前列表不包含元素时返回 true 。\n3. boolean contains(Object o);    如果当前列表包含指定的元素则返回 true 。\n更准确的说，当且仅当列表中至少存在一个元素满足 (o == null ? e == null : o.equals(e) 时返回 true 。\n如果指定的元素类型不匹配，则可以抛出 ClassCastException ，但这是可选操作，也可以不抛出异常。\n如果指定的元素是空，且当前列表不允许空元素，则可以抛出 NullPointerException ，这也是可选操作。\n4. Iteratoriterator();    以正确的顺序返回在此列表中的元素上的迭代器。\n5. Object[] toArray();    以正确的顺序（从第一个元素到最后一个元素）返回一个包含此列表中所有元素的数组。\n返回的数组将是“安全的”，因为此列表不保留对其的引用。 （换句话说，即使此列表由数组支持，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的API和基于集合的API之间的桥梁。\n6. T[] toArray(T[] a);    返回一个数组，该数组按正确的顺序包含此列表中的所有元素（从第一个元素到最后一个元素）；返回数组的运行时类型是指定数组的运行时类型。如果列表适合指定的数组，则将其返回。否则，将使用指定数组的运行时类型和此列表的大小分配一个新数组。\n如果列表适合指定的数组并有剩余空间（即数组中的元素多于列表），则数组中紧接列表末尾的元素将设置为null。 （如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n7. boolean add(E e);    将指定的元素追加到此列表的末尾（可选操作）。\n支持此操作的列表可能会限制可以添加到此列表的元素。特别是，某些列表将拒绝添加空元素，而另一些列表将对可能添加的元素类型施加限制。列表类应在其文档中明确指定对可以添加哪些元素的所有限制。\n8. boolean remove(Object o);    如果存在指定元素，则从列表中删除该元素的第一个匹配项（可选操作）。如果此列表不包含该元素，则它保持不变。更准确的说，删除满足(o==null ? get(i)==null : o.equals(get(i))) 条件的最小索引i的元素（如果存在这样的元素）。如果此列表包含指定的元素（或者等效地，如果此列表由于调用而更改），则返回true。\n9. boolean containsAll(Collection\u0026lt;?\u0026gt; c);    如果此列表包含指定集合的所有元素，则返回true。\n按照指定集合的迭代器返回的顺序（可选操作），将指定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c);    按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n11. boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c);    将指定集合中的所有元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在此列表中。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，并且是非空的，则将发生这种情况。）\n12. boolean removeAll(Collection\u0026lt;?\u0026gt; c);    从此列表中删除指定集合中包含的所有其元素（可选操作）。\n13. boolean retainAll(Collection\u0026lt;?\u0026gt; c);    仅保留此列表中包含的指定集合中的元素（可选操作）。换句话说，从该列表中删除所有未包含在指定集合中的元素。\n14. default void replaceAll(UnaryOperatoroperator)    用指定运算符应用于该元素的结果替换此列表中的每个元素。操作时抛出的错误或运行时异常将中继给调用方。\n对于此list，默认实现等效于：\nfinal ListIterator\u0026lt;E\u0026gt; li = list.listIterator(); while (li.hasNext()) { li.set(operator.apply(li.next())); } 如果列表的列表迭代器不支持set操作，则替换第一个元素时将引发UnsupportedOperationException。\n源码如下：\ndefault void replaceAll(UnaryOperator\u0026lt;E\u0026gt; operator) { Objects.requireNonNull(operator); final ListIterator\u0026lt;E\u0026gt; li = this.listIterator(); // 使用迭代器遍历当前集合  while (li.hasNext()) { // 对遍历到的每个元素执行指定的操作，将得到的返回值替换当前元素  li.set(operator.apply(li.next())); } } 15. default void sort(Comparator\u0026lt;? super E\u0026gt; c)    根据指定的Comparator 所指定的顺序对该列表进行排序。\n此列表中的所有元素必须相互可比，即使用指定的比较器（c.compare(e1, e2)）不得为任何元素例如列表中的e1、e2抛出ClassCastException。\n如果指定的比较器为null，则此列表中的所有元素都必须实现Comparable接口，并且应使用元素的Comparable自然排序。\n该列表必须是可修改的，但无需可调整大小。\n默认实现获取一个包含此列表中所有元素的数组，然后对该数组进行排序，并在此列表上进行迭代，从数组中的相应位置重置每个元素。（这避免了由于尝试对链表进行排序而导致的$n^2$ log(n)的性能开销。）\n此实现是一种稳定的，自适应的，可迭代的合并排序，当对输入数组进行部分排序时，所需的比较少于n lg(n)，而在对输入数组进行随机排序时，它提供了传统合并排序的性能。如果输入数组几乎已排序，则该实现需要大约n个比较。临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n/2对象引用，不一而足。\n该实现在其输入数组中利用了升序和降序的同等优势，并且可以在同一输入数组的不同部分中利用了升序和降序的优势。它非常适合合并两个或多个排序后的数组：简单地将数组连接起来并对排序后的数组进行排序。\n该实现改编自Tim Peters针对Python的列表排序TimSort。它使用了Peter McIlroy的“乐观排序和信息理论复杂性”技术，该技术在1993年1月举行的第四届ACM-SIAM离散算法年会上发表，第467-474页。\n源码如下：\ndefault void sort(Comparator\u0026lt;? super E\u0026gt; c) { // 将当前列表转换为数组a  Object[] a = this.toArray(); // 使用指定的比较器c对数组a进行排序  Arrays.sort(a, (Comparator) c); ListIterator\u0026lt;E\u0026gt; i = this.listIterator(); // 遍历数组a，将每个元素放入当前集合  for (Object e : a) { i.next(); i.set((E) e); } } 16. void clear();    从此列表中删除所有元素（可选操作）。此调用返回后，该列表将为空。\n17. boolean equals(Object o);    比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对都相等时（如果(e1==null ? e2==null : e1.equals(e2))），才返回true。\n换句话说，如果两个列表包含相同顺序的相同元素，则将两个列表定义为相等。此定义确保equals方法可在List接口的不同实现中正常工作。\n18. int hashCode();    返回此列表的哈希码值。列表的哈希码定义为以下计算的结果：\nint hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); 这样可以确保list1.equals(list2)意味着对于任意两个列表list1和list2均有list1.hashCode()==list2.hashCode()，这是Object中hashCode的基本要求。\n19. E get(int index);    返回列表中指定位置的元素。\n20. E set(int index, E element);    替换列表中指定位置的元素为指定的元素（可选操作），然后将返回被替换掉的元素。\n21. void add(int index, E element);    将指定的元素插入此列表中的指定位置（可选操作）。将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。\n22. E remove(int index);    删除此列表中指定位置的元素（可选操作）。将所有后续元素向左移动（将其索引减一）。然后返回从列表中删除的元素。\n23. int indexOf(Object o);    返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最小索引i或-1（如果没有这样的索引）。\n24. int lastIndexOf(Object o);    返回指定元素在此列表中最后一次出现的索引；如果此列表不包含该元素，则返回-1。更准确地说，返回满足(o==null ? get(i)==null : o.equals(get(i)))的最大索引i或-1（如果没有这样的索引）。\n25. ListIteratorlistIterator();    返回此列表中的元素的列表迭代器（按适当顺序）。\n26. ListIteratorlistIterator(int index);    返回在此列表从指定位置开始的列表迭代器（以适当的顺序）。指定的索引就是初始调用next将返回的第一个元素。初次调用previous将返回指定索引减一的元素。\n27. ListsubList(int fromIndex, int toIndex);    返回此列表在指定的fromIndex（含）和toIndex（不含）之间的视图。 （如果fromIndex和toIndex相等，则返回列表为空。）返回的列表由此列表支持，因此该列表中反映了返回列表中的非结构性更改 ，反之亦然。返回的列表支持此列表支持的所有可选列表操作。\n此方法消除了对显式范围操作（数组通常存在的那种范围）的需要。通过subList视图而不是整个列表，可以对列表进行期望的任何范围操作。例如，以下常见用法从列表中删除了一系列元素：\nlist.subList(from, to).clear(); 可以为indexOf和lastIndexOf构建类似的习惯用法，并且Collections类中的所有语法都可以应用于子列表。\n如果后备列表（即此列表）以除通过返回列表以外的任何其他方式进行结构修改，则此方法返回的列表的语义将变得不确定。（结构修改是指更改此列表大小或以其他方式干扰列表的方式，正在进行的迭代可能会产生不正确的结果。）\n28. default Spliteratorspliterator()    创建一个包含此列表所有元素的 Spliterator 。\nSpliterator报告SIZED和ORDERED。实现类应记录其他特征值的报告。\n默认实现从列表的Iterator创建一个延迟绑定的拆分器。该拆分器继承了列表迭代器“快速失败”的属性。\n创建的Spliterator还报告SUBSIZED。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, Spliterator.ORDERED); } "},{"id":4,"href":"/jdk8-src-note/java/util/ListIterator/","title":"ListIterator","parent":"util","content":"  1. boolean hasNext(); 2. E next(); 3. boolean hasPrevious(); 4. E previous(); 5. int nextIndex(); 6. int previousIndex(); 7. void remove(); 8. void set(E e); 9. void add(E e);    列表的迭代器，允许编程者在任一方向上遍历列表，在迭代过程中修改列表，并获取迭代器在列表中的当前位置。ListIterator不持有当前元素，它的游标位置始终位于previous()返回的元素与next()返回的元素之间。 长度为n列表的迭代器具有n+1个可能的光标位置，如下面的插入符号（^）所示：\n Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 注意remove()和set(E e)方法不是根据光标位置定义的。它们被定义为对调用next()或previous()返回的最后一个元素进行操作。 该接口也是Java集合框架的成员接口。它继承于Iterator。\n注：下文中提到的“前”和“后”定义为：\n 前：索引增大的方向 后：索引减小的方向  1. boolean hasNext();    当按照前进的方向遍历一个数组时，如果当前列表迭代器还有其他元素时返回true。（换句话说，如果next()方法能返回一个元素而非抛出一个异常，则返回true）\n2. E next();    返回列表中的下一个元素并向前移动光标位置。 可以重复调用此方法以遍历列表，也可以将其与previous()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有下一个元素时抛出NoSuchElementException。\n3. boolean hasPrevious();    当反向遍历列表时，如果列表迭代器还有其他元素，则返回true。（换句话说，当调用previous()时能返回一个元素而非抛出异常时，返回true）\n4. E previous();    返回列表中的前一个元素，并将光标位置向后移动。可以重复调用此方法以向后遍历列表，也可以将其与next()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有上一个元素时抛出NoSuchElementException。\n5. int nextIndex();    返回下一个元素的索引，也即后续对next()的调用返回的元素。 （如果列表迭代器位于列表的末尾，则返回列表大小。）\n6. int previousIndex();    返回上一个元素的索引，也即后续对previous()调用返回的元素。（如果列表迭代器位于列表的开头，则返回-1）\n7. void remove();    从列表中删除next()或previous()返回的最后一个元素（可选操作）。每次调用next()或previous()时，只能进行一次此调用。仅当在上次调用next()或previous()之后没有调用add()时，才可以进行删除。 当没有调用next()或者previous()就调用remove()方法时或者在最后一次调用next()或previous()后已经调用过add()或remove()，则抛出IllegalStateException。\n8. void set(E e);    将next()或previous()返回的最后一个元素替换为指定的元素（可选操作）。仅在上次调用next()或previous()之后没有调用remove()或add()的情况下才能进行此调用。 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。 当没有调用next()或者previous()就调用set()方法时或者在最后一次调用next()或previous()后调用过add()或remove()，则抛出IllegalStateException。\n9. void add(E e);    将指定的元素插入列表（可选操作）。该元素将立即插入next()返回的元素之前（如果有的话）、previous()返回的元素之后（如果有的话）。 （如果列表不包含任何元素，则新元素将成为列表上的唯一元素。）新元素将插入到游标之前：对next()的后续调用将不受影响，对previous()的后续调用将返回新元素。 （此调用使得调用nextIndex()或previousIndex()返回的值加一。） 如果指定元素的类阻止将其添加到此列表中，则抛出ClassCastException。 如果指定元素的某些切面阻止将其添加到此列表中，则抛出IllegalArgumentException。\n"},{"id":5,"href":"/jdk8-src-note/java/util/Iterator/","title":"Iterator","parent":"util","content":"  1. boolean hasNext() 2. E next() 3. default void remove() 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)   集合上的迭代器。Iterator在Java集合框架中取代Enumeration。迭代器与枚举有两个不同之处：\n 迭代器允许调用者在迭代期间以明确的语义从基础集合中删除元素。 方法名已得到改进。  该接口也是Java集合框架的成员。\n1. boolean hasNext()    如果当前迭代器包含更多元素，则返回true。（换句话说，如果调用next方法将返回一个元素而不是抛出异常，则返回true。）\n2. E next()    返回当前迭代器的下一个元素，如果不存在，则抛出NoSuchElementException。\n3. default void remove()    从基础集合中移除此迭代器返回的最后一个元素（可选操作）。每次调用next方法后只能调用此方法一次。如果在进行迭代时以任何方式修改基础集合，而不是调用此方法，则此时当前迭代器的行为将变得不确定。 可以看到该方法定义中有default关键字，其有一个默认实现，但是此默认执行仅抛出了一个UnsupportedOperationException，并无其他操作。 如果next方法还没有被调用，或者remove方法在最后一次调用next方法之后已经被调用过，则抛出IllegalStateException。\n源码如下：\ndefault void remove() { throw new UnsupportedOperationException(\u0026#34;remove\u0026#34;); } 4. default void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action)    对剩下的元素执行参数中指定的操作，直到所有元素（即剩下的所有元素）都被处理或者有异常抛出。如果指定了迭代的顺序，操作将按照迭代的顺序执行。 由action引发的异常会被转发给调用者。\n源码如下：\ndefault void forEachRemaining(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } 测试用例：\n@Test public void testIterator() { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); iterator.next(); iterator.next(); iterator.forEachRemaining(System.out::println); } 输出：\n3 4 5 "},{"id":6,"href":"/jdk8-src-note/java/util/AbstractCollection/","title":"AbstractCollection","parent":"util","content":"  1. protected AbstractCollection() 2. public abstract Iteratoriterator(); 3. public abstract int size(); 4. public boolean isEmpty() 5. public boolean contains(Object o) 6. public Object[] toArray() 7. public T[] toArray(T[] a) 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 9. private static T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it) 10. private static int hugeCapacity(int minCapacity) 11. public boolean add(E e) 12. public boolean remove(Object o) 13. public boolean containsAll(Collection\u0026lt;?\u0026gt; c) 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 15. public boolean removeAll(Collection\u0026lt;?\u0026gt; c) 16. public boolean retainAll(Collection\u0026lt;?\u0026gt; c) 17. public void clear() 18. public String toString()    此类提供了Collection接口的基本实现，以最大程度地减少实现此接口所需的工作。\n要实现一个不可修改的集合，编程者只需扩展此类并为iterator和size方法提供实现。 （iterator方法返回的迭代器必须实现hasNext和next。）\n要实现一个可修改的集合，编程者必须另外重写此类的add方法（否则将抛出UnsupportedOperationException），并且iterator方法返回的迭代器必须另外实现其remove方法。\n按Collection照接口规范中的建议，程序员通常应提供void（无参数）的Collection构造函数。\n此类中每个非抽象方法的文档都详细描述了其实现。如果正在实现的集合有更有效的实现，则可以重写这些方法中的每一个。\n该类是Java集合框架中的一员。\n1. protected AbstractCollection()    唯一的构造函数。 （用于子类构造函数的调用，通常是隐式的。）\n源码如下：\nprotected AbstractCollection() { } 2. public abstract Iteratoriterator();    抽象方法，返回此集合中所包含元素的迭代器。\n3. public abstract int size();    抽象方法，返回此集合所包含的元素数量。\n4. public boolean isEmpty()    判断当前集合是否为空，底层是通过调用size()获取当前集合的元素数量，然后判断元素数量是否为0。\n源码如下：\npublic boolean isEmpty() { return size() == 0; } 5. public boolean contains(Object o)    此实现对集合中的元素进行迭代，依次检查每个元素是否与参数中给定的元素相等。\n使用该集合的迭代器遍历当前集合，如果参数中给定的参数o为null，则判断当前集合中是否存在为null的元素。如果参数中给定的参数不为null，则通过equals判断当前集合中是否存在和给定元素o相等的元素。\n源码如下：\npublic boolean contains(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false; } 6. public Object[] toArray()    此实现返回一个数组，该数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组连续存在，从索引0开始。返回数组的长度等于迭代器返回的元素数（即使此集合的大小在迭代过程中发生了变化，如果该集合允许在迭代过程中进行并发修改，就可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\npublic Object[] toArray() { // Estimate size of array; be prepared to see more or fewer elements  // 声明一个数组，大小为当前集合的大小（实际元素可能会多也可能会少） \tObject[] r = new Object[size()]; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，截止索引为当前集合的元素个数减1  for (int i = 0; i \u0026lt; r.length; i++) { // 如果未遍历完却发现迭代器已迭代至末尾了，说明元素比期望的要少，此时也不报错，而是复制一个数组返回  if (! it.hasNext()) // fewer elements than expected  return Arrays.copyOf(r, i); r[i] = it.next(); } // 如果遍历完成，但迭代器仍未至末尾，此时调用finishToArray方法重新分配数组并完成剩余元素的填充  return it.hasNext() ? finishToArray(r, it) : r; } 7. public T[] toArray(T[] a)    此实现返回一个数组，此数组包含所有通过该集合的迭代器返回的元素，元素以相同的顺序在数组中连续存在，从索引0开始。如果迭代器返回的元素数量太多而无法容纳到指定的数组中，那么元素也会以新分配数组的形式返回，其长度等于迭代器返回的元素数量，即使此集合的大小发生变化（如果在迭代过程中集合允许并发修改，则可能会发生这种情况）。size方法仅作为优化提示被调用，即使迭代器返回不同数量的元素，也将返回正确的结果。\n该方法等同于：\nList\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;E\u0026gt;(size()); for (E e : this) list.add(e); return list.toArray(); 源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T[] toArray(T[] a) { // Estimate size of array; be prepared to see more or fewer elements  int size = size(); // 声明一个数组r，若指定数组a的容量大于等于集合的元素个数，说明数组a可以容纳当前集合的所有元素，此时r取指定的数组a \t// 否则，说明指定的数组a不足以容纳当前列表的所有元素，此时重新分配一个容量为当前集合元素个数的数组，并赋值给r  T[] r = a.length \u0026gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历集合  for (int i = 0; i \u0026lt; r.length; i++) { // 未遍历结束，但迭代器已至末尾，说明集合的元素在toArray过程中变少了  if (! it.hasNext()) { // fewer elements than expected  if (a == r) { // 如果数组r就是指定的数组a，则此处第i个元素置为null  r[i] = null; // null-terminate  } else if (a.length \u0026lt; i) { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a \t// 如果数组a的长度小于此处i，则复制一个数组返回  return Arrays.copyOf(r, i); } else { // 进入此分支，说明在声明数组r的时候，r是新分配的数组，而非指定的a，且a的长度大于等于i，此时进行数组复制，把r复制给a  System.arraycopy(r, 0, a, 0, i); if (a.length \u0026gt; i) { // 如果a的长度大于i，则i位置的元素置为null  a[i] = null; } } // 返回数组a  return a; } r[i] = (T)it.next(); } // more elements than expected \t// 如果遍历完成，发现仍未至迭代器的末尾，则调用finishToArray重新分配数组并完成剩余元素的填充  return it.hasNext() ? finishToArray(r, it) : r; } 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    可分配的最大数组大小。一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出虚拟机限制。\n9. private static T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it)    当迭代器返回的元素比预期的多时，在toArray中重新分配正在使用的数组，并完成从迭代器中填充它的操作。\n源码如下：\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) private static \u0026lt;T\u0026gt; T[] finishToArray(T[] r, Iterator\u0026lt;?\u0026gt; it) { int i = r.length; while (it.hasNext()) { int cap = r.length; // 当指定数组的大小等于当前需要存放元素的数组索引时，进行扩容  if (i == cap) { int newCap = cap + (cap \u0026gt;\u0026gt; 1) + 1; // overflow-conscious code  if (newCap - MAX_ARRAY_SIZE \u0026gt; 0) newCap = hugeCapacity(cap + 1); r = Arrays.copyOf(r, newCap); } // 在数组的i索引位置放置当前遍历到的元素，然后i加1  r[i++] = (T)it.next(); } // trim if overallocated \t// 如果重新分配后数组长度过长，则进行数组复制以实现trim效果  return (i == r.length) ? r : Arrays.copyOf(r, i); } 10. private static int hugeCapacity(int minCapacity)    获取数组的最大容量。\n源码如下：\nprivate static int hugeCapacity(int minCapacity) { // 负数是不可以的，直接抛出异常  if (minCapacity \u0026lt; 0) // overflow  throw new OutOfMemoryError (\u0026#34;Required array size too large\u0026#34;); // 如果最小容量需求大于集合所允许的最大数组容量，则此时取当前虚拟机所支持的Integer最大值 \t// 否则就取集合所允许的最大数组容量  return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 11. public boolean add(E e)    该方法的默认实现为抛出UnsupportedOperationException。\n源码如下：\npublic boolean add(E e) { throw new UnsupportedOperationException(); } 12. public boolean remove(Object o)    此实现遍历集合以查找指定的元素。如果找到该元素，则使用迭代器的remove方法从集合中删除该元素。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合包含指定的对象，则此实现将引发UnsupportedOperationException。\n源码如下：\npublic boolean remove(Object o) { Iterator\u0026lt;E\u0026gt; it = iterator(); // 当指定元素为null时，遍历集合，对每个元素执行 “== null”的判断 \t// 否则，使用equals方法判断，找到对应对象后，使用迭代器的remove方法删除 \t// 从此实现上看，仅删除第一个命中的元素，删除后即返回true  if (o==null) { while (it.hasNext()) { if (it.next()==null) { it.remove(); return true; } } } else { while (it.hasNext()) { if (o.equals(it.next())) { it.remove(); return true; } } } return false; } 13. public boolean containsAll(Collection\u0026lt;?\u0026gt; c)    此实现将遍历给定的集合，依次检查每个元素以查看其是否包含在此集合中。如果所有元素都包含，则返回true，否则返回false。\n源码如下：\npublic boolean containsAll(Collection\u0026lt;?\u0026gt; c) { // 遍历指定集合c，然后调用contains方法判断每一个迭代到的元素是否存在于当前集合中 \t// 发现有一个不包含则直接返回false  for (Object e : c) if (!contains(e)) return false; return true; } 14. public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    此实现遍历给定的集合，并将迭代器返回的每个对象依次添加到此集合。\n请注意，除非重写add（假定指定的集合为非空），否则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { boolean modified = false; // 遍历指定的集合c  for (E e : c) // 调用add方法添加元素到当前集合  if (add(e)) modified = true; return modified; } 15. public boolean removeAll(Collection\u0026lt;?\u0026gt; c)    此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合的一个或多个元素，则此实现将抛出UnsupportedOperationException。\n源码如下：\npublic boolean removeAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;?\u0026gt; it = iterator(); // 遍历当前集合  while (it.hasNext()) { // 使用指定集合的contains方法判断是否包含当前迭代到的元素  if (c.contains(it.next())) { // 如果包含，使用迭代器的remove方法删除  it.remove(); modified = true; } } return modified; } 16. public boolean retainAll(Collection\u0026lt;?\u0026gt; c)    此实现遍历当前集合，依次检查迭代器返回的每个元素以查看其是否包含在指定的集合中。如果没有包含，则使用迭代器的remove方法将其从此集合中删除。\n请注意，如果iterator方法返回的迭代器未实现remove方法并且此集合的确包含给定集合中一个或多个不存在的元素，则此实现将抛出UnsupportedOperationException。\n总体来说，该方法执行后，当前集合中仅剩余当前集合和指定集合中均存在的元素。\n源码如下：\npublic boolean retainAll(Collection\u0026lt;?\u0026gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合  while (it.hasNext()) { // 如果指定集合中不包含当前迭代到的元素，则将其删除  if (!c.contains(it.next())) { it.remove(); modified = true; } } return modified; } 17. public void clear()    此实现遍历当前集合，并使用Iterator.remove操作删除每个元素。大多数实现可能会选择重写此方法以提高效率。\n请注意，如果此集合的iterator方法返回的迭代器未实现remove方法并且该集合非空，则此方法将抛出UnsupportedOperationException。\n源码如下：\npublic void clear() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 遍历当前集合，使用迭代器删除每个元素  while (it.hasNext()) { it.next(); it.remove(); } } 18. public String toString()    返回此集合的字符串表示形式。字符串表示形式包括一个集合元素的列表，这些元素按其迭代器返回的顺序排列，并括在方括号（[]）中。相邻元素由字符,（逗号和空格）分隔。元素通过String的valueOf(Object obj)方法转换为字符串。\n源码如下：\npublic String toString() { Iterator\u0026lt;E\u0026gt; it = iterator(); // 如果当前集合为空，则返回[]  if (! it.hasNext()) return \u0026#34;[]\u0026#34;; // 使用StringBuilder进行拼接  StringBuilder sb = new StringBuilder(); sb.append(\u0026#39;[\u0026#39;); for (;;) { E e = it.next(); // 如果当前元素就是当前集合，则此时使用“(this Collection)”来展示  sb.append(e == this ? \u0026#34;(this Collection)\u0026#34; : e); if (! it.hasNext()) return sb.append(\u0026#39;]\u0026#39;).toString(); sb.append(\u0026#39;,\u0026#39;).append(\u0026#39; \u0026#39;); } } "},{"id":7,"href":"/jdk8-src-note/java/util/Collection/","title":"Collection","parent":"util","content":"  1. int size() 2. boolean isEmpty() 3. boolean contains(Object o) 4. Iteratoriterator() 5. Object[] toArray() 6. T[] toArray(T[] a) 7. boolean add(E e) 8. boolean remove(Object o) 9. boolean containsAll(Collection\u0026lt;?\u0026gt; c) 10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 11. boolean removeAll(Collection\u0026lt;?\u0026gt; c) 12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c) 14. void clear() 15. boolean equals(Object o) 16. int hashCode() 17. default Spliteratorspliterator() 18. default Streamstream() 19. default StreamparallelStream()    Collection接口是集合层次结构中的根接口。集合表示一组对象，每个对象称为元素。有些集合允许重复元素，有些则不允许。有些集合是有序的，有些是无序的。\nJDK没有提供该接口的任何直接实现：它提供了更具体的子接口的实现，如Set和List。此接口通常用于传递集合并在需要最大通用性的地方操作它们。\nBags或multiset（可能包含重复元素的无序集合）应该直接实现这个接口。\n所有通用的Collection实现类（通常通过其某个子接口间接实现Collection）应提供两个“标准”的构造函数：void（无参数）构造函数（该构造函数创建一个空集合），以及一个具有单个类型为Collection的参数的构造函数，该构造函数将创建一个新集合，新集合的元素与参数中指定的Collection的元素相同。实际上，后一个构造函数允许用户复制任何集合，从而生成所需类型的等效集合。但是无法强制执行此约定（因为接口不能包含构造函数），但是Java平台库中的所有通用Collection实现都遵循此约定。\n该接口中包含一些具有“破坏性”的方法，也就是这些方法在被调用时操作集合，但该集合并不支持该操作，此时这些方法将抛出UnsupportedOperationException。在这种情况下，如果调用对集合没有影响，则这些方法可能（但不是必需）抛出UnsupportedOperationException。例如，对不可修改的集合调用addAll方法可能会（但并不一定）引发异常（如果要添加的集合为空的话）。\n一些集合实现对它们可能包含的元素有所限制。例如，某些实现禁止空元素，而有些实现对其元素类型有限制。尝试添加不匹配的元素会引发未经检查的异常，通常为NullPointerException或ClassCastException。尝试查询集合中不匹配的元素是否存在可能会引发异常，或者可能仅返回false。一些实现将表现出前一种行为，而某些实现将表现出后者。更普遍的是，尝试对不匹配的元素进行操作，该操作的完成不会将不合格元素插入集合中，这可能会导致异常或成功，具体取决于实现方式。此类异常在此接口的规范中标记为“可选”。\n同步策略是由每个集合自己决定的。在没有强有力保证的实现中，调用另一个线程正在改变的集合上的任何方法都可能导致未知的行为；这包括直接调用，将集合传递给可能执行调用的方法，以及使用现有的迭代器检查集合。\n集合框架接口中的许多方法都是根据Object的equals方法定义的。例如，contains方法的规范中说：“当且仅当此集合包含至少一个元素e满足(o==null ? e==null : o.equals(e))时，返回true”。此规范不应解释为暗示使用非空参数o调用Collection.contains时将导致对任何元素e都会调用o.equals(e)。各实现可以自由地进行优化，从而避免equals调用，例如，首先比较两个元素的哈希码。（Object的hashCode()规范保证哈希码不相等的两个对象不能相等。）更普遍的说，只要实现者认为合适，各种集合框架接口的实现都可以自由利用基础Object方法的指定行为。\n一些对集合执行递归遍历的操作可能会失败，但对于集合直接或间接包含其自身的自引用实例除外，包括clone()、equals()、hashCode()、toString()方法。实现类可以选择性地处理自引用场景，但是大多数当前的实现都没有这样做。\n该接口是Java集合框架的成员接口。\n默认的方法实现（继承的或其他）不应用任何同步协议。如果一个集合实现有一个特定的同步协议，那么它必须覆盖默认实现来应用该协议。\n1. int size()    返回当前集合内元素的数量。如果数量超过Integer.MAX_VALUE则返回Integer.MAX_VALUE。\n2. boolean isEmpty()    如果当前集合内没有元素，则返回true。\n3. boolean contains(Object o)    当集合包含指定的元素时返回true。更准确的说，当且仅当集合中至少存在一个元素e能够满足(o==null ? e==null : o.equals(e))时返回true。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素o为空，则抛出NullPointerException。\n4. Iteratoriterator()    返回此集合中元素的迭代器。没有关于元素返回顺序的保证（除非此集合是某个提供保证的类的实例）。\n5. Object[] toArray()    返回一个包含此集合中所有元素的数组。如果此集合保证其迭代器返回其元素的顺序，则此方法必须按相同的顺序返回元素。\n返回的数组将是“安全的”，因为此集合不维护对其的引用。 （换句话说，即使此集合是基于数组的，此方法也必须分配一个新数组）。因此，调用者可以自由修改返回的数组。\n此方法充当基于数组的api和基于集合的api之间的桥梁。\n6. T[] toArray(T[] a)    返回一个数组，该数组包含此集合中的所有元素。返回数组的运行时类型是指定数组的运行时类型。如果集合符合指定的数组，则在其中返回集合。否则，将使用指定数组的运行时类型和此集合的大小分配新数组。\n如果指定的数组能够容纳集合的所有元素并有剩余空间（即数组中的容量大于集合），则紧接集合结束后的数组中的元素设置为null。（如果调用者知道列表不包含任何null元素，则这对于确定列表的长度很有用。）\n如果此集合保证其迭代器返回元素的顺序，则此方法必须按相同的顺序返回元素。\n与toArray()方法类似，此方法充当基于数组的API和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且在某些情况下可以用来节省分配成本。\n假设x是一个已知仅包含字符串的集合。以下代码可用于将集合转储到新分配的String数组中：\nString[] y = x.toArray(new String[0]); 请注意，toArray(new Object[0])在功能上与toArray()相同。\n如果指定数组的运行时类型不是此集合中每个元素的运行时类型的超类型，则抛出ArrayStoreException。\n如果参数中指定的数组a为null，则抛出NullPointerException。\n7. boolean add(E e)    确保此集合包含指定的元素（可选操作）。如果此集合由于调用该方法而更改，则返回true。 （如果此集合不允许重复并且已经包含指定的元素，则返回false。）\n支持此操作的集合可能会对可以添加到此集合的元素加以限制。特别是，某些集合将拒绝添加null元素，而其他集合将对可能添加的元素类型施加限制。集合类应在其文档中明确指定对可以添加哪些元素的限制。\n如果某个集合由于除了已经包含该元素以外的其他原因拒绝添加特定元素，则它必须抛出异常（而不是返回false）。这保留了在此调用返回后集合始终包含指定元素的不变性。\n如果当前集合不支持add操作，则抛出UnsupportedOperationException。\n如果指定元素的类阻止将其添加到此集合中，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n如果元素的某些属性阻止将其添加到此集合中，则抛出IllegalArgumentException。\n如果由于插入限制当前无法添加该元素，则抛出IllegalStateException。\n8. boolean remove(Object o)    如果指定的元素在此集合中存在，则从此集合中删除它（可选操作）。\n更正式地讲，如果存在当前集合中存在一个或多个元素e可以满足(o==null ? e==null : o.equals(e))，则删除该元素e（注：此处源码中明确指出是满足条件的元素全部删除，还是删除其中的一个，它只是说：removes an element e such that ···）。如果此集合包含指定的元素（或者等效地，如果此集合由于调用而更改），则返回true。\n如果当前集合不支持remove操作，则抛出UnsupportedOperationException。\n如果指定元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的元素为null，并且此集合不允许使用null元素，则抛出NullPointerException。\n9. boolean containsAll(Collection\u0026lt;?\u0026gt; c)    如果此集合包含指定集合中的所有元素，则返回true。\n如果指定集合中一个或多个元素的类型与此集合不兼容，则抛出ClassCastException。\n如果指定的集合包含一个或多个null元素，并且此集合不允许null元素，则抛出NullPointerException。\n10. boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)    将指定集合中的所有元素添加到此集合中（可选操作）。如果在操作进行过程中修改了指定的集合，则此操作的行为是不确定的。 （这意味着如果指定的集合就是本集合，并且本集合是非空的，则此次调用的行为是不确定的。）\n11. boolean removeAll(Collection\u0026lt;?\u0026gt; c)    删除也包含在指定集合中的所有此集合的元素（可选操作）。在此调用返回之后，此集合将不包含与指定集合相同的元素。\n12. default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter)    1.8版本的JDK中新出的方法。删除此集合中满足给定断言的所有元素。在迭代过程中或断言中引发的错误或运行时异常将中继给调用方。\n默认实现使用其iterator遍历集合的所有元素。使用Iterator的remove()方法删除每个匹配的元素。如果集合的迭代器不支持删除，则将在第一个匹配元素上抛出UnsupportedOperationException。\n源码如下：\ndefault boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); while (each.hasNext()) { // 对每个元素执行给定的断言，命中则删除该元素  if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } 13. boolean retainAll(Collection\u0026lt;?\u0026gt; c)    只保留此集合中包含在指定集合中的元素（可选操作）。换句话说，从该集合中删除指定集合中不包含的所有元素。\n14. void clear()    从此集合中删除所有元素（可选操作）。此方法返回后，集合将为空。\n15. boolean equals(Object o)    将指定对象与此集合进行比较以判断是否相等。\n尽管Collection接口没有为Object.equals的常规规定添加任何规定，但是“直接”实现Collection接口的程序员（换句话说，创建Collection但不是Set或List的类）如果选择覆盖Object.equals的话则必须要当心。其实没有必要这样做，最简单的方法是依靠Object的实现，但是实现者可能希望实现“值比较”来代替默认的“引用比较”。（List和Set接口要求进行值比较。）\nObject.equals方法的通用规范规定，equals必须是对称的（换句话说，当且仅当b.equals(a)时a.equals(b)）。 List.equals和Set.equals的约定规定，List仅等于其他List，并且Set仅等于其他Set。因此，如果一个集合类它实现的既不是List也不是Set接口，那么当这个集合与List或Set比较时，它自定义的equals方法必须返回false。（按照这个逻辑，不可能编写一个类能够同时正确地实现List和Set接口的类。）\n16. int hashCode()    返回当前集合的hash code值。尽管Collection接口没有在Object.hashCode方法的常规约定之外添加任何规定，但编程者应注意，任何覆盖Object.equals方法的类还必须重写Object.hashCode方法，以便满足Object.hashCode方法的常规约定。特别是，c1.equals(c2)意味着c1.hashCode()==c2.hashCode()。\n17. default Spliteratorspliterator()    在此集合中的元素上创建一个Spliterator。\n实现中应该说明拆分器报告的特征值。如果拆分器报告Spliterator.SIZED并且该集合不包含任何元素，则就不需要报告这些特征值。\n子类应该覆盖默认的实现，以返回一个更高效的拆分器。为了保持stream()和parallelStream()方法的预期惰性行为，拆分器应该具有IMMUTABLE或CONCURRENT的特征，或者是后期绑定。\n如果这些都不可行，则覆盖的类应描述拆分器记录的绑定和结构干扰策略，并应覆盖stream()和parallelStream()方法，以使用拆分器的Supplier创建流，如：\nStream\u0026lt;E\u0026gt; s = StreamSupport.stream(() -\u0026gt; spliterator(), spliteratorCharacteristics) 这些要求确保stream()和parallelStream()方法生成的流将反映在终端流操作启动时集合的内容。\n默认实现通过集合的Iterator创建一个延迟绑定的拆分器。该拆分器继承了集合迭代器快速失败的特性。\n创建的Spliterator报告Spliterator.SIZED。\n创建的Spliterator另外还报告了Spliterator.SUBSIZED。\n如果拆分器没有覆盖任何元素，那么除了SIZED和SUBSIZED之外的其他特征值的报告，不会帮助客户端控制、专门化或简化计算。然而，这确实允许对空集合共享不可变的空拆分器实例（参见Spliterators.emptySpliterator()），并允许客户端确定这样的拆分器是否不包含元素。\n源码如下：\n@Override default Spliterator\u0026lt;E\u0026gt; spliterator() { return Spliterators.spliterator(this, 0); } 18. default Streamstream()    返回以该集合为源的顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现通过集合的Spliterator创建顺序的Stream。\n源码如下：\ndefault Stream\u0026lt;E\u0026gt; stream() { return StreamSupport.stream(spliterator(), false); } 19. default StreamparallelStream()    返回以此集合为源的可能并行的Stream。此方法也允许返回顺序Stream。\n当spliterator()方法无法返回IMMUTABLE，CONCURRENT或延迟绑定的拆分器时，应重写此方法。 （有关详细信息，请参见spliterator()）\n默认实现从集合的Spliterator创建并行的Stream。\ndefault Stream\u0026lt;E\u0026gt; parallelStream() { return StreamSupport.stream(spliterator(), true); } "},{"id":8,"href":"/jdk8-src-note/java/util/","title":"util","parent":"java","content":"    AbstractCollection     AbstractList     Collection     Iterator     List     ListIterator     RandomAccess     "},{"id":9,"href":"/jdk8-src-note/java/","title":"java","parent":"JDK8源码阅读笔记","content":"    util     AbstractCollection     AbstractList     Collection     Iterator     List     ListIterator     RandomAccess       "},{"id":10,"href":"/jdk8-src-note/categories/","title":"Categories","parent":"JDK8源码阅读笔记","content":""},{"id":11,"href":"/jdk8-src-note/tags/","title":"Tags","parent":"JDK8源码阅读笔记","content":""}]