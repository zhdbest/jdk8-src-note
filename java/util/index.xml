<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>util on JDK8源码阅读笔记</title>
    <link>https://hongmao.run/jdk8-src-note/java/util/</link>
    <description>Recent content in util on JDK8源码阅读笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 18 Jul 2021 14:14:04 +0800</lastBuildDate><atom:link href="https://hongmao.run/jdk8-src-note/java/util/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RandomAccess</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/RandomAccess/</link>
      <pubDate>Sat, 31 Jul 2021 10:32:17 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/RandomAccess/</guid>
      <description>List 接口的实现类所使用的标记接口，标识出它们支持快速（通常为恒定时间）随机访问。该接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问或顺序访问列表时提供良好的性能。
当用于操纵随机访问列表（例如ArrayList）的最佳算法应用于顺序访问列表（例如LinkedList）时，会产生二次行为。鼓励通用的列表算法在应用一种算法（如果将其应用于顺序访问列表时会产生较差的性能）之前，检查给定列表是否为此接口的实例（通过instanceof判断），并在必要时更改其行为以确保可接受的性能。
公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些List实现会提供渐近线性的访问时间（如果它们变得很大），但实际上却是恒定的访问时间。这样的List实现通常应实现此接口。根据经验，对于类的典型实例，在以下场景下当循环1快于循环2时List实现应实现此接口：
循环1：
for (int i=0, n=list.size(); i &amp;lt; n; i++) list.get(i); 循环2：
for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 该接口也是Java集合框架成员。</description>
    </item>
    
    <item>
      <title>AbstractList</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/AbstractList/</link>
      <pubDate>Sun, 18 Jul 2021 18:23:58 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/AbstractList/</guid>
      <description>1. protected AbstractList() 2. public boolean add(E e) 3. abstract public E get(int index); 4. public E set(int index, E element) 5. public void add(int index, E element) 6. public E remove(int index) 7. public int indexOf(Object o) 8. public int lastIndexOf(Object o) 9. public void clear() 10. public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) 11. public Iteratoriterator() 12. public ListIteratorlistIterator() 13. public ListIteratorlistIterator(final int index) 14. private class Itr implements Iterator  14.</description>
    </item>
    
    <item>
      <title>List</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/List/</link>
      <pubDate>Sun, 18 Jul 2021 18:23:47 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/List/</guid>
      <description>1. int size(); 2. boolean isEmpty(); 3. boolean contains(Object o); 4. Iteratoriterator(); 5. Object[] toArray(); 6. T[] toArray(T[] a); 7. boolean add(E e); 8. boolean remove(Object o); 9. boolean containsAll(Collection&amp;lt;?&amp;gt; c); 10. boolean addAll(Collection&amp;lt;? extends E&amp;gt; c); 11. boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c); 12. boolean removeAll(Collection&amp;lt;?&amp;gt; c); 13. boolean retainAll(Collection&amp;lt;?&amp;gt; c); 14. default void replaceAll(UnaryOperatoroperator) 15. default void sort(Comparator&amp;lt;? super E&amp;gt; c) 16. void clear(); 17. boolean equals(Object o); 18.</description>
    </item>
    
    <item>
      <title>ListIterator</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/ListIterator/</link>
      <pubDate>Sun, 18 Jul 2021 18:23:38 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/ListIterator/</guid>
      <description>1. boolean hasNext(); 2. E next(); 3. boolean hasPrevious(); 4. E previous(); 5. int nextIndex(); 6. int previousIndex(); 7. void remove(); 8. void set(E e); 9. void add(E e);    列表的迭代器，允许编程者在任一方向上遍历列表，在迭代过程中修改列表，并获取迭代器在列表中的当前位置。ListIterator不持有当前元素，它的游标位置始终位于previous()返回的元素与next()返回的元素之间。 长度为n列表的迭代器具有n+1个可能的光标位置，如下面的插入符号（^）所示：
 Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 注意remove()和set(E e)方法不是根据光标位置定义的。它们被定义为对调用next()或previous()返回的最后一个元素进行操作。 该接口也是Java集合框架的成员接口。它继承于Iterator。
注：下文中提到的“前”和“后”定义为：
 前：索引增大的方向 后：索引减小的方向  1. boolean hasNext();    当按照前进的方向遍历一个数组时，如果当前列表迭代器还有其他元素时返回true。（换句话说，如果next()方法能返回一个元素而非抛出一个异常，则返回true）
2. E next();    返回列表中的下一个元素并向前移动光标位置。 可以重复调用此方法以遍历列表，也可以将其与previous()混合调用。 （请注意，交替调用next()和previous()将重复返回相同的元素。） 当没有下一个元素时抛出NoSuchElementException。</description>
    </item>
    
    <item>
      <title>Iterator</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/Iterator/</link>
      <pubDate>Sun, 18 Jul 2021 18:23:23 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/Iterator/</guid>
      <description>1. boolean hasNext() 2. E next() 3. default void remove() 4. default void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action)   集合上的迭代器。Iterator在Java集合框架中取代Enumeration。迭代器与枚举有两个不同之处：
 迭代器允许调用者在迭代期间以明确的语义从基础集合中删除元素。 方法名已得到改进。  该接口也是Java集合框架的成员。
1. boolean hasNext()    如果当前迭代器包含更多元素，则返回true。（换句话说，如果调用next方法将返回一个元素而不是抛出异常，则返回true。）
2. E next()    返回当前迭代器的下一个元素，如果不存在，则抛出NoSuchElementException。
3. default void remove()    从基础集合中移除此迭代器返回的最后一个元素（可选操作）。每次调用next方法后只能调用此方法一次。如果在进行迭代时以任何方式修改基础集合，而不是调用此方法，则此时当前迭代器的行为将变得不确定。 可以看到该方法定义中有default关键字，其有一个默认实现，但是此默认执行仅抛出了一个UnsupportedOperationException，并无其他操作。 如果next方法还没有被调用，或者remove方法在最后一次调用next方法之后已经被调用过，则抛出IllegalStateException。
源码如下：
default void remove() { throw new UnsupportedOperationException(&amp;#34;remove&amp;#34;); } 4. default void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action)    对剩下的元素执行参数中指定的操作，直到所有元素（即剩下的所有元素）都被处理或者有异常抛出。如果指定了迭代的顺序，操作将按照迭代的顺序执行。 由action引发的异常会被转发给调用者。</description>
    </item>
    
    <item>
      <title>AbstractCollection</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/AbstractCollection/</link>
      <pubDate>Sun, 18 Jul 2021 18:22:49 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/AbstractCollection/</guid>
      <description>1. protected AbstractCollection() 2. public abstract Iteratoriterator(); 3. public abstract int size(); 4. public boolean isEmpty() 5. public boolean contains(Object o) 6. public Object[] toArray() 7. public T[] toArray(T[] a) 8. private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 9. private static T[] finishToArray(T[] r, Iterator&amp;lt;?&amp;gt; it) 10. private static int hugeCapacity(int minCapacity) 11. public boolean add(E e) 12. public boolean remove(Object o) 13. public boolean containsAll(Collection&amp;lt;?&amp;gt; c) 14.</description>
    </item>
    
    <item>
      <title>Collection</title>
      <link>https://hongmao.run/jdk8-src-note/java/util/Collection/</link>
      <pubDate>Sun, 18 Jul 2021 14:38:11 +0800</pubDate>
      
      <guid>https://hongmao.run/jdk8-src-note/java/util/Collection/</guid>
      <description>1. int size() 2. boolean isEmpty() 3. boolean contains(Object o) 4. Iteratoriterator() 5. Object[] toArray() 6. T[] toArray(T[] a) 7. boolean add(E e) 8. boolean remove(Object o) 9. boolean containsAll(Collection&amp;lt;?&amp;gt; c) 10. boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) 11. boolean removeAll(Collection&amp;lt;?&amp;gt; c) 12. default boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter) 13. boolean retainAll(Collection&amp;lt;?&amp;gt; c) 14. void clear() 15. boolean equals(Object o) 16. int hashCode() 17. default Spliteratorspliterator() 18. default Streamstream() 19.</description>
    </item>
    
  </channel>
</rss>
